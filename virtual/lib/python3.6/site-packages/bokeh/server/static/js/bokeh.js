(function(root, factory) {
//  if(typeof exports === 'object' && typeof module === 'object')
//    module.exports = factory();
//  else if(typeof define === 'function' && define.amd)
//    define("Bokeh", [], factory);
//  else if(typeof exports === 'object')
//    exports["Bokeh"] = factory();
//  else
    root["Bokeh"] = factory();
})(this, function() {
  var define;
  return (function(modules, aliases, entry) {
    var cache = {};

    var require = function(name) {
      var id = aliases[name] != null ? aliases[name] : name;

      if (!cache[id]) {
        if (!modules[id]) {
          var err = new Error("Cannot find module '" + name + "'");
          err.code = 'MODULE_NOT_FOUND';
          throw err;
        }

        var module = cache[id] = {exports: {}};
        modules[id].call(module.exports, require, module, module.exports);
      }

      return cache[id].exports;
    }

    var main = require(entry);
    main.require = require;

    main.register_plugin = function(plugin_modules, plugin_aliases, plugin_entry) {
      for (var name in plugin_modules) {
        modules[name] = plugin_modules[name];
      }

      for (var name in plugin_aliases) {
        aliases[name] = plugin_aliases[name];
      }

      var plugin = require(plugin_entry);

      for (var name in plugin) {
        main[name] = plugin[name];
      }

      return plugin;
    }

    return main;
  })
([
/*base*/
function _(require, module, exports) {
    var models = require(135    /* ./models/index */);
    var object_1 = require(30    /* ./core/util/object */);
    exports.overrides = {};
    var _all_models = object_1.clone(models);
    exports.Models = function (name) {
        var model = exports.overrides[name] || _all_models[name];
        if (model == null) {
            throw new Error('Model \'' + name + '\' does not exist. This could be due to a widget\n                     or a custom model not being registered before first usage.');
        }
        return model;
    };
    exports.Models.register = function (name, model) {
        exports.overrides[name] = model;
    };
    exports.Models.unregister = function (name) {
        delete exports.overrides[name];
    };
    exports.Models.register_models = function (models, force, errorFn) {
        if (force === void 0) {
            force = false;
        }
        if (models == null)
            return;
        for (var name_1 in models) {
            var model = models[name_1];
            if (force || !_all_models.hasOwnProperty(name_1))
                _all_models[name_1] = model;
            else if (errorFn != null)
                errorFn(name_1);
            else
                console.warn('Model \'' + name_1 + '\' was already registered');
        }
    };
    exports.register_models = exports.Models.register_models;
    exports.Models.registered_names = function () {
        return Object.keys(_all_models);
    };
    // "index" is a map from the toplevel model IDs rendered by
    // embed.coffee, to the view objects for those models. It doesn't
    // contain all views, only those explicitly rendered to an element
    // by embed.coffee.
    exports.index = {};    
},
/*client/connection*/
function _(require, module, exports) {
    var es6_promise_1 = require(302    /* es6-promise */);
    var logging_1 = require(14    /* core/logging */);
    var document_1 = require(47    /* document */);
    var message_1 = require(245    /* protocol/message */);
    var receiver_1 = require(246    /* protocol/receiver */);
    var session_1 = require(2    /* ./session */);
    exports.DEFAULT_SERVER_WEBSOCKET_URL = 'ws://localhost:5006/ws';
    exports.DEFAULT_SESSION_ID = 'default';
    var _connection_count = 0;
    var ClientConnection = function () {
        function ClientConnection(url, id, args_string, _on_have_session_hook, _on_closed_permanently_hook) {
            if (url === void 0) {
                url = exports.DEFAULT_SERVER_WEBSOCKET_URL;
            }
            if (id === void 0) {
                id = exports.DEFAULT_SESSION_ID;
            }
            if (args_string === void 0) {
                args_string = null;
            }
            if (_on_have_session_hook === void 0) {
                _on_have_session_hook = null;
            }
            if (_on_closed_permanently_hook === void 0) {
                _on_closed_permanently_hook = null;
            }
            this.url = url;
            this.id = id;
            this.args_string = args_string;
            this._on_have_session_hook = _on_have_session_hook;
            this._on_closed_permanently_hook = _on_closed_permanently_hook;
            this._number = _connection_count++;
            this.socket = null;
            this.session = null;
            this.closed_permanently = false;
            this._current_handler = null;
            this._pending_ack = null;
            // null or [resolve,reject]
            this._pending_replies = {};
            // map reqid to [resolve,reject]
            this._receiver = new receiver_1.Receiver();
            logging_1.logger.debug('Creating websocket ' + this._number + ' to \'' + this.url + '\' session \'' + this.id + '\'');
        }
        ClientConnection.prototype.connect = function () {
            var _this = this;
            if (this.closed_permanently)
                return es6_promise_1.Promise.reject(new Error('Cannot connect() a closed ClientConnection'));
            if (this.socket != null)
                return es6_promise_1.Promise.reject(new Error('Already connected'));
            this._pending_replies = {};
            this._current_handler = null;
            try {
                var versioned_url = this.url + '?bokeh-protocol-version=1.0&bokeh-session-id=' + this.id;
                if (this.args_string != null && this.args_string.length > 0)
                    versioned_url += '&' + this.args_string;
                this.socket = new WebSocket(versioned_url);
                return new es6_promise_1.Promise(function (resolve, reject) {
                    // "arraybuffer" gives us binary data we can look at;
                    // if we just needed an opaque blob we could use "blob"
                    _this.socket.binaryType = 'arraybuffer';
                    _this.socket.onopen = function () {
                        return _this._on_open(resolve, reject);
                    };
                    _this.socket.onmessage = function (event) {
                        return _this._on_message(event);
                    };
                    _this.socket.onclose = function (event) {
                        return _this._on_close(event);
                    };
                    _this.socket.onerror = function () {
                        return _this._on_error(reject);
                    };
                });
            } catch (error) {
                logging_1.logger.error('websocket creation failed to url: ' + this.url);
                logging_1.logger.error(' - ' + error);
                return es6_promise_1.Promise.reject(error);
            }
        };
        ClientConnection.prototype.close = function () {
            if (!this.closed_permanently) {
                logging_1.logger.debug('Permanently closing websocket connection ' + this._number);
                this.closed_permanently = true;
                if (this.socket != null)
                    this.socket.close(1000, 'close method called on ClientConnection ' + this._number);
                this.session._connection_closed();
                if (this._on_closed_permanently_hook != null) {
                    this._on_closed_permanently_hook();
                    this._on_closed_permanently_hook = null;
                }
            }
        };
        ClientConnection.prototype._schedule_reconnect = function (milliseconds) {
            var _this = this;
            var retry = function () {
                // TODO commented code below until we fix reconnection to repull
                // the document when required. Otherwise, we get a lot of
                // confusing errors that are causing trouble when debugging.
                /*
            if (this.closed_permanently) {
            */
                if (!_this.closed_permanently)
                    logging_1.logger.info('Websocket connection ' + _this._number + ' disconnected, will not attempt to reconnect');
                return;    /*
            } else {
              logger.debug(`Attempting to reconnect websocket ${this._number}`)
              this.connect()
            }
            */
            };
            setTimeout(retry, milliseconds);
        };
        ClientConnection.prototype.send = function (message) {
            if (this.socket == null)
                throw new Error('not connected so cannot send ' + message);
            message.send(this.socket);
        };
        ClientConnection.prototype.send_with_reply = function (message) {
            var _this = this;
            var promise = new es6_promise_1.Promise(function (resolve, reject) {
                _this._pending_replies[message.msgid()] = [
                    resolve,
                    reject
                ];
                _this.send(message);
            });
            return promise.then(function (message) {
                if (message.msgtype() === 'ERROR')
                    throw new Error('Error reply ' + message.content['text']);
                else
                    return message;
            }, function (error) {
                throw error;
            });
        };
        ClientConnection.prototype._pull_doc_json = function () {
            var message = message_1.Message.create('PULL-DOC-REQ', {});
            var promise = this.send_with_reply(message);
            return promise.then(function (reply) {
                if (!('doc' in reply.content))
                    throw new Error('No \'doc\' field in PULL-DOC-REPLY');
                return reply.content['doc'];
            }, function (error) {
                throw error;
            });
        };
        ClientConnection.prototype._repull_session_doc = function () {
            var _this = this;
            if (this.session == null)
                logging_1.logger.debug('Pulling session for first time');
            else
                logging_1.logger.debug('Repulling session');
            this._pull_doc_json().then(function (doc_json) {
                if (_this.session == null) {
                    if (_this.closed_permanently)
                        logging_1.logger.debug('Got new document after connection was already closed');
                    else {
                        var document_2 = document_1.Document.from_json(doc_json);
                        // Constructing models changes some of their attributes, we deal with that
                        // here. This happens when models set attributes during construction
                        // or initialization.
                        var patch = document_1.Document._compute_patch_since_json(doc_json, document_2);
                        if (patch.events.length > 0) {
                            logging_1.logger.debug('Sending ' + patch.events.length + ' changes from model construction back to server');
                            var patch_message = message_1.Message.create('PATCH-DOC', {}, patch);
                            _this.send(patch_message);
                        }
                        _this.session = new session_1.ClientSession(_this, document_2, _this.id);
                        logging_1.logger.debug('Created a new session from new pulled doc');
                        if (_this._on_have_session_hook != null) {
                            _this._on_have_session_hook(_this.session);
                            _this._on_have_session_hook = null;
                        }
                    }
                } else {
                    _this.session.document.replace_with_json(doc_json);
                    logging_1.logger.debug('Updated existing session with new pulled doc');
                }
            }, function (error) {
                // handling the error here is useless because we wouldn't
                // get errors from the resolve handler above, so see
                // the catch below instead
                throw error;
            }).catch(function (error) {
                if (console.trace != null)
                    console.trace(error);
                logging_1.logger.error('Failed to repull session ' + error);
            });
        };
        ClientConnection.prototype._on_open = function (resolve, reject) {
            var _this = this;
            logging_1.logger.info('Websocket connection ' + this._number + ' is now open');
            this._pending_ack = [
                resolve,
                reject
            ];
            this._current_handler = function (message) {
                _this._awaiting_ack_handler(message);
            };
        };
        ClientConnection.prototype._on_message = function (event) {
            if (this._current_handler == null)
                logging_1.logger.error('Got a message with no current handler set');
            try {
                this._receiver.consume(event.data);
            } catch (e) {
                this._close_bad_protocol(e.toString());
            }
            if (this._receiver.message == null)
                return;
            var msg = this._receiver.message;
            var problem = msg.problem();
            if (problem != null)
                this._close_bad_protocol(problem);
            this._current_handler(msg);
        };
        ClientConnection.prototype._on_close = function (event) {
            var _this = this;
            logging_1.logger.info('Lost websocket ' + this._number + ' connection, ' + event.code + ' (' + event.reason + ')');
            this.socket = null;
            if (this._pending_ack != null) {
                this._pending_ack[1](new Error('Lost websocket connection, ' + event.code + ' (' + event.reason + ')'));
                this._pending_ack = null;
            }
            var pop_pending = function () {
                for (var reqid in _this._pending_replies) {
                    var promise_funcs_1 = _this._pending_replies[reqid];
                    delete _this._pending_replies[reqid];
                    return promise_funcs_1;
                }
                return null;
            };
            var promise_funcs = pop_pending();
            while (promise_funcs != null) {
                promise_funcs[1]('Disconnected');
                promise_funcs = pop_pending();
            }
            if (!this.closed_permanently)
                this._schedule_reconnect(2000);
        };
        ClientConnection.prototype._on_error = function (reject) {
            logging_1.logger.debug('Websocket error on socket ' + this._number);
            reject(new Error('Could not open websocket'));
        };
        ClientConnection.prototype._close_bad_protocol = function (detail) {
            logging_1.logger.error('Closing connection: ' + detail);
            if (this.socket != null)
                this.socket.close(1002, detail);    // 1002 = protocol error
        };
        ClientConnection.prototype._awaiting_ack_handler = function (message) {
            var _this = this;
            if (message.msgtype() === 'ACK') {
                this._current_handler = function (message) {
                    return _this._steady_state_handler(message);
                };
                // Reload any sessions
                // TODO (havocp) there's a race where we might get a PATCH before
                // we send and get a reply to our pulls.
                this._repull_session_doc();
                if (this._pending_ack != null) {
                    this._pending_ack[0](this);
                    this._pending_ack = null;
                }
            } else
                this._close_bad_protocol('First message was not an ACK');
        };
        ClientConnection.prototype._steady_state_handler = function (message) {
            if (message.reqid() in this._pending_replies) {
                var promise_funcs = this._pending_replies[message.reqid()];
                delete this._pending_replies[message.reqid()];
                promise_funcs[0](message);
            } else
                this.session.handle(message);
        };
        return ClientConnection;
    }();
    exports.ClientConnection = ClientConnection;
    // Returns a promise of a ClientSession
    // The returned promise has a close() method in case you want to close before
    // getting a session; session.close() works too once you have a session.
    function pull_session(url, session_id, args_string) {
        var connection;
        var promise = new es6_promise_1.Promise(function (resolve, reject) {
            connection = new ClientConnection(url, session_id, args_string, function (session) {
                try {
                    resolve(session);
                } catch (error) {
                    logging_1.logger.error('Promise handler threw an error, closing session ' + error);
                    session.close();
                    throw error;
                }
            }, function () {
                // we rely on reject() as a no-op if we already resolved
                reject(new Error('Connection was closed before we successfully pulled a session'));
            });
            return connection.connect().then(function (_) {
                return undefined;
            }, function (error) {
                logging_1.logger.error('Failed to connect to Bokeh server ' + error);
                throw error;
            });
        });
        /*
    // add a "close" method to the promise... too weird?
    promise.close = () => {
      connection.close()
    }
    */
        return promise;
    }
    exports.pull_session = pull_session;    
},
/*client/session*/
function _(require, module, exports) {
    var logging_1 = require(14    /* core/logging */);
    var document_1 = require(47    /* document */);
    var message_1 = require(245    /* protocol/message */);
    var ClientSession = function () {
        function ClientSession(_connection, document, id) {
            var _this = this;
            this._connection = _connection;
            this.document = document;
            /*Document*/
            this.id = id;
            this._document_listener = function (event) {
                return _this._document_changed(event);
            };
            this.document.on_change(this._document_listener);
            this.event_manager = this.document.event_manager;
            this.event_manager.session = this;
        }
        ClientSession.prototype.handle = function (message) {
            var msgtype = message.msgtype();
            if (msgtype === 'PATCH-DOC')
                this._handle_patch(message);
            else if (msgtype === 'OK')
                this._handle_ok(message);
            else if (msgtype === 'ERROR')
                this._handle_error(message);
            else
                logging_1.logger.debug('Doing nothing with message ' + message.msgtype());
        };
        ClientSession.prototype.close = function () {
            this._connection.close();
        };
        ClientSession.prototype.send_event = function (event) {
            var message = message_1.Message.create('EVENT', {}, JSON.stringify(event));
            this._connection.send(message);
        };
        /*protected*/
        ClientSession.prototype._connection_closed = function () {
            this.document.remove_on_change(this._document_listener);
        };
        // Sends a request to the server for info about the server, such as its Bokeh
        // version. Returns a promise, the value of the promise is a free-form dictionary
        // of server details.
        ClientSession.prototype.request_server_info = function () {
            var message = message_1.Message.create('SERVER-INFO-REQ', {});
            var promise = this._connection.send_with_reply(message);
            return promise.then(function (reply) {
                return reply.content;
            });
        };
        // Sends some request to the server (no guarantee about which one) and returns
        // a promise which is completed when the server replies. The purpose of this
        // is that if you wait for the promise to be completed, you know the server
        // has processed the request. This is useful when writing tests because once
        // the server has processed this request it should also have processed any
        // events or requests you sent previously, which means you can check for the
        // results of that processing without a race condition. (This assumes the
        // server processes events in sequence, which it mostly has to semantically,
        // since reordering events might change the final state.)
        ClientSession.prototype.force_roundtrip = function () {
            return this.request_server_info().then(function (_) {
                return undefined;
            });
        };
        ClientSession.prototype._document_changed = function (event) {
            // Filter out events that were initiated by the ClientSession itself
            if (event.setter_id === this.id)
                return;
            // Filter out changes to attributes that aren't server-visible
            if (event instanceof document_1.ModelChangedEvent && !(event.attr in event.model.serializable_attributes()))
                return;
            // TODO (havocp) the connection may be closed here, which will
            // cause this send to throw an error - need to deal with it more cleanly.
            var message = message_1.Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]));
            this._connection.send(message);
        };
        ClientSession.prototype._handle_patch = function (message) {
            this.document.apply_json_patch(message.content, message.buffers, this.id);
        };
        ClientSession.prototype._handle_ok = function (message) {
            logging_1.logger.trace('Unhandled OK reply to ' + message.reqid());
        };
        ClientSession.prototype._handle_error = function (message) {
            logging_1.logger.error('Unhandled ERROR reply to ' + message.reqid() + ': ' + message.content['text']);
        };
        return ClientSession;
    }();
    exports.ClientSession = ClientSession;    
},
/*core/bokeh_events*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var logging_1 = require(14    /* ./logging */);
    var object_1 = require(30    /* ./util/object */);
    var event_classes = {};
    function register_event_class(event_name) {
        return function (event_cls) {
            event_cls.prototype.event_name = event_name;
            event_classes[event_name] = event_cls;
        };
    }
    exports.register_event_class = register_event_class;
    function register_with_event(event_cls) {
        var models = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            models[_i - 1] = arguments[_i];
        }
        var applicable_models = event_cls.prototype.applicable_models.concat(models);
        event_cls.prototype.applicable_models = applicable_models;
    }
    exports.register_with_event = register_with_event;
    var BokehEvent = function () {
        function BokehEvent(options) {
            if (options === void 0) {
                options = {};
            }
            this.model_id = null;
            this._options = options;
            if (options.model_id) {
                this.model_id = options.model_id;
            }
        }
        BokehEvent.prototype.set_model_id = function (id) {
            this._options.model_id = id;
            this.model_id = id;
            return this;
        };
        BokehEvent.prototype.is_applicable_to = function (obj) {
            return this.applicable_models.some(function (model) {
                return obj instanceof model;
            });
        };
        BokehEvent.event_class = function (e) {
            // Given an event with a type attribute matching the event_name,
            // return the appropriate BokehEvent class
            if (e.type) {
                return event_classes[e.type];
            } else {
                logging_1.logger.warn('BokehEvent.event_class required events with a string type attribute');
            }
        };
        BokehEvent.prototype.toJSON = function () {
            return {
                event_name: this.event_name,
                event_values: object_1.clone(this._options)
            };
        };
        BokehEvent.prototype._customize_event = function (_model) {
            return this;
        };
        return BokehEvent;
    }();
    exports.BokehEvent = BokehEvent;
    BokehEvent.prototype.applicable_models = [];
    var ButtonClick = function (_super) {
        tslib_1.__extends(ButtonClick, _super);
        function ButtonClick() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ButtonClick = tslib_1.__decorate([register_event_class('button_click')], ButtonClick);
        return ButtonClick;
    }(BokehEvent);
    exports.ButtonClick = ButtonClick;
    // A UIEvent is an event originating on a PlotCanvas this includes
    // DOM events such as keystrokes as well as hammer events and LOD events.
    var UIEvent = function (_super) {
        tslib_1.__extends(UIEvent, _super);
        function UIEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return UIEvent;
    }(BokehEvent);
    exports.UIEvent = UIEvent;
    var LODStart = function (_super) {
        tslib_1.__extends(LODStart, _super);
        function LODStart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LODStart = tslib_1.__decorate([register_event_class('lodstart')], LODStart);
        return LODStart;
    }(UIEvent);
    exports.LODStart = LODStart;
    var LODEnd = function (_super) {
        tslib_1.__extends(LODEnd, _super);
        function LODEnd() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LODEnd = tslib_1.__decorate([register_event_class('lodend')], LODEnd);
        return LODEnd;
    }(UIEvent);
    exports.LODEnd = LODEnd;
    var SelectionGeometry = function (_super) {
        tslib_1.__extends(SelectionGeometry, _super);
        function SelectionGeometry(options) {
            var _this = _super.call(this, options) || this;
            _this.geometry = options.geometry;
            _this.final = options.final;
            return _this;
        }
        SelectionGeometry = tslib_1.__decorate([register_event_class('selectiongeometry')], SelectionGeometry);
        return SelectionGeometry;
    }(UIEvent);
    exports.SelectionGeometry = SelectionGeometry;
    var Reset = function (_super) {
        tslib_1.__extends(Reset, _super);
        function Reset() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Reset = tslib_1.__decorate([register_event_class('reset')], Reset);
        return Reset;
    }(UIEvent);
    exports.Reset = Reset;
    var PointEvent = function (_super) {
        tslib_1.__extends(PointEvent, _super);
        function PointEvent(options) {
            var _this = _super.call(this, options) || this;
            _this.sx = options.sx;
            _this.sy = options.sy;
            _this.x = null;
            _this.y = null;
            return _this;
        }
        PointEvent.from_event = function (e, model_id) {
            if (model_id === void 0) {
                model_id = null;
            }
            return new this({
                sx: e.bokeh['sx'],
                sy: e.bokeh['sy'],
                model_id: model_id
            });
        };
        PointEvent.prototype._customize_event = function (plot) {
            var xscale = plot.plot_canvas.frame.xscales['default'];
            var yscale = plot.plot_canvas.frame.yscales['default'];
            this.x = xscale.invert(this.sx);
            this.y = yscale.invert(this.sy);
            this._options['x'] = this.x;
            this._options['y'] = this.y;
            return this;
        };
        return PointEvent;
    }(UIEvent);
    exports.PointEvent = PointEvent;
    var Pan = function (_super) {
        tslib_1.__extends(Pan, _super);
        function Pan(options) {
            if (options === void 0) {
                options = {};
            }
            var _this = _super.call(this, options) || this;
            _this.delta_x = options.delta_x;
            _this.delta_y = options.delta_y;
            return _this;
        }
        Pan.from_event = function (e, model_id) {
            if (model_id === void 0) {
                model_id = null;
            }
            return new this({
                sx: e.bokeh['sx'],
                sy: e.bokeh['sy'],
                delta_x: e.deltaX,
                delta_y: e.deltaY,
                direction: e.direction,
                model_id: model_id
            });
        };
        Pan = tslib_1.__decorate([register_event_class('pan')], Pan);
        return Pan;
    }(PointEvent);
    exports.Pan = Pan;
    var Pinch = function (_super) {
        tslib_1.__extends(Pinch, _super);
        function Pinch(options) {
            if (options === void 0) {
                options = {};
            }
            var _this = _super.call(this, options) || this;
            _this.scale = options.scale;
            return _this;
        }
        Pinch.from_event = function (e, model_id) {
            if (model_id === void 0) {
                model_id = null;
            }
            return new this({
                sx: e.bokeh['sx'],
                sy: e.bokeh['sy'],
                scale: e.scale,
                model_id: model_id
            });
        };
        Pinch = tslib_1.__decorate([register_event_class('pinch')], Pinch);
        return Pinch;
    }(PointEvent);
    exports.Pinch = Pinch;
    var MouseWheel = function (_super) {
        tslib_1.__extends(MouseWheel, _super);
        function MouseWheel(options) {
            if (options === void 0) {
                options = {};
            }
            var _this = _super.call(this, options) || this;
            _this.delta = options.delta;
            return _this;
        }
        MouseWheel.from_event = function (e, model_id) {
            if (model_id === void 0) {
                model_id = null;
            }
            return new this({
                sx: e.bokeh['sx'],
                sy: e.bokeh['sy'],
                delta: e.bokeh['delta'],
                model_id: model_id
            });
        };
        MouseWheel = tslib_1.__decorate([register_event_class('wheel')], MouseWheel);
        return MouseWheel;
    }(PointEvent);
    exports.MouseWheel = MouseWheel;
    var MouseMove = function (_super) {
        tslib_1.__extends(MouseMove, _super);
        function MouseMove() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MouseMove = tslib_1.__decorate([register_event_class('mousemove')], MouseMove);
        return MouseMove;
    }(PointEvent);
    exports.MouseMove = MouseMove;
    var MouseEnter = function (_super) {
        tslib_1.__extends(MouseEnter, _super);
        function MouseEnter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MouseEnter = tslib_1.__decorate([register_event_class('mouseenter')], MouseEnter);
        return MouseEnter;
    }(PointEvent);
    exports.MouseEnter = MouseEnter;
    var MouseLeave = function (_super) {
        tslib_1.__extends(MouseLeave, _super);
        function MouseLeave() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MouseLeave = tslib_1.__decorate([register_event_class('mouseleave')], MouseLeave);
        return MouseLeave;
    }(PointEvent);
    exports.MouseLeave = MouseLeave;
    var Tap = function (_super) {
        tslib_1.__extends(Tap, _super);
        function Tap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Tap = tslib_1.__decorate([register_event_class('tap')], Tap);
        return Tap;
    }(PointEvent);
    exports.Tap = Tap;
    var DoubleTap = function (_super) {
        tslib_1.__extends(DoubleTap, _super);
        function DoubleTap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DoubleTap = tslib_1.__decorate([register_event_class('doubletap')], DoubleTap);
        return DoubleTap;
    }(PointEvent);
    exports.DoubleTap = DoubleTap;
    var Press = function (_super) {
        tslib_1.__extends(Press, _super);
        function Press() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Press = tslib_1.__decorate([register_event_class('press')], Press);
        return Press;
    }(PointEvent);
    exports.Press = Press;
    var PanStart = function (_super) {
        tslib_1.__extends(PanStart, _super);
        function PanStart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PanStart = tslib_1.__decorate([register_event_class('panstart')], PanStart);
        return PanStart;
    }(PointEvent);
    exports.PanStart = PanStart;
    var PanEnd = function (_super) {
        tslib_1.__extends(PanEnd, _super);
        function PanEnd() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PanEnd = tslib_1.__decorate([register_event_class('panend')], PanEnd);
        return PanEnd;
    }(PointEvent);
    exports.PanEnd = PanEnd;
    var PinchStart = function (_super) {
        tslib_1.__extends(PinchStart, _super);
        function PinchStart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PinchStart = tslib_1.__decorate([register_event_class('pinchstart')], PinchStart);
        return PinchStart;
    }(PointEvent);
    exports.PinchStart = PinchStart;
    var PinchEnd = function (_super) {
        tslib_1.__extends(PinchEnd, _super);
        function PinchEnd() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PinchEnd = tslib_1.__decorate([register_event_class('pinchend')], PinchEnd);
        return PinchEnd;
    }(PointEvent);
    exports.PinchEnd = PinchEnd;    
},
/*core/build_views*/
function _(require, module, exports) {
    var array_1 = require(22    /* ./util/array */);
    var object_1 = require(30    /* ./util/object */);
    function build_views(view_storage, models, options, cls) {
        if (cls === void 0) {
            cls = function (model) {
                return model.default_view;
            };
        }
        var to_remove = array_1.difference(Object.keys(view_storage), models.map(function (model) {
            return model.id;
        }));
        for (var _i = 0, to_remove_1 = to_remove; _i < to_remove_1.length; _i++) {
            var model_id = to_remove_1[_i];
            view_storage[model_id].remove();
            delete view_storage[model_id];
        }
        var created_views = [];
        var new_models = models.filter(function (model) {
            return view_storage[model.id] == null;
        });
        for (var _a = 0, new_models_1 = new_models; _a < new_models_1.length; _a++) {
            var model = new_models_1[_a];
            var view_cls = cls(model);
            var view_options = object_1.extend({}, options, {
                model: model,
                connect_signals: false
            });
            var view = new view_cls(view_options);
            view_storage[model.id] = view;
            created_views.push(view);
        }
        for (var _b = 0, created_views_1 = created_views; _b < created_views_1.length; _b++) {
            var view = created_views_1[_b];
            view.connect_signals();
        }
        return created_views;
    }
    exports.build_views = build_views;
    function remove_views(view_storage) {
        for (var id in view_storage) {
            view_storage[id].remove();
            delete view_storage[id];
        }
    }
    exports.remove_views = remove_views;    
},
/*core/dom*/
function _(require, module, exports) {
    var types_1 = require(42    /* ./util/types */);
    var _createElement = function (tag) {
        return function (attrs) {
            if (attrs === void 0) {
                attrs = {};
            }
            var children = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                children[_i - 1] = arguments[_i];
            }
            var element = document.createElement(tag);
            for (var attr in attrs) {
                var value = attrs[attr];
                if (value == null || types_1.isBoolean(value) && !value)
                    continue;
                if (attr === 'class' && types_1.isArray(value)) {
                    for (var _a = 0, _b = value; _a < _b.length; _a++) {
                        var cls = _b[_a];
                        if (cls != null)
                            element.classList.add(cls);
                    }
                    continue;
                }
                if (attr === 'style' && types_1.isObject(value)) {
                    for (var prop in value) {
                        element.style[prop] = value[prop];
                    }
                    continue;
                }
                if (attr === 'data' && types_1.isObject(value)) {
                    for (var key in value) {
                        element.dataset[key] = value[key];
                    }
                    continue;
                }
                element.setAttribute(attr, value);
            }
            function append(child) {
                if (child instanceof HTMLElement)
                    element.appendChild(child);
                else if (types_1.isString(child))
                    element.appendChild(document.createTextNode(child));
                else if (child != null && child !== false)
                    throw new Error('expected an HTMLElement, string, false or null, got ' + JSON.stringify(child));
            }
            for (var _c = 0, children_1 = children; _c < children_1.length; _c++) {
                var child = children_1[_c];
                if (types_1.isArray(child)) {
                    for (var _d = 0, child_1 = child; _d < child_1.length; _d++) {
                        var _child = child_1[_d];
                        append(_child);
                    }
                } else
                    append(child);
            }
            return element;
        };
    };
    function createElement(tag, attrs) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        return _createElement(tag).apply(void 0, [attrs].concat(children));
    }
    exports.createElement = createElement;
    exports.div = _createElement('div'), exports.span = _createElement('span'), exports.link = _createElement('link'), exports.style = _createElement('style'), exports.a = _createElement('a'), exports.p = _createElement('p'), exports.pre = _createElement('pre'), exports.button = _createElement('button'), exports.label = _createElement('label'), exports.input = _createElement('input'), exports.select = _createElement('select'), exports.option = _createElement('option'), exports.optgroup = _createElement('optgroup'), exports.canvas = _createElement('canvas'), exports.ul = _createElement('ul'), exports.ol = _createElement('ol'), exports.li = _createElement('li');
    exports.nbsp = document.createTextNode('\xA0');
    function removeElement(element) {
        var parent = element.parentNode;
        if (parent != null) {
            parent.removeChild(element);
        }
    }
    exports.removeElement = removeElement;
    function replaceWith(element, replacement) {
        var parent = element.parentNode;
        if (parent != null) {
            parent.replaceChild(replacement, element);
        }
    }
    exports.replaceWith = replaceWith;
    function prepend(element) {
        var nodes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            nodes[_i - 1] = arguments[_i];
        }
        var first = element.firstChild;
        for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
            var node = nodes_1[_a];
            element.insertBefore(node, first);
        }
    }
    exports.prepend = prepend;
    function empty(element) {
        var child;
        while (child = element.firstChild) {
            element.removeChild(child);
        }
    }
    exports.empty = empty;
    function show(element) {
        element.style.display = '';
    }
    exports.show = show;
    function hide(element) {
        element.style.display = 'none';
    }
    exports.hide = hide;
    function position(element) {
        return {
            top: element.offsetTop,
            left: element.offsetLeft
        };
    }
    exports.position = position;
    function offset(element) {
        var rect = element.getBoundingClientRect();
        return {
            top: rect.top + window.pageYOffset - document.documentElement.clientTop,
            left: rect.left + window.pageXOffset - document.documentElement.clientLeft
        };
    }
    exports.offset = offset;
    function matches(el, selector) {
        var p = Element.prototype;
        var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector;
        return f.call(el, selector);
    }
    exports.matches = matches;
    function parent(el, selector) {
        var node = el;
        while (node = node.parentElement) {
            if (matches(node, selector))
                return node;
        }
        return null;
    }
    exports.parent = parent;
    var Keys;
    (function (Keys) {
        Keys[Keys['Tab'] = 9] = 'Tab';
        Keys[Keys['Enter'] = 13] = 'Enter';
        Keys[Keys['Esc'] = 27] = 'Esc';
        Keys[Keys['PageUp'] = 33] = 'PageUp';
        Keys[Keys['PageDown'] = 34] = 'PageDown';
        Keys[Keys['Up'] = 38] = 'Up';
        Keys[Keys['Down'] = 40] = 'Down';
    }(Keys = exports.Keys || (exports.Keys = {})));    
},
/*core/dom_view*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var view_1 = require(45    /* ./view */);
    var DOM = require(5    /* ./dom */);
    var DOMView = function (_super) {
        tslib_1.__extends(DOMView, _super);
        function DOMView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DOMView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this._has_finished = false;
            this.el = this._createElement();
        };
        DOMView.prototype.remove = function () {
            DOM.removeElement(this.el);
            _super.prototype.remove.call(this);
        };
        DOMView.prototype.layout = function () {
        };
        DOMView.prototype.render = function () {
        };
        DOMView.prototype.renderTo = function (element, replace) {
            if (replace === void 0) {
                replace = false;
            }
            if (!replace)
                element.appendChild(this.el);
            else
                DOM.replaceWith(element, this.el);
            this.layout();
        };
        DOMView.prototype.has_finished = function () {
            return this._has_finished;
        };
        Object.defineProperty(DOMView.prototype, '_root_element', {
            get: function () {
                return DOM.parent(this.el, '.bk-root');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DOMView.prototype, 'solver', {
            get: function () {
                return this.is_root ? this._solver : this.parent.solver;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DOMView.prototype, 'is_idle', {
            get: function () {
                return this.has_finished();
            },
            enumerable: true,
            configurable: true
        });
        DOMView.prototype._createElement = function () {
            return DOM.createElement(this.tagName, {
                id: this.id,
                class: this.className
            });
        };
        return DOMView;
    }(view_1.View);
    exports.DOMView = DOMView;
    DOMView.prototype.tagName = 'div';
    DOMView.prototype.className = null;    
},
/*core/enums*/
function _(require, module, exports) {
    exports.AngleUnits = [
        'deg',
        'rad'
    ];
    exports.Dimension = [
        'width',
        'height'
    ];
    exports.Dimensions = [
        'width',
        'height',
        'both'
    ];
    exports.Direction = [
        'clock',
        'anticlock'
    ];
    exports.FontStyle = [
        'normal',
        'italic',
        'bold'
    ];
    exports.LatLon = [
        'lat',
        'lon'
    ];
    exports.LineCap = [
        'butt',
        'round',
        'square'
    ];
    exports.LineJoin = [
        'miter',
        'round',
        'bevel'
    ];
    exports.Location = [
        'above',
        'below',
        'left',
        'right'
    ];
    exports.LegendLocation = [
        'top_left',
        'top_center',
        'top_right',
        'center_left',
        'center',
        'center_right',
        'bottom_left',
        'bottom_center',
        'bottom_right'
    ];
    exports.Orientation = [
        'vertical',
        'horizontal'
    ];
    exports.OutputBackend = [
        'canvas',
        'svg',
        'webgl'
    ];
    exports.RenderLevel = [
        'image',
        'underlay',
        'glyph',
        'annotation',
        'overlay'
    ];
    exports.RenderMode = [
        'canvas',
        'css'
    ];
    exports.Side = [
        'left',
        'right'
    ];
    exports.SpatialUnits = [
        'screen',
        'data'
    ];
    exports.StartEnd = [
        'start',
        'end'
    ];
    exports.VerticalAlign = [
        'top',
        'middle',
        'bottom'
    ];
    exports.TextAlign = [
        'left',
        'right',
        'center'
    ];
    exports.TextBaseline = [
        'top',
        'middle',
        'bottom',
        'alphabetic',
        'hanging',
        'ideographic'
    ];
    exports.DistributionTypes = [
        'uniform',
        'normal'
    ];
    exports.StepModes = [
        'after',
        'before',
        'center'
    ];
    exports.SizingMode = [
        'stretch_both',
        'scale_width',
        'scale_height',
        'scale_both',
        'fixed'
    ];
    exports.PaddingUnits = [
        'percent',
        'absolute'
    ];    
},
/*core/has_props*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var signaling_1 = require(20    /* ./signaling */);
    var property_mixins = require(16    /* ./property_mixins */);
    var refs_1 = require(33    /* ./util/refs */);
    var p = require(15    /* ./properties */);
    var string_1 = require(37    /* ./util/string */);
    var array_1 = require(22    /* ./util/array */);
    var object_1 = require(30    /* ./util/object */);
    var types_1 = require(42    /* ./util/types */);
    var eq_1 = require(28    /* ./util/eq */);
    var HasProps = function (_super) {
        tslib_1.__extends(HasProps, _super);
        function HasProps(attributes, options) {
            if (attributes === void 0) {
                attributes = {};
            }
            if (options === void 0) {
                options = {};
            }
            var _this = _super.call(this) || this;
            _this._subtype = undefined;
            _this.document = null;
            _this.destroyed = new signaling_1.Signal(_this, 'destroyed');
            _this.change = new signaling_1.Signal(_this, 'change');
            _this.transformchange = new signaling_1.Signal(_this, 'transformchange');
            _this.attributes = {};
            _this.properties = {};
            _this._set_after_defaults = {};
            _this._pending = false;
            _this._changing = false;
            for (var name_1 in _this.props) {
                var _a = _this.props[name_1], type = _a.type, default_value = _a.default_value;
                if (type != null)
                    _this.properties[name_1] = new type(_this, name_1, default_value);
                else
                    throw new Error('undefined property type for ' + _this.type + '.' + name_1);
            }
            // auto generating ID
            if (attributes.id == null)
                _this.setv([
                    'id',
                    string_1.uniqueId()
                ], { silent: true });
            _this.setv(attributes, object_1.extend({ silent: true }, options));
            // allowing us to defer initialization when loading many models
            // when loading a bunch of models, we want to do initialization as a second pass
            // because other objects that this one depends on might not be loaded yet
            if (!options.defer_initialization)
                _this.finalize(attributes, options);
            return _this;
        }
        // }}}
        HasProps.getters = function (specs) {
            for (var name_2 in specs) {
                var fn = specs[name_2];
                Object.defineProperty(this.prototype, name_2, { get: fn });
            }
        };
        HasProps._fix_default = function (default_value, _attr) {
            if (default_value === undefined)
                return undefined;
            else if (types_1.isFunction(default_value))
                return default_value;
            else if (!types_1.isObject(default_value))
                return function () {
                    return default_value;
                };
            else {
                //logger.warn(`${this.prototype.type}.${attr} uses unwrapped non-primitive default value`)
                if (types_1.isArray(default_value))
                    return function () {
                        return array_1.copy(default_value);
                    };
                else
                    return function () {
                        return object_1.clone(default_value);
                    };
            }
        };
        HasProps.define = function (obj) {
            var _loop_1 = function (name_3) {
                var prop = obj[name_3];
                if (this_1.prototype.props[name_3] != null)
                    throw new Error('attempted to redefine property \'' + this_1.prototype.type + '.' + name_3 + '\'');
                if (this_1.prototype[name_3] != null)
                    throw new Error('attempted to redefine attribute \'' + this_1.prototype.type + '.' + name_3 + '\'');
                Object.defineProperty(this_1.prototype, name_3, {
                    // XXX: don't use tail calls in getters/setters due to https://bugs.webkit.org/show_bug.cgi?id=164306
                    get: function () {
                        var value = this.getv(name_3);
                        return value;
                    },
                    set: function (value) {
                        this.setv([
                            name_3,
                            value
                        ]);
                        return this;
                    },
                    configurable: false,
                    enumerable: true
                });
                var type = prop[0], default_value = prop[1], internal = prop[2];
                var refined_prop = {
                    type: type,
                    default_value: this_1._fix_default(default_value, name_3),
                    internal: internal || false
                };
                var props = object_1.clone(this_1.prototype.props);
                props[name_3] = refined_prop;
                this_1.prototype.props = props;
            };
            var this_1 = this;
            for (var name_3 in obj) {
                _loop_1(name_3);
            }
        };
        HasProps.internal = function (obj) {
            var _object = {};
            for (var name_4 in obj) {
                var prop = obj[name_4];
                var type = prop[0], default_value = prop[1];
                _object[name_4] = [
                    type,
                    default_value,
                    true
                ];
            }
            this.define(_object);
        };
        HasProps.mixin = function () {
            var names = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                names[_i] = arguments[_i];
            }
            this.define(property_mixins.create(names));
            var mixins = this.prototype.mixins.concat(names);
            this.prototype.mixins = mixins;
        };
        HasProps.mixins = function (names) {
            this.mixin.apply(this, names);
        };
        HasProps.override = function (obj) {
            for (var name_5 in obj) {
                var default_value = this._fix_default(obj[name_5], name_5);
                var value = this.prototype.props[name_5];
                if (value == null)
                    throw new Error('attempted to override nonexistent \'' + this.prototype.type + '.' + name_5 + '\'');
                var props = object_1.clone(this.prototype.props);
                props[name_5] = object_1.extend({}, value, { default_value: default_value });
                this.prototype.props = props;
            }
        };
        HasProps.prototype.toString = function () {
            return this.type + '(' + this.id + ')';
        };
        HasProps.prototype.finalize = function (attributes, options) {
            var _this = this;
            // This is necessary because the initial creation of properties relies on
            // model.get which is not usable at that point yet in the constructor. This
            // initializer is called when deferred initialization happens for all models
            // and insures that the Bokeh properties are initialized from Backbone
            // attributes in a consistent way.
            //
            // TODO (bev) split property creation up into two parts so that only the
            // portion of init that can be done happens in HasProps constructor and so
            // that subsequent updates do not duplicate that setup work.
            for (var name_6 in this.properties) {
                var prop = this.properties[name_6];
                prop.update();
                if (prop.spec.transform != null)
                    this.connect(prop.spec.transform.change, function () {
                        return _this.transformchange.emit(undefined);
                    });
            }
            this.initialize(attributes, options);
            this.connect_signals();
        };
        HasProps.prototype.initialize = function (_attributes, _options) {
        };
        HasProps.prototype.connect_signals = function () {
        };
        HasProps.prototype.disconnect_signals = function () {
            signaling_1.Signal.disconnectReceiver(this);
        };
        HasProps.prototype.destroy = function () {
            this.disconnect_signals();
            this.destroyed.emit(undefined);
        };
        // Create a new model with identical attributes to this one.
        HasProps.prototype.clone = function () {
            return new this.constructor(this.attributes);
        };
        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        HasProps.prototype._setv = function (attrs, options) {
            // Extract attributes and options.
            var check_eq = options.check_eq;
            var silent = options.silent;
            var changes = [];
            var changing = this._changing;
            this._changing = true;
            var current = this.attributes;
            // For each `set` attribute, update or delete the current value.
            for (var attr in attrs) {
                var val = attrs[attr];
                if (check_eq !== false) {
                    if (!eq_1.isEqual(current[attr], val))
                        changes.push(attr);
                } else
                    changes.push(attr);
                current[attr] = val;
            }
            // Trigger all relevant attribute changes.
            if (!silent) {
                if (changes.length > 0)
                    this._pending = true;
                for (var i = 0; i < changes.length; i++)
                    this.properties[changes[i]].change.emit(current[changes[i]]);
            }
            // You might be wondering why there's a `while` loop here. Changes can
            // be recursively nested within `"change"` events.
            if (changing)
                return;
            if (!silent && !options.no_change) {
                while (this._pending) {
                    this._pending = false;
                    this.change.emit(undefined);
                }
            }
            this._pending = false;
            this._changing = false;
        };
        HasProps.prototype.setv = function (obj, options) {
            if (options === void 0) {
                options = {};
            }
            var attrs = {};
            if (types_1.isArray(obj)) {
                var _a = obj, attr = _a[0], value = _a[1];
                attrs[attr] = value;
            } else
                attrs = obj;
            for (var key in attrs) {
                if (!attrs.hasOwnProperty(key))
                    continue;
                var prop_name = key;
                if (this.props[prop_name] == null)
                    throw new Error('property ' + this.type + '.' + prop_name + ' wasn\'t declared');
                if (!(options != null && options.defaults))
                    this._set_after_defaults[key] = true;
            }
            if (!object_1.isEmpty(attrs)) {
                var old = {};
                for (var key in attrs)
                    old[key] = this.getv(key);
                this._setv(attrs, options);
                var silent = options.silent;
                if (silent == null || !silent) {
                    for (var key in attrs)
                        this._tell_document_about_change(key, old[key], this.getv(key), options);
                }
            }
        };
        HasProps.prototype.getv = function (prop_name) {
            if (this.props[prop_name] == null)
                throw new Error('property ' + this.type + '.' + prop_name + ' wasn\'t declared');
            else
                return this.attributes[prop_name];
        };
        HasProps.prototype.ref = function () {
            return refs_1.create_ref(this);
        };
        // we only keep the subtype so we match Python;
        // only Python cares about this
        HasProps.prototype.set_subtype = function (subtype) {
            this._subtype = subtype;
        };
        HasProps.prototype.attribute_is_serializable = function (attr) {
            var prop = this.props[attr];
            if (prop == null)
                throw new Error(this.type + '.attribute_is_serializable(\'' + attr + '\'): ' + attr + ' wasn\'t declared');
            else
                return !prop.internal;
        };
        // dict of attributes that should be serialized to the server. We
        // sometimes stick things in attributes that aren't part of the
        // Document's models, subtypes that do that have to remove their
        // extra attributes here.
        HasProps.prototype.serializable_attributes = function () {
            var attrs = {};
            for (var name_7 in this.attributes) {
                var value = this.attributes[name_7];
                if (this.attribute_is_serializable(name_7))
                    attrs[name_7] = value;
            }
            return attrs;
        };
        HasProps._value_to_json = function (_key, value, _optional_parent_object) {
            if (value instanceof HasProps)
                return value.ref();
            else if (types_1.isArray(value)) {
                var ref_array = [];
                for (var i = 0; i < value.length; i++) {
                    var v = value[i];
                    ref_array.push(HasProps._value_to_json(i.toString(), v, value));
                }
                return ref_array;
            } else if (types_1.isObject(value)) {
                var ref_obj = {};
                for (var subkey in value) {
                    if (value.hasOwnProperty(subkey))
                        ref_obj[subkey] = HasProps._value_to_json(subkey, value[subkey], value);
                }
                return ref_obj;
            } else
                return value;
        };
        // Convert attributes to "shallow" JSON (values which are themselves models
        // are included as just references)
        // TODO (havocp) can this just be toJSON (from Backbone / JSON.stingify?)
        // backbone will have implemented a toJSON already that we may need to override
        // optional value_to_json is for test to override with a "deep" version to replace the
        // standard "shallow" HasProps._value_to_json
        HasProps.prototype.attributes_as_json = function (include_defaults, value_to_json) {
            if (include_defaults === void 0) {
                include_defaults = true;
            }
            if (value_to_json === void 0) {
                value_to_json = HasProps._value_to_json;
            }
            var serializable = this.serializable_attributes();
            var attrs = {};
            for (var key in serializable) {
                if (serializable.hasOwnProperty(key)) {
                    var value = serializable[key];
                    if (include_defaults)
                        attrs[key] = value;
                    else if (key in this._set_after_defaults)
                        attrs[key] = value;
                }
            }
            return value_to_json('attributes', attrs, this);
        };
        // this is like _value_record_references but expects to find refs
        // instead of models, and takes a doc to look up the refs in
        HasProps._json_record_references = function (doc, v, result, recurse) {
            if (v == null) {
            } else if (refs_1.is_ref(v)) {
                if (!(v.id in result)) {
                    var model = doc.get_model_by_id(v.id);
                    HasProps._value_record_references(model, result, recurse);
                }
            } else if (types_1.isArray(v)) {
                for (var _i = 0, v_1 = v; _i < v_1.length; _i++) {
                    var elem = v_1[_i];
                    HasProps._json_record_references(doc, elem, result, recurse);
                }
            } else if (types_1.isObject(v)) {
                for (var k in v) {
                    if (v.hasOwnProperty(k)) {
                        var elem = v[k];
                        HasProps._json_record_references(doc, elem, result, recurse);
                    }
                }
            }
        };
        // add all references from 'v' to 'result', if recurse
        // is true then descend into refs, if false only
        // descend into non-refs
        HasProps._value_record_references = function (v, result, recurse) {
            if (v == null) {
            } else if (v instanceof HasProps) {
                if (!(v.id in result)) {
                    result[v.id] = v;
                    if (recurse) {
                        var immediate = v._immediate_references();
                        for (var _i = 0, immediate_1 = immediate; _i < immediate_1.length; _i++) {
                            var obj = immediate_1[_i];
                            HasProps._value_record_references(obj, result, true);
                        }    // true=recurse
                    }
                }
            } else if (v.buffer instanceof ArrayBuffer) {
            } else if (types_1.isArray(v)) {
                for (var _a = 0, v_2 = v; _a < v_2.length; _a++) {
                    var elem = v_2[_a];
                    HasProps._value_record_references(elem, result, recurse);
                }
            } else if (types_1.isObject(v)) {
                for (var k in v) {
                    if (v.hasOwnProperty(k)) {
                        var elem = v[k];
                        HasProps._value_record_references(elem, result, recurse);
                    }
                }
            }
        };
        // Get models that are immediately referenced by our properties
        // (do not recurse, do not include ourselves)
        HasProps.prototype._immediate_references = function () {
            var result = {};
            var attrs = this.serializable_attributes();
            for (var key in attrs) {
                var value = attrs[key];
                HasProps._value_record_references(value, result, false);    // false = no recurse
            }
            return object_1.values(result);
        };
        HasProps.prototype.references = function () {
            var references = {};
            HasProps._value_record_references(this, references, true);
            return object_1.values(references);
        };
        HasProps.prototype._doc_attached = function () {
        };
        HasProps.prototype.attach_document = function (doc) {
            // This should only be called by the Document implementation to set the document field
            if (this.document != null && this.document != doc)
                throw new Error('models must be owned by only a single document');
            this.document = doc;
            this._doc_attached();
        };
        HasProps.prototype.detach_document = function () {
            // This should only be called by the Document implementation to unset the document field
            this.document = null;
        };
        HasProps.prototype._tell_document_about_change = function (attr, old, new_, options) {
            if (!this.attribute_is_serializable(attr))
                return;
            if (this.document != null) {
                var new_refs = {};
                HasProps._value_record_references(new_, new_refs, false);
                var old_refs = {};
                HasProps._value_record_references(old, old_refs, false);
                var need_invalidate = false;
                for (var new_id in new_refs) {
                    if (!(new_id in old_refs)) {
                        need_invalidate = true;
                        break;
                    }
                }
                if (!need_invalidate) {
                    for (var old_id in old_refs) {
                        if (!(old_id in new_refs)) {
                            need_invalidate = true;
                            break;
                        }
                    }
                }
                if (need_invalidate)
                    this.document._invalidate_all_models();
                this.document._notify_change(this, attr, old, new_, options);
            }
        };
        HasProps.prototype.materialize_dataspecs = function (source) {
            // Note: this should be moved to a function separate from HasProps
            var data = {};
            for (var name_8 in this.properties) {
                var prop = this.properties[name_8];
                if (!prop.dataspec)
                    continue;
                // this skips optional properties like radius for circles
                if (prop.optional && prop.spec.value == null && !(name_8 in this._set_after_defaults))
                    continue;
                data['_' + name_8] = prop.array(source);
                // the shapes are indexed by the column name, but when we materialize the dataspec, we should
                // store under the canonical field name, e.g. _image_shape, even if the column name is "foo"
                if (prop.spec.field != null && prop.spec.field in source._shapes)
                    data['_' + name_8 + '_shape'] = source._shapes[prop.spec.field];
                if (prop instanceof p.Distance)
                    data['max_' + name_8] = array_1.max(data['_' + name_8]);
            }
            return data;
        };
        return HasProps;
    }(signaling_1.Signalable());
    exports.HasProps = HasProps;
    HasProps.prototype.type = 'HasProps';
    HasProps.prototype.props = {};
    HasProps.prototype.mixins = [];
    HasProps.define({ id: [p.Any] });    
},
/*core/hittest*/
function _(require, module, exports) {
    var array_1 = require(22    /* ./util/array */);
    var object_1 = require(30    /* ./util/object */);
    function point_in_poly(x, y, px, py) {
        var inside = false;
        var x1 = px[px.length - 1];
        var y1 = py[py.length - 1];
        for (var i = 0; i < px.length; i++) {
            var x2 = px[i];
            var y2 = py[i];
            if (y1 < y != y2 < y) {
                if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x)
                    inside = !inside;
            }
            x1 = x2;
            y1 = y2;
        }
        return inside;
    }
    exports.point_in_poly = point_in_poly;
    var nullreturner = function () {
        return null;
    };
    // stub function shared by all hittests by default
    var HitTestResult = function () {
        function HitTestResult() {
            // 0d is only valid for line and patch glyphs
            this['0d'] = {
                // the glyph that was picked
                glyph: null,
                get_view: nullreturner,
                // array with the [smallest] index of the segment of the line that was hit
                indices: []
            };
            // 1d for all other glyphs apart from multilines and multi patches
            this['1d'] = {
                // index of the closest point to the crossed segment
                // useful for special glyphs like line that are continuous and
                // not discrete between 2 data points
                indices: []
            };
            // 2d for all for multilines and multi patches
            this['2d'] = {
                // mapping of indices of the multiglyph to array of glyph indices that were hit
                // e.g. {3: [5, 6], 4: [5]}
                indices: {}
            };
        }
        Object.defineProperty(HitTestResult.prototype, '_0d', {
            get: function () {
                return this['0d'];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HitTestResult.prototype, '_1d', {
            get: function () {
                return this['1d'];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HitTestResult.prototype, '_2d', {
            get: function () {
                return this['2d'];
            },
            enumerable: true,
            configurable: true
        });
        HitTestResult.prototype.is_empty = function () {
            return this._0d.indices.length == 0 && this._1d.indices.length == 0 && object_1.isEmpty(this._2d.indices);
        };
        HitTestResult.prototype.update_through_union = function (other) {
            this._0d.indices = array_1.union(other._0d.indices, this._0d.indices);
            this._0d.glyph = other._0d.glyph || this._0d.glyph;
            this._1d.indices = array_1.union(other._1d.indices, this._1d.indices);
            this._2d.indices = object_1.merge(other._2d.indices, this._2d.indices);
        };
        return HitTestResult;
    }();
    exports.HitTestResult = HitTestResult;
    function create_hit_test_result() {
        return new HitTestResult();
    }
    exports.create_hit_test_result = create_hit_test_result;
    function create_1d_hit_test_result(hits) {
        var result = new HitTestResult();
        result._1d.indices = array_1.sortBy(hits, function (_a) {
            var _i = _a[0], dist = _a[1];
            return dist;
        }).map(function (_a) {
            var i = _a[0], _dist = _a[1];
            return i;
        });
        return result;
    }
    exports.create_1d_hit_test_result = create_1d_hit_test_result;
    function validate_bbox_coords(_a, _b) {
        var x0 = _a[0], x1 = _a[1];
        var y0 = _b[0], y1 = _b[1];
        // rbush expects x0, y0 to be min, x1, y1 max
        if (x0 > x1)
            _c = [
                x1,
                x0
            ], x0 = _c[0], x1 = _c[1];
        if (y0 > y1)
            _d = [
                y1,
                y0
            ], y0 = _d[0], y1 = _d[1];
        return {
            minX: x0,
            minY: y0,
            maxX: x1,
            maxY: y1
        };
        var _c, _d;
    }
    exports.validate_bbox_coords = validate_bbox_coords;
    function sqr(x) {
        return x * x;
    }
    function dist_2_pts(x0, y0, x1, y1) {
        return sqr(x0 - x1) + sqr(y0 - y1);
    }
    exports.dist_2_pts = dist_2_pts;
    function dist_to_segment_squared(p, v, w) {
        var l2 = dist_2_pts(v.x, v.y, w.x, w.y);
        if (l2 == 0)
            return dist_2_pts(p.x, p.y, v.x, v.y);
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0)
            return dist_2_pts(p.x, p.y, v.x, v.y);
        if (t > 1)
            return dist_2_pts(p.x, p.y, w.x, w.y);
        return dist_2_pts(p.x, p.y, v.x + t * (w.x - v.x), v.y + t * (w.y - v.y));
    }
    exports.dist_to_segment_squared = dist_to_segment_squared;
    function dist_to_segment(p, v, w) {
        return Math.sqrt(dist_to_segment_squared(p, v, w));
    }
    exports.dist_to_segment = dist_to_segment;
    function check_2_segments_intersect(l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {
        /*
     *  Check if 2 segments (l0 and l1) intersect. Returns a structure with
     *  the following attributes:
     *   * hit (boolean): whether the 2 segments intersect
     *   * x (float): x coordinate of the intersection point
     *   * y (float): y coordinate of the intersection point
     */
        var den = (l1_y1 - l1_y0) * (l0_x1 - l0_x0) - (l1_x1 - l1_x0) * (l0_y1 - l0_y0);
        if (den == 0) {
            return {
                hit: false,
                x: null,
                y: null
            };
        } else {
            var a = l0_y0 - l1_y0;
            var b = l0_x0 - l1_x0;
            var num1 = (l1_x1 - l1_x0) * a - (l1_y1 - l1_y0) * b;
            var num2 = (l0_x1 - l0_x0) * a - (l0_y1 - l0_y0) * b;
            a = num1 / den;
            b = num2 / den;
            var x = l0_x0 + a * (l0_x1 - l0_x0);
            var y = l0_y0 + a * (l0_y1 - l0_y0);
            return {
                hit: a > 0 && a < 1 && (b > 0 && b < 1),
                x: x,
                y: y
            };
        }
    }
    exports.check_2_segments_intersect = check_2_segments_intersect;    
},
/*core/layout/alignments*/
function _(require, module, exports) {
    var solver_1 = require(13    /* ./solver */);
    var array_1 = require(22    /* ../util/array */);
    function vstack(container, children) {
        var constraints = [];
        if (children.length > 0) {
            constraints.push(solver_1.EQ(array_1.head(children)._bottom, [
                -1,
                container._bottom
            ]));
            constraints.push(solver_1.EQ(array_1.tail(children)._top, [
                -1,
                container._top
            ]));
            constraints.push.apply(constraints, array_1.pairwise(children, function (prev, next) {
                return solver_1.EQ(prev._top, [
                    -1,
                    next._bottom
                ]);
            }));
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                constraints.push(solver_1.EQ(child._left, [
                    -1,
                    container._left
                ]));
                constraints.push(solver_1.EQ(child._right, [
                    -1,
                    container._right
                ]));
            }
        }
        return constraints;
    }
    exports.vstack = vstack;
    function hstack(container, children) {
        var constraints = [];
        if (children.length > 0) {
            constraints.push(solver_1.EQ(array_1.head(children)._right, [
                -1,
                container._right
            ]));
            constraints.push(solver_1.EQ(array_1.tail(children)._left, [
                -1,
                container._left
            ]));
            constraints.push.apply(constraints, array_1.pairwise(children, function (prev, next) {
                return solver_1.EQ(prev._left, [
                    -1,
                    next._right
                ]);
            }));
            for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                var child = children_2[_i];
                constraints.push(solver_1.EQ(child._top, [
                    -1,
                    container._top
                ]));
                constraints.push(solver_1.EQ(child._bottom, [
                    -1,
                    container._bottom
                ]));
            }
        }
        return constraints;
    }
    exports.hstack = hstack;    
},
/*core/layout/layout_canvas*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var solver_1 = require(13    /* ./solver */);
    var has_props_1 = require(8    /* ../has_props */);
    var bbox_1 = require(23    /* ../util/bbox */);
    var LayoutCanvas = function (_super) {
        tslib_1.__extends(LayoutCanvas, _super);
        function LayoutCanvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LayoutCanvas.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._top = new solver_1.Variable(this.toString() + '.top');
            this._left = new solver_1.Variable(this.toString() + '.left');
            this._width = new solver_1.Variable(this.toString() + '.width');
            this._height = new solver_1.Variable(this.toString() + '.height');
            this._right = new solver_1.Variable(this.toString() + '.right');
            this._bottom = new solver_1.Variable(this.toString() + '.bottom');
            this._hcenter = new solver_1.Variable(this.toString() + '.hcenter');
            this._vcenter = new solver_1.Variable(this.toString() + '.vcenter');
        };
        LayoutCanvas.prototype.get_editables = function () {
            return [];
        };
        LayoutCanvas.prototype.get_constraints = function () {
            return [
                solver_1.GE(this._top),
                solver_1.GE(this._bottom),
                solver_1.GE(this._left),
                solver_1.GE(this._right),
                solver_1.GE(this._width),
                solver_1.GE(this._height),
                solver_1.EQ(this._left, this._width, [
                    -1,
                    this._right
                ]),
                solver_1.EQ(this._top, this._height, [
                    -1,
                    this._bottom
                ]),
                solver_1.EQ([
                    2,
                    this._hcenter
                ], [
                    -1,
                    this._left
                ], [
                    -1,
                    this._right
                ]),
                solver_1.EQ([
                    2,
                    this._vcenter
                ], [
                    -1,
                    this._top
                ], [
                    -1,
                    this._bottom
                ])
            ];
        };
        Object.defineProperty(LayoutCanvas.prototype, 'bbox', {
            get: function () {
                return new bbox_1.BBox({
                    x0: this._left.value,
                    y0: this._top.value,
                    x1: this._right.value,
                    y1: this._bottom.value
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutCanvas.prototype, 'layout_bbox', {
            get: function () {
                return {
                    top: this._top.value,
                    left: this._left.value,
                    width: this._width.value,
                    height: this._height.value,
                    right: this._right.value,
                    bottom: this._bottom.value,
                    hcenter: this._hcenter.value,
                    vcenter: this._vcenter.value
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutCanvas.prototype, 'xview', {
            get: function () {
                var _this = this;
                return {
                    compute: function (x) {
                        return _this._left.value + x;
                    },
                    v_compute: function (xx) {
                        var _xx = new Float64Array(xx.length);
                        var left = _this._left.value;
                        for (var i = 0; i < xx.length; i++) {
                            _xx[i] = left + xx[i];
                        }
                        return _xx;
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayoutCanvas.prototype, 'yview', {
            get: function () {
                var _this = this;
                return {
                    compute: function (y) {
                        return _this._bottom.value - y;
                    },
                    v_compute: function (yy) {
                        var _yy = new Float64Array(yy.length);
                        var bottom = _this._bottom.value;
                        for (var i = 0; i < yy.length; i++) {
                            _yy[i] = bottom - yy[i];
                        }
                        return _yy;
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        return LayoutCanvas;
    }(has_props_1.HasProps);
    exports.LayoutCanvas = LayoutCanvas;
    LayoutCanvas.prototype.type = 'LayoutCanvas';    
},
/*core/layout/side_panel*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var ALPHABETIC, BOTTOM, CENTER, HANGING, LEFT, MIDDLE, RIGHT, TOP, _align_lookup, _align_lookup_negative, _align_lookup_positive, _angle_lookup, _baseline_lookup, pi2;
    var solver_1 = require(13    /* ./solver */);
    var layout_canvas_1 = require(11    /* ./layout_canvas */);
    var p = require(15    /* core/properties */);
    var logging_1 = require(14    /* core/logging */);
    var types_1 = require(42    /* core/util/types */);
    // This table lays out the rules for configuring the baseline, alignment, etc. of
    // title text, based on it's location and orientation
    // side    orient        baseline   align     angle   normal-dist
    // ------------------------------------------------------------------------------
    // above   parallel      bottom     center    0       height
    //         normal        middle     left      -90     width
    //         horizontal    bottom     center    0       height
    //         [angle > 0]   middle     left              width * sin + height * cos
    //         [angle < 0]   middle     right             width * sin + height * cos
    // below   parallel      top        center    0       height
    //         normal        middle     right     90      width
    //         horizontal    top        center    0       height
    //         [angle > 0]   middle     right             width * sin + height * cos
    //         [angle < 0]   middle     left              width * sin + height * cos
    // left    parallel      bottom     center    90      height
    //         normal        middle     right     0       width
    //         horizontal    middle     right     0       width
    //         [angle > 0]   middle     right             width * cos + height * sin
    //         [angle < 0]   middle     right             width * cos + height + sin
    // right   parallel      bottom     center   -90      height
    //         normal        middle     left     0        width
    //         horizontal    middle     left     0        width
    //         [angle > 0]   middle     left              width * cos + height * sin
    //         [angle < 0]   middle     left              width * cos + height + sin
    pi2 = Math.PI / 2;
    ALPHABETIC = 'alphabetic';
    TOP = 'top';
    BOTTOM = 'bottom';
    MIDDLE = 'middle';
    HANGING = 'hanging';
    LEFT = 'left';
    RIGHT = 'right';
    CENTER = 'center';
    _angle_lookup = {
        above: {
            parallel: 0,
            normal: -pi2,
            horizontal: 0,
            vertical: -pi2
        },
        below: {
            parallel: 0,
            normal: pi2,
            horizontal: 0,
            vertical: pi2
        },
        left: {
            parallel: -pi2,
            normal: 0,
            horizontal: 0,
            vertical: -pi2
        },
        right: {
            parallel: pi2,
            normal: 0,
            horizontal: 0,
            vertical: pi2
        }
    };
    _baseline_lookup = {
        above: {
            justified: TOP,
            parallel: ALPHABETIC,
            normal: MIDDLE,
            horizontal: ALPHABETIC,
            vertical: MIDDLE
        },
        below: {
            justified: BOTTOM,
            parallel: HANGING,
            normal: MIDDLE,
            horizontal: HANGING,
            vertical: MIDDLE
        },
        left: {
            justified: TOP,
            parallel: ALPHABETIC,
            normal: MIDDLE,
            horizontal: MIDDLE,
            vertical: ALPHABETIC
        },
        right: {
            justified: TOP,
            parallel: ALPHABETIC,
            normal: MIDDLE,
            horizontal: MIDDLE,
            vertical: ALPHABETIC
        }
    };
    _align_lookup = {
        above: {
            justified: CENTER,
            parallel: CENTER,
            normal: LEFT,
            horizontal: CENTER,
            vertical: LEFT
        },
        below: {
            justified: CENTER,
            parallel: CENTER,
            normal: LEFT,
            horizontal: CENTER,
            vertical: LEFT
        },
        left: {
            justified: CENTER,
            parallel: CENTER,
            normal: RIGHT,
            horizontal: RIGHT,
            vertical: CENTER
        },
        right: {
            justified: CENTER,
            parallel: CENTER,
            normal: LEFT,
            horizontal: LEFT,
            vertical: CENTER
        }
    };
    _align_lookup_negative = {
        above: RIGHT,
        below: LEFT,
        left: RIGHT,
        right: LEFT
    };
    _align_lookup_positive = {
        above: LEFT,
        below: RIGHT,
        left: RIGHT,
        right: LEFT
    };
    exports._view_sizes = new WeakMap();
    // <View, number>
    exports.update_panel_constraints = function (view) {
        var s, size;
        size = view.get_size();
        s = view.solver;
        if (view._size_constraint != null && s.has_constraint(view._size_constraint)) {
            if (exports._view_sizes.get(view) === size) {
                return;
            }
            s.remove_constraint(view._size_constraint);
        }
        exports._view_sizes.set(view, size);
        view._size_constraint = solver_1.GE(view.model.panel._size, -size);
        return s.add_constraint(view._size_constraint);
    };
    var SidePanel = function (_super) {
        tslib_1.__extends(SidePanel, _super);
        function SidePanel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SidePanel.prototype.toString = function () {
            return this.type + '(' + this.id + ', ' + this.side + ')';
        };
        SidePanel.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            switch (this.side) {
            case 'above':
                this._dim = 0;
                this._normals = [
                    0,
                    -1
                ];
                return this._size = this._height;
            case 'below':
                this._dim = 0;
                this._normals = [
                    0,
                    1
                ];
                return this._size = this._height;
            case 'left':
                this._dim = 1;
                this._normals = [
                    -1,
                    0
                ];
                return this._size = this._width;
            case 'right':
                this._dim = 1;
                this._normals = [
                    1,
                    0
                ];
                return this._size = this._width;
            default:
                return logging_1.logger.error('unrecognized side: \'' + this.side + '\'');
            }
        };
        SidePanel.prototype.apply_label_text_heuristics = function (ctx, orient) {
            var align, baseline, side;
            side = this.side;
            if (types_1.isString(orient)) {
                baseline = _baseline_lookup[side][orient];
                align = _align_lookup[side][orient];
            } else if (orient === 0) {
                baseline = _baseline_lookup[side][orient];
                align = _align_lookup[side][orient];
            } else if (orient < 0) {
                baseline = 'middle';
                align = _align_lookup_negative[side];
            } else if (orient > 0) {
                baseline = 'middle';
                align = _align_lookup_positive[side];
            }
            ctx.textBaseline = baseline;
            ctx.textAlign = align;
            return ctx;
        };
        SidePanel.prototype.get_label_angle_heuristic = function (orient) {
            var side;
            side = this.side;
            return _angle_lookup[side][orient];
        };
        return SidePanel;
    }(layout_canvas_1.LayoutCanvas);
    exports.SidePanel = SidePanel;
    ;
    SidePanel.prototype.type = 'SidePanel';
    SidePanel.internal({ side: [p.String] });
    SidePanel.getters({
        is_horizontal: function () {
            return this.side === 'above' || this.side === 'below';
        },
        is_vertical: function () {
            return this.side === 'left' || this.side === 'right';
        }
    });    
},
/*core/layout/solver*/
function _(require, module, exports) {
    var kiwi_1 = require(321    /* kiwi */);
    exports.Variable = kiwi_1.Variable;
    exports.Expression = kiwi_1.Expression;
    exports.Constraint = kiwi_1.Constraint;
    exports.Operator = kiwi_1.Operator;
    exports.Strength = kiwi_1.Strength;
    function _constrainer(op) {
        return function () {
            var terms = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                terms[_i] = arguments[_i];
            }
            return new kiwi_1.Constraint(new (kiwi_1.Expression.bind.apply(kiwi_1.Expression, [void 0].concat(terms)))(), op);
        };
    }
    function _weak_constrainer(op) {
        return function () {
            var terms = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                terms[_i] = arguments[_i];
            }
            return new kiwi_1.Constraint(new (kiwi_1.Expression.bind.apply(kiwi_1.Expression, [void 0].concat(terms)))(), op, kiwi_1.Strength.weak);
        };
    }
    exports.EQ = _constrainer(kiwi_1.Operator.Eq);
    exports.LE = _constrainer(kiwi_1.Operator.Le);
    exports.GE = _constrainer(kiwi_1.Operator.Ge);
    exports.WEAK_EQ = _weak_constrainer(kiwi_1.Operator.Eq);
    exports.WEAK_LE = _weak_constrainer(kiwi_1.Operator.Le);
    exports.WEAK_GE = _weak_constrainer(kiwi_1.Operator.Ge);
    var Solver = function () {
        function Solver() {
            this.solver = new kiwi_1.Solver();
        }
        Solver.prototype.clear = function () {
            this.solver = new kiwi_1.Solver();
        };
        Solver.prototype.toString = function () {
            return 'Solver(num_constraints=' + this.num_constraints + ', num_editables=' + this.num_editables + ')';
        };
        Object.defineProperty(Solver.prototype, 'num_constraints', {
            get: function () {
                return this.solver.numConstraints;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Solver.prototype, 'num_editables', {
            get: function () {
                return this.solver.numEditVariables;
            },
            enumerable: true,
            configurable: true
        });
        Solver.prototype.get_constraints = function () {
            return this.solver.getConstraints();
        };
        Solver.prototype.update_variables = function () {
            this.solver.updateVariables();
        };
        Solver.prototype.has_constraint = function (constraint) {
            return this.solver.hasConstraint(constraint);
        };
        Solver.prototype.add_constraint = function (constraint) {
            try {
                this.solver.addConstraint(constraint);
            } catch (e) {
                throw new Error(e.message + ': ' + constraint.toString());
            }
        };
        Solver.prototype.remove_constraint = function (constraint) {
            this.solver.removeConstraint(constraint);
        };
        Solver.prototype.add_edit_variable = function (variable, strength) {
            this.solver.addEditVariable(variable, strength);
        };
        Solver.prototype.remove_edit_variable = function (variable) {
            this.solver.removeEditVariable(variable);
        };
        Solver.prototype.suggest_value = function (variable, value) {
            this.solver.suggestValue(variable, value);
        };
        return Solver;
    }();
    exports.Solver = Solver;    
},
/*core/logging*/
function _(require, module, exports) {
    var types_1 = require(42    /* ./util/types */);
    var _loggers = {};
    var LogLevel = function () {
        function LogLevel(name, level) {
            this.name = name;
            this.level = level;
        }
        return LogLevel;
    }();
    exports.LogLevel = LogLevel;
    var Logger = function () {
        function Logger(name, level) {
            if (level === void 0) {
                level = Logger.INFO;
            }
            this._name = name;
            this.set_level(level);
        }
        Object.defineProperty(Logger, 'levels', {
            get: function () {
                return Object.keys(Logger.log_levels);
            },
            enumerable: true,
            configurable: true
        });
        Logger.get = function (name, level) {
            if (level === void 0) {
                level = Logger.INFO;
            }
            if (name.length > 0) {
                var logger_1 = _loggers[name];
                if (logger_1 == null)
                    _loggers[name] = logger_1 = new Logger(name, level);
                return logger_1;
            } else
                throw new TypeError('Logger.get() expects a non-empty string name and an optional log-level');
        };
        Object.defineProperty(Logger.prototype, 'level', {
            get: function () {
                return this.get_level();
            },
            enumerable: true,
            configurable: true
        });
        Logger.prototype.get_level = function () {
            return this._log_level;
        };
        Logger.prototype.set_level = function (log_level) {
            if (log_level instanceof LogLevel)
                this._log_level = log_level;
            else if (types_1.isString(log_level) && Logger.log_levels[log_level] != null)
                this._log_level = Logger.log_levels[log_level];
            else
                throw new Error('Logger.set_level() expects a log-level object or a string name of a log-level');
            var logger_name = '[' + this._name + ']';
            for (var name_1 in Logger.log_levels) {
                var log_level_1 = Logger.log_levels[name_1];
                if (log_level_1.level < this._log_level.level || this._log_level.level === Logger.OFF.level)
                    this[name_1] = function () {
                    };
                else
                    this[name_1] = _method_factory(name_1, logger_name);
            }
        };
        Logger.prototype.trace = function () {
            var _args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _args[_i] = arguments[_i];
            }
        };
        Logger.prototype.debug = function () {
            var _args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _args[_i] = arguments[_i];
            }
        };
        Logger.prototype.info = function () {
            var _args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _args[_i] = arguments[_i];
            }
        };
        Logger.prototype.warn = function () {
            var _args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _args[_i] = arguments[_i];
            }
        };
        Logger.prototype.error = function () {
            var _args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _args[_i] = arguments[_i];
            }
        };
        Logger.TRACE = new LogLevel('trace', 0);
        Logger.DEBUG = new LogLevel('debug', 1);
        Logger.INFO = new LogLevel('info', 2);
        Logger.WARN = new LogLevel('warn', 6);
        Logger.ERROR = new LogLevel('error', 7);
        Logger.FATAL = new LogLevel('fatal', 8);
        Logger.OFF = new LogLevel('off', 9);
        Logger.log_levels = {
            trace: Logger.TRACE,
            debug: Logger.DEBUG,
            info: Logger.INFO,
            warn: Logger.WARN,
            error: Logger.ERROR,
            fatal: Logger.FATAL,
            off: Logger.OFF
        };
        return Logger;
    }();
    exports.Logger = Logger;
    function _method_factory(method_name, logger_name) {
        if (console[method_name] != null)
            return console[method_name].bind(console, logger_name);
        else if (console.log != null)
            return console.log.bind(console, logger_name);
        else
            return function () {
            };
    }
    exports.logger = Logger.get('bokeh');
    function set_log_level(level) {
        if (Logger.log_levels[level] == null) {
            console.log('[bokeh] unrecognized logging level \'' + level + '\' passed to Bokeh.set_log_level(), ignoring');
            console.log('[bokeh] valid log levels are: ' + Logger.levels.join(', '));
        } else {
            console.log('[bokeh] setting log level to: \'' + level + '\'');
            exports.logger.set_level(level);
        }
    }
    exports.set_log_level = set_log_level;    
},
/*core/properties*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var signaling_1 = require(20    /* ./signaling */);
    var enums = require(7    /* ./enums */);
    var svg_colors = require(38    /* ./util/svg_colors */);
    var color_1 = require(26    /* ./util/color */);
    var array_1 = require(22    /* ./util/array */);
    var types_1 = require(42    /* ./util/types */);
    function valueToString(value) {
        try {
            return JSON.stringify(value);
        } catch (_a) {
            return value.toString();
        }
    }
    //
    // Property base class
    //
    var Property = function (_super) {
        tslib_1.__extends(Property, _super);
        function Property(obj, attr, default_value) {
            var _this = _super.call(this) || this;
            _this.obj = obj;
            _this.attr = attr;
            _this.default_value = default_value;
            _this.optional = false;
            _this.change = new signaling_1.Signal(_this.obj, 'change');
            _this._init();
            _this.connect(_this.change, function () {
                return _this._init();
            });
            return _this;
        }
        Property.prototype.update = function () {
            this._init();
        };
        // ----- customizable policies
        Property.prototype.init = function () {
        };
        Property.prototype.transform = function (values) {
            return values;
        };
        Property.prototype.validate = function (_value) {
        };
        // ----- property accessors
        Property.prototype.value = function (do_spec_transform) {
            if (do_spec_transform === void 0) {
                do_spec_transform = true;
            }
            if (this.spec.value === undefined)
                throw new Error('attempted to retrieve property value for property without value specification');
            var ret = this.transform([this.spec.value])[0];
            if (this.spec.transform != null && do_spec_transform)
                ret = this.spec.transform.compute(ret);
            return ret;
        };
        Property.prototype.array = function (source) {
            if (!this.dataspec)
                throw new Error('attempted to retrieve property array for non-dataspec property');
            var data = source.data;
            var ret;
            if (this.spec.field != null) {
                if (this.spec.field in data)
                    ret = this.transform(source.get_column(this.spec.field));
                else
                    throw new Error('attempted to retrieve property array for nonexistent field \'' + this.spec.field + '\'');
            } else if (this.spec.expr != null) {
                ret = this.transform(this.spec.expr._v_compute(source));
            } else {
                var length_1 = source.get_length();
                if (length_1 == null)
                    length_1 = 1;
                var value = this.value(false);
                // don't apply any spec transform
                ret = array_1.repeat(value, length_1);
            }
            if (this.spec.transform != null)
                ret = this.spec.transform.v_compute(ret);
            return ret;
        };
        // ----- private methods
        /*protected*/
        Property.prototype._init = function () {
            var obj = this.obj;
            var attr = this.attr;
            var attr_value = obj.getv(attr);
            if (attr_value === undefined) {
                var default_value = this.default_value;
                if (default_value !== undefined)
                    attr_value = default_value(obj);
                else
                    attr_value = null;
                obj.setv([
                    attr,
                    attr_value
                ], {
                    silent: true,
                    defaults: true
                });
            }
            if (types_1.isArray(attr_value))
                this.spec = { value: attr_value };
            else if (types_1.isObject(attr_value) && (attr_value.value === undefined ? 0 : 1) + (attr_value.field === undefined ? 0 : 1) + (attr_value.expr === undefined ? 0 : 1) == 1)
                this.spec = attr_value;
            else
                this.spec = { value: attr_value };
            if (this.spec.field != null && !types_1.isString(this.spec.field))
                throw new Error('field value for property \'' + attr + '\' is not a string');
            if (this.spec.value != null)
                this.validate(this.spec.value);
            this.init();
        };
        Property.prototype.toString = function () {
            /*${this.name}*/
            return 'Prop(' + this.obj + '.' + this.attr + ', spec: ' + valueToString(this.spec) + ')';
        };
        return Property;
    }(signaling_1.Signalable());
    exports.Property = Property;
    Property.prototype.dataspec = false;
    //
    // Simple Properties
    //
    function simple_prop(name, pred) {
        return function (_super) {
            tslib_1.__extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.validate = function (value) {
                if (!pred(value))
                    throw new Error(name + ' property \'' + this.attr + '\' given invalid value: ' + valueToString(value));
            };
            return class_1;
        }(Property);
    }
    exports.simple_prop = simple_prop;
    var Any = function (_super) {
        tslib_1.__extends(Any, _super);
        function Any() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Any;
    }(simple_prop('Any', function (_x) {
        return true;
    }));
    exports.Any = Any;
    var Array = function (_super) {
        tslib_1.__extends(Array, _super);
        function Array() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Array;
    }(simple_prop('Array', function (x) {
        return types_1.isArray(x) || x instanceof Float64Array;
    }));
    exports.Array = Array;
    var Bool = function (_super) {
        tslib_1.__extends(Bool, _super);
        function Bool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Bool;
    }(simple_prop('Bool', types_1.isBoolean));
    exports.Bool = Bool;
    exports.Boolean = Bool;
    var Color = function (_super) {
        tslib_1.__extends(Color, _super);
        function Color() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Color;
    }(simple_prop('Color', function (x) {
        return svg_colors[x.toLowerCase()] != null || x.substring(0, 1) == '#' || color_1.valid_rgb(x);
    }));
    exports.Color = Color;
    var Instance = function (_super) {
        tslib_1.__extends(Instance, _super);
        function Instance() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Instance;
    }(simple_prop('Instance', function (x) {
        return x.properties != null;
    }));
    exports.Instance = Instance;
    // TODO (bev) separate booleans?
    var Number = function (_super) {
        tslib_1.__extends(Number, _super);
        function Number() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Number;
    }(simple_prop('Number', function (x) {
        return types_1.isNumber(x) || types_1.isBoolean(x);
    }));
    exports.Number = Number;
    exports.Int = Number;
    // TODO extend Number instead of copying it's predicate
    //class Percent extends Number("Percent", (x) -> 0 <= x <= 1.0)
    var Percent = function (_super) {
        tslib_1.__extends(Percent, _super);
        function Percent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Percent;
    }(simple_prop('Number', function (x) {
        return (types_1.isNumber(x) || types_1.isBoolean(x)) && 0 <= x && x <= 1;
    }));
    exports.Percent = Percent;
    var String = function (_super) {
        tslib_1.__extends(String, _super);
        function String() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return String;
    }(simple_prop('String', types_1.isString));
    exports.String = String;
    // TODO (bev) don't think this exists python side
    var Font = function (_super) {
        tslib_1.__extends(Font, _super);
        function Font() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Font;
    }(String);
    exports.Font = Font;
    //
    // Enum properties
    //
    function enum_prop(name, enum_values) {
        return function (_super) {
            tslib_1.__extends(class_2, _super);
            function class_2() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return class_2;
        }(simple_prop(name, function (x) {
            return array_1.contains(enum_values, x);
        }));
    }
    exports.enum_prop = enum_prop;
    var Anchor = function (_super) {
        tslib_1.__extends(Anchor, _super);
        function Anchor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Anchor;
    }(enum_prop('Anchor', enums.LegendLocation));
    exports.Anchor = Anchor;
    var AngleUnits = function (_super) {
        tslib_1.__extends(AngleUnits, _super);
        function AngleUnits() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AngleUnits;
    }(enum_prop('AngleUnits', enums.AngleUnits));
    exports.AngleUnits = AngleUnits;
    var Direction = function (_super) {
        tslib_1.__extends(Direction, _super);
        function Direction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Direction.prototype.transform = function (values) {
            var result = new Uint8Array(values.length);
            for (var i = 0; i < values.length; i++) {
                switch (values[i]) {
                case 'clock':
                    result[i] = 0;
                    break;
                case 'anticlock':
                    result[i] = 1;
                    break;
                }
            }
            return result;
        };
        return Direction;
    }(enum_prop('Direction', enums.Direction));
    exports.Direction = Direction;
    var Dimension = function (_super) {
        tslib_1.__extends(Dimension, _super);
        function Dimension() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Dimension;
    }(enum_prop('Dimension', enums.Dimension));
    exports.Dimension = Dimension;
    var Dimensions = function (_super) {
        tslib_1.__extends(Dimensions, _super);
        function Dimensions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Dimensions;
    }(enum_prop('Dimensions', enums.Dimensions));
    exports.Dimensions = Dimensions;
    var FontStyle = function (_super) {
        tslib_1.__extends(FontStyle, _super);
        function FontStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return FontStyle;
    }(enum_prop('FontStyle', enums.FontStyle));
    exports.FontStyle = FontStyle;
    var LatLon = function (_super) {
        tslib_1.__extends(LatLon, _super);
        function LatLon() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LatLon;
    }(enum_prop('LatLon', enums.LatLon));
    exports.LatLon = LatLon;
    var LineCap = function (_super) {
        tslib_1.__extends(LineCap, _super);
        function LineCap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LineCap;
    }(enum_prop('LineCap', enums.LineCap));
    exports.LineCap = LineCap;
    var LineJoin = function (_super) {
        tslib_1.__extends(LineJoin, _super);
        function LineJoin() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LineJoin;
    }(enum_prop('LineJoin', enums.LineJoin));
    exports.LineJoin = LineJoin;
    var LegendLocation = function (_super) {
        tslib_1.__extends(LegendLocation, _super);
        function LegendLocation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LegendLocation;
    }(enum_prop('LegendLocation', enums.LegendLocation));
    exports.LegendLocation = LegendLocation;
    var Location = function (_super) {
        tslib_1.__extends(Location, _super);
        function Location() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Location;
    }(enum_prop('Location', enums.Location));
    exports.Location = Location;
    var OutputBackend = function (_super) {
        tslib_1.__extends(OutputBackend, _super);
        function OutputBackend() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return OutputBackend;
    }(enum_prop('OutputBackend', enums.OutputBackend));
    exports.OutputBackend = OutputBackend;
    var Orientation = function (_super) {
        tslib_1.__extends(Orientation, _super);
        function Orientation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Orientation;
    }(enum_prop('Orientation', enums.Orientation));
    exports.Orientation = Orientation;
    var VerticalAlign = function (_super) {
        tslib_1.__extends(VerticalAlign, _super);
        function VerticalAlign() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return VerticalAlign;
    }(enum_prop('VerticalAlign', enums.VerticalAlign));
    exports.VerticalAlign = VerticalAlign;
    var TextAlign = function (_super) {
        tslib_1.__extends(TextAlign, _super);
        function TextAlign() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TextAlign;
    }(enum_prop('TextAlign', enums.TextAlign));
    exports.TextAlign = TextAlign;
    var TextBaseline = function (_super) {
        tslib_1.__extends(TextBaseline, _super);
        function TextBaseline() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TextBaseline;
    }(enum_prop('TextBaseline', enums.TextBaseline));
    exports.TextBaseline = TextBaseline;
    var RenderLevel = function (_super) {
        tslib_1.__extends(RenderLevel, _super);
        function RenderLevel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RenderLevel;
    }(enum_prop('RenderLevel', enums.RenderLevel));
    exports.RenderLevel = RenderLevel;
    var RenderMode = function (_super) {
        tslib_1.__extends(RenderMode, _super);
        function RenderMode() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RenderMode;
    }(enum_prop('RenderMode', enums.RenderMode));
    exports.RenderMode = RenderMode;
    var SizingMode = function (_super) {
        tslib_1.__extends(SizingMode, _super);
        function SizingMode() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SizingMode;
    }(enum_prop('SizingMode', enums.SizingMode));
    exports.SizingMode = SizingMode;
    var SpatialUnits = function (_super) {
        tslib_1.__extends(SpatialUnits, _super);
        function SpatialUnits() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SpatialUnits;
    }(enum_prop('SpatialUnits', enums.SpatialUnits));
    exports.SpatialUnits = SpatialUnits;
    var Distribution = function (_super) {
        tslib_1.__extends(Distribution, _super);
        function Distribution() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Distribution;
    }(enum_prop('Distribution', enums.DistributionTypes));
    exports.Distribution = Distribution;
    var StepMode = function (_super) {
        tslib_1.__extends(StepMode, _super);
        function StepMode() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return StepMode;
    }(enum_prop('StepMode', enums.StepModes));
    exports.StepMode = StepMode;
    var PaddingUnits = function (_super) {
        tslib_1.__extends(PaddingUnits, _super);
        function PaddingUnits() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return PaddingUnits;
    }(enum_prop('PaddingUnits', enums.PaddingUnits));
    exports.PaddingUnits = PaddingUnits;
    var StartEnd = function (_super) {
        tslib_1.__extends(StartEnd, _super);
        function StartEnd() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return StartEnd;
    }(enum_prop('StartEnd', enums.StartEnd));
    exports.StartEnd = StartEnd;
    //
    // Units Properties
    //
    function units_prop(name, valid_units, default_units) {
        return function (_super) {
            tslib_1.__extends(class_3, _super);
            function class_3() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_3.prototype.init = function () {
                if (this.spec.units == null)
                    this.spec.units = default_units;
                var units = this.spec.units;
                if (!array_1.contains(valid_units, units))
                    throw new Error(name + ' units must be one of ' + valid_units + ', given invalid value: ' + units);
            };
            Object.defineProperty(class_3.prototype, 'units', {
                get: function () {
                    return this.spec.units;
                },
                set: function (units) {
                    this.spec.units = units;
                },
                enumerable: true,
                configurable: true
            });
            return class_3;
        }(Number);
    }
    exports.units_prop = units_prop;
    var Angle = function (_super) {
        tslib_1.__extends(Angle, _super);
        function Angle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Angle.prototype.transform = function (values) {
            if (this.spec.units == 'deg')
                values = array_1.map(values, function (x) {
                    return x * Math.PI / 180;
                });
            values = array_1.map(values, function (x) {
                return -x;
            });
            return _super.prototype.transform.call(this, values);
        };
        return Angle;
    }(units_prop('Angle', enums.AngleUnits, 'rad'));
    exports.Angle = Angle;
    var Distance = function (_super) {
        tslib_1.__extends(Distance, _super);
        function Distance() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Distance;
    }(units_prop('Distance', enums.SpatialUnits, 'data'));
    exports.Distance = Distance;
    //
    // DataSpec properties
    //
    var AngleSpec = function (_super) {
        tslib_1.__extends(AngleSpec, _super);
        function AngleSpec() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AngleSpec;
    }(Angle);
    exports.AngleSpec = AngleSpec;
    AngleSpec.prototype.dataspec = true;
    var ColorSpec = function (_super) {
        tslib_1.__extends(ColorSpec, _super);
        function ColorSpec() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ColorSpec;
    }(Color);
    exports.ColorSpec = ColorSpec;
    ColorSpec.prototype.dataspec = true;
    var DirectionSpec = function (_super) {
        tslib_1.__extends(DirectionSpec, _super);
        function DirectionSpec() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DirectionSpec;
    }(Distance);
    exports.DirectionSpec = DirectionSpec;
    DirectionSpec.prototype.dataspec = true;
    var DistanceSpec = function (_super) {
        tslib_1.__extends(DistanceSpec, _super);
        function DistanceSpec() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DistanceSpec;
    }(Distance);
    exports.DistanceSpec = DistanceSpec;
    DistanceSpec.prototype.dataspec = true;
    var FontSizeSpec = function (_super) {
        tslib_1.__extends(FontSizeSpec, _super);
        function FontSizeSpec() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return FontSizeSpec;
    }(String);
    exports.FontSizeSpec = FontSizeSpec;
    FontSizeSpec.prototype.dataspec = true;
    var NumberSpec = function (_super) {
        tslib_1.__extends(NumberSpec, _super);
        function NumberSpec() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return NumberSpec;
    }(Number);
    exports.NumberSpec = NumberSpec;
    NumberSpec.prototype.dataspec = true;
    var StringSpec = function (_super) {
        tslib_1.__extends(StringSpec, _super);
        function StringSpec() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return StringSpec;
    }(String);
    exports.StringSpec = StringSpec;
    StringSpec.prototype.dataspec = true;    
},
/*core/property_mixins*/
function _(require, module, exports) {
    var _fill_mixin, _gen_mixin, _line_mixin, _text_mixin;
    var p = require(15    /* ./properties */);
    var object_1 = require(30    /* ./util/object */);
    _gen_mixin = function (mixin, prefix) {
        var name, result, type;
        result = {};
        if (prefix == null) {
            prefix = '';
        }
        for (name in mixin) {
            type = mixin[name];
            result[prefix + name] = type;
        }
        return result;
    };
    _line_mixin = {
        line_color: [
            p.ColorSpec,
            'black'
        ],
        line_width: [
            p.NumberSpec,
            1
        ],
        line_alpha: [
            p.NumberSpec,
            1
        ],
        line_join: [
            p.LineJoin,
            'miter'
        ],
        line_cap: [
            p.LineCap,
            'butt'
        ],
        line_dash: [
            p.Array,
            []
        ],
        line_dash_offset: [
            p.Number,
            0
        ]
    };
    exports.line = function (prefix) {
        return _gen_mixin(_line_mixin, prefix);
    };
    _fill_mixin = {
        fill_color: [
            p.ColorSpec,
            'gray'
        ],
        fill_alpha: [
            p.NumberSpec,
            1
        ]
    };
    exports.fill = function (prefix) {
        return _gen_mixin(_fill_mixin, prefix);
    };
    _text_mixin = {
        text_font: [
            p.Font,
            'helvetica'
        ],
        text_font_size: [
            p.FontSizeSpec,
            '12pt'
        ],
        text_font_style: [
            p.FontStyle,
            'normal'
        ],
        text_color: [
            p.ColorSpec,
            '#444444'
        ],
        text_alpha: [
            p.NumberSpec,
            1
        ],
        text_align: [
            p.TextAlign,
            'left'
        ],
        text_baseline: [
            p.TextBaseline,
            'bottom'
        ],
        text_line_height: [
            p.Number,
            1.2
        ]
    };
    exports.text = function (prefix) {
        return _gen_mixin(_text_mixin, prefix);
    };
    exports.create = function (configs) {
        var config, i, kind, len, prefix, result;
        result = {};
        for (i = 0, len = configs.length; i < len; i++) {
            config = configs[i];
            _a = config.split(':'), kind = _a[0], prefix = _a[1];
            if (this[kind] == null) {
                throw new Error('Unknown property mixin kind \'' + kind + '\'');
            }
            result = object_1.extend(result, this[kind](prefix));
        }
        return result;
        var _a;
    };    
},
/*core/selection_manager*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var has_props_1 = require(8    /* ./has_props */);
    var selector_1 = require(18    /* ./selector */);
    var hittest = require(9    /* ./hittest */);
    var p = require(15    /* ./properties */);
    var SelectionManager = function (_super) {
        tslib_1.__extends(SelectionManager, _super);
        function SelectionManager() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SelectionManager.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this.selector = new selector_1.Selector();
            this.inspectors = {};
        };
        SelectionManager.prototype.select = function (renderer_views, geometry, final, append) {
            if (append === void 0) {
                append = false;
            }
            var did_hit = false;
            for (var _i = 0, renderer_views_1 = renderer_views; _i < renderer_views_1.length; _i++) {
                var r = renderer_views_1[_i];
                did_hit = did_hit || r.hit_test(geometry, final, append);
            }
            return did_hit;
        };
        SelectionManager.prototype.inspect = function (renderer_view, geometry) {
            var did_hit = false;
            did_hit = did_hit || renderer_view.hit_test(geometry, false, false, 'inspect');
            return did_hit;
        };
        SelectionManager.prototype.clear = function (_rview) {
            this.selector.clear();
            this.source.selected = hittest.create_hit_test_result();
        };
        SelectionManager.prototype.get_or_create_inspector = function (rmodel) {
            if (this.inspectors[rmodel.id] == null)
                this.inspectors[rmodel.id] = new selector_1.Selector();
            return this.inspectors[rmodel.id];
        };
        return SelectionManager;
    }(has_props_1.HasProps);
    exports.SelectionManager = SelectionManager;
    SelectionManager.prototype.type = 'SelectionManager';
    SelectionManager.internal({ source: [p.Any] });    
},
/*core/selector*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var has_props_1 = require(8    /* ./has_props */);
    var hittest_1 = require(9    /* ./hittest */);
    var p = require(15    /* ./properties */);
    var Selector = function (_super) {
        tslib_1.__extends(Selector, _super);
        function Selector() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Selector.prototype.update = function (indices, final, append, silent) {
            if (silent === void 0) {
                silent = false;
            }
            this.setv({ timestamp: new Date() }, { silent: silent });
            this.setv({ final: final }, { silent: silent });
            if (append)
                indices.update_through_union(this.indices);
            this.setv({ indices: indices }, { silent: silent });
        };
        Selector.prototype.clear = function () {
            this.timestamp = new Date();
            this.final = true;
            this.indices = new hittest_1.HitTestResult();
        };
        return Selector;
    }(has_props_1.HasProps);
    exports.Selector = Selector;
    Selector.prototype.type = 'Selector';
    Selector.internal({
        indices: [
            p.Any,
            function () {
                return new hittest_1.HitTestResult();
            }
        ],
        final: [p.Boolean],
        timestamp: [p.Any]
    });    
},
/*core/settings*/
function _(require, module, exports) {
    var Settings = function () {
        function Settings() {
            this._dev = false;
        }
        Object.defineProperty(Settings.prototype, 'dev', {
            get: function () {
                return this._dev;
            },
            set: function (dev) {
                this._dev = dev;
            },
            enumerable: true,
            configurable: true
        });
        return Settings;
    }();
    exports.Settings = Settings;
    exports.settings = new Settings();    
},
/*core/signaling*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var callback_1 = require(24    /* ./util/callback */);
    var array_1 = require(22    /* ./util/array */);
    var Signal = function () {
        function Signal(sender, name) {
            this.sender = sender;
            this.name = name;
        }
        Signal.prototype.connect = function (slot, context) {
            if (context === void 0) {
                context = null;
            }
            if (!receiversForSender.has(this.sender)) {
                receiversForSender.set(this.sender, []);
            }
            var receivers = receiversForSender.get(this.sender);
            if (findConnection(receivers, this, slot, context) != null) {
                return false;
            }
            var receiver = context || slot;
            if (!sendersForReceiver.has(receiver)) {
                sendersForReceiver.set(receiver, []);
            }
            var senders = sendersForReceiver.get(receiver);
            var connection = {
                signal: this,
                slot: slot,
                context: context
            };
            receivers.push(connection);
            senders.push(connection);
            return true;
        };
        Signal.prototype.disconnect = function (slot, context) {
            if (context === void 0) {
                context = null;
            }
            var receivers = receiversForSender.get(this.sender);
            if (receivers == null || receivers.length === 0) {
                return false;
            }
            var connection = findConnection(receivers, this, slot, context);
            if (connection == null) {
                return false;
            }
            var receiver = context || slot;
            var senders = sendersForReceiver.get(receiver);
            connection.signal = null;
            scheduleCleanup(receivers);
            scheduleCleanup(senders);
            return true;
        };
        Signal.prototype.emit = function (args) {
            var receivers = receiversForSender.get(this.sender) || [];
            for (var _i = 0, receivers_1 = receivers; _i < receivers_1.length; _i++) {
                var _a = receivers_1[_i], signal = _a.signal, slot = _a.slot, context = _a.context;
                if (signal === this) {
                    slot.call(context, args, this.sender);
                }
            }
        };
        return Signal;
    }();
    exports.Signal = Signal;
    (function (Signal) {
        function disconnectBetween(sender, receiver) {
            var receivers = receiversForSender.get(sender);
            if (receivers == null || receivers.length === 0)
                return;
            var senders = sendersForReceiver.get(receiver);
            if (senders == null || senders.length === 0)
                return;
            for (var _i = 0, senders_1 = senders; _i < senders_1.length; _i++) {
                var connection = senders_1[_i];
                if (connection.signal == null)
                    return;
                if (connection.signal.sender === sender)
                    connection.signal = null;
            }
            scheduleCleanup(receivers);
            scheduleCleanup(senders);
        }
        Signal.disconnectBetween = disconnectBetween;
        function disconnectSender(sender) {
            var receivers = receiversForSender.get(sender);
            if (receivers == null || receivers.length === 0)
                return;
            for (var _i = 0, receivers_2 = receivers; _i < receivers_2.length; _i++) {
                var connection = receivers_2[_i];
                if (connection.signal == null)
                    return;
                var receiver = connection.context || connection.slot;
                connection.signal = null;
                scheduleCleanup(sendersForReceiver.get(receiver));
            }
            scheduleCleanup(receivers);
        }
        Signal.disconnectSender = disconnectSender;
        function disconnectReceiver(receiver) {
            var senders = sendersForReceiver.get(receiver);
            if (senders == null || senders.length === 0)
                return;
            for (var _i = 0, senders_2 = senders; _i < senders_2.length; _i++) {
                var connection = senders_2[_i];
                if (connection.signal == null)
                    return;
                var sender = connection.signal.sender;
                connection.signal = null;
                scheduleCleanup(receiversForSender.get(sender));
            }
            scheduleCleanup(senders);
        }
        Signal.disconnectReceiver = disconnectReceiver;
        function disconnectAll(obj) {
            var receivers = receiversForSender.get(obj);
            if (receivers != null && receivers.length !== 0) {
                for (var _i = 0, receivers_3 = receivers; _i < receivers_3.length; _i++) {
                    var connection = receivers_3[_i];
                    connection.signal = null;
                }
                scheduleCleanup(receivers);
            }
            var senders = sendersForReceiver.get(obj);
            if (senders != null && senders.length !== 0) {
                for (var _a = 0, senders_3 = senders; _a < senders_3.length; _a++) {
                    var connection = senders_3[_a];
                    connection.signal = null;
                }
                scheduleCleanup(senders);
            }
        }
        Signal.disconnectAll = disconnectAll;
    }(Signal = exports.Signal || (exports.Signal = {})));
    exports.Signal = Signal;
    function Signalable(Base) {
        // XXX: `class Foo extends Signalable(Object)` doesn't work (compiles, but fails at runtime), so
        // we have to do this to allow signalable classes without an explict base class.
        if (Base != null) {
            return function (_super) {
                tslib_1.__extends(class_1, _super);
                function class_1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                class_1.prototype.connect = function (signal, slot) {
                    return signal.connect(slot, this);
                };
                return class_1;
            }(Base);
        } else {
            return function () {
                function class_2() {
                }
                class_2.prototype.connect = function (signal, slot) {
                    return signal.connect(slot, this);
                };
                return class_2;
            }();
        }
    }
    exports.Signalable = Signalable;
    var _Signalable;
    (function (_Signalable) {
        function connect(signal, slot) {
            return signal.connect(slot, this);
        }
        _Signalable.connect = connect;
    }(_Signalable = exports._Signalable || (exports._Signalable = {})));
    var receiversForSender = new WeakMap();
    var sendersForReceiver = new WeakMap();
    function findConnection(conns, signal, slot, context) {
        return array_1.find(conns, function (conn) {
            return conn.signal === signal && conn.slot === slot && conn.context === context;
        });
    }
    var dirtySet = new Set();
    function scheduleCleanup(connections) {
        if (dirtySet.size === 0) {
            callback_1.defer(cleanupDirtySet);
        }
        dirtySet.add(connections);
    }
    function cleanupDirtySet() {
        dirtySet.forEach(function (connections) {
            array_1.removeBy(connections, function (connection) {
                return connection.signal == null;
            });
        });
        dirtySet.clear();
    }    
},
/*core/ui_events*/
function _(require, module, exports) {
    var Hammer = require(318    /* hammerjs */);
    var signaling_1 = require(20    /* ./signaling */);
    var logging_1 = require(14    /* ./logging */);
    var dom_1 = require(5    /* ./dom */);
    var wheel_1 = require(43    /* ./util/wheel */);
    var object_1 = require(30    /* ./util/object */);
    var bokeh_events_1 = require(3    /* ./bokeh_events */);
    exports.UIEvents = function () {
        // new (plot_view: PlotCanvasView, toolbar: Toolbar, hit_area: Element, plot: Plot)
        function UIEvents(plot_view, toolbar, hit_area, plot) {
            this.plot_view = plot_view;
            this.toolbar = toolbar;
            this.hit_area = hit_area;
            this.plot = plot;
            this.tap = new signaling_1.Signal(this, 'tap');
            this.doubletap = new signaling_1.Signal(this, 'doubletap');
            this.press = new signaling_1.Signal(this, 'press');
            this.pan_start = new signaling_1.Signal(this, 'pan:start');
            this.pan = new signaling_1.Signal(this, 'pan');
            this.pan_end = new signaling_1.Signal(this, 'pan:end');
            this.pinch_start = new signaling_1.Signal(this, 'pinch:start');
            this.pinch = new signaling_1.Signal(this, 'pinch');
            this.pinch_end = new signaling_1.Signal(this, 'pinch:end');
            this.rotate_start = new signaling_1.Signal(this, 'rotate:start');
            this.rotate = new signaling_1.Signal(this, 'rotate');
            this.rotate_end = new signaling_1.Signal(this, 'rotate:end');
            this.move_enter = new signaling_1.Signal(this, 'move:enter');
            this.move = new signaling_1.Signal(this, 'move');
            this.move_exit = new signaling_1.Signal(this, 'move:exit');
            this.scroll = new signaling_1.Signal(this, 'scroll');
            this.keydown = new signaling_1.Signal(this, 'keydown');
            this.keyup = new signaling_1.Signal(this, 'keyup');
            this._configure_hammerjs();
        }
        UIEvents.prototype._configure_hammerjs = function () {
            var _this = this;
            this.hammer = new Hammer(this.hit_area);
            // This is to be able to distinguish double taps from single taps
            this.hammer.get('doubletap').recognizeWith('tap');
            this.hammer.get('tap').requireFailure('doubletap');
            this.hammer.get('doubletap').dropRequireFailure('tap');
            this.hammer.on('doubletap', function (e) {
                return _this._doubletap(e);
            });
            this.hammer.on('tap', function (e) {
                return _this._tap(e);
            });
            this.hammer.on('press', function (e) {
                return _this._press(e);
            });
            this.hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });
            this.hammer.on('panstart', function (e) {
                return _this._pan_start(e);
            });
            this.hammer.on('pan', function (e) {
                return _this._pan(e);
            });
            this.hammer.on('panend', function (e) {
                return _this._pan_end(e);
            });
            this.hammer.get('pinch').set({ enable: true });
            this.hammer.on('pinchstart', function (e) {
                return _this._pinch_start(e);
            });
            this.hammer.on('pinch', function (e) {
                return _this._pinch(e);
            });
            this.hammer.on('pinchend', function (e) {
                return _this._pinch_end(e);
            });
            this.hammer.get('rotate').set({ enable: true });
            this.hammer.on('rotatestart', function (e) {
                return _this._rotate_start(e);
            });
            this.hammer.on('rotate', function (e) {
                return _this._rotate(e);
            });
            this.hammer.on('rotateend', function (e) {
                return _this._rotate_end(e);
            });
            this.hit_area.addEventListener('mousemove', function (e) {
                return _this._mouse_move(e);
            });
            this.hit_area.addEventListener('mouseenter', function (e) {
                return _this._mouse_enter(e);
            });
            this.hit_area.addEventListener('mouseleave', function (e) {
                return _this._mouse_exit(e);
            });
            this.hit_area.addEventListener('wheel', function (e) {
                return _this._mouse_wheel(e);
            });
            document.addEventListener('keydown', function (e) {
                return _this._key_down(e);
            });
            return document.addEventListener('keyup', function (e) {
                return _this._key_up(e);
            });
        };
        UIEvents.prototype.register_tool = function (tool_view, event_type) {
            var e, et, i, id, len, type, v;
            et = event_type || tool_view.model.event_type;
            if (et != null && !(typeof et === 'string')) {
                for (i = 0, len = et.length; i < len; i++) {
                    e = et[i];
                    this.register_tool(tool_view, e);
                }
                return;
            }
            id = tool_view.model.id;
            type = tool_view.model.type;
            // tool_viewbar button events handled by tool_view manager
            if (et == null) {
                logging_1.logger.debug('Button tool: ' + type);
                return;
            }
            v = tool_view;
            switch (et) {
            case 'pan':
                if (v._pan_start != null) {
                    v.connect(this.pan_start, function (x) {
                        if (x.id === id) {
                            return v._pan_start(x.e);
                        }
                    });
                }
                if (v._pan != null) {
                    v.connect(this.pan, function (x) {
                        if (x.id === id) {
                            return v._pan(x.e);
                        }
                    });
                }
                if (v._pan_end != null) {
                    v.connect(this.pan_end, function (x) {
                        if (x.id === id) {
                            return v._pan_end(x.e);
                        }
                    });
                }
                break;
            case 'pinch':
                if (v._pinch_start != null) {
                    v.connect(this.pinch_start, function (x) {
                        if (x.id === id) {
                            return v._pinch_start(x.e);
                        }
                    });
                }
                if (v._pinch != null) {
                    v.connect(this.pinch, function (x) {
                        if (x.id === id) {
                            return v._pinch(x.e);
                        }
                    });
                }
                if (v._pinch_end != null) {
                    v.connect(this.pinch_end, function (x) {
                        if (x.id === id) {
                            return v._pinch_end(x.e);
                        }
                    });
                }
                break;
            case 'rotate':
                if (v._rotate_start != null) {
                    v.connect(this.rotate_start, function (x) {
                        if (x.id === id) {
                            return v._rotate_start(x.e);
                        }
                    });
                }
                if (v._rotate != null) {
                    v.connect(this.rotate, function (x) {
                        if (x.id === id) {
                            return v._rotate(x.e);
                        }
                    });
                }
                if (v._rotate_end != null) {
                    v.connect(this.rotate_end, function (x) {
                        if (x.id === id) {
                            return v._rotate_end(x.e);
                        }
                    });
                }
                break;
            case 'move':
                if (v._move_enter != null) {
                    v.connect(this.move_enter, function (x) {
                        if (x.id === id) {
                            return v._move_enter(x.e);
                        }
                    });
                }
                if (v._move != null) {
                    v.connect(this.move, function (x) {
                        if (x.id === id) {
                            return v._move(x.e);
                        }
                    });
                }
                if (v._move_exit != null) {
                    v.connect(this.move_exit, function (x) {
                        if (x.id === id) {
                            return v._move_exit(x.e);
                        }
                    });
                }
                break;
            case 'tap':
                if (v._tap != null) {
                    v.connect(this.tap, function (x) {
                        if (x.id === id) {
                            return v._tap(x.e);
                        }
                    });
                }
                break;
            case 'press':
                if (v._press != null) {
                    v.connect(this.press, function (x) {
                        if (x.id === id) {
                            return v._press(x.e);
                        }
                    });
                }
                break;
            case 'scroll':
                if (v._scroll != null) {
                    v.connect(this.scroll, function (x) {
                        if (x.id === id) {
                            return v._scroll(x.e);
                        }
                    });
                }
                break;
            default:
                throw new Error('unsupported event_type: ' + ev);
            }
            if (v._doubletap != null) {
                v.connect(this.doubletap, function (x) {
                    return v._doubletap(x.e);
                });
            }
            if (v._keydown != null) {
                v.connect(this.keydown, function (x) {
                    return v._keydown(x.e);
                });
            }
            if (v._keyup != null) {
                v.connect(this.keyup, function (x) {
                    return v._keyup(x.e);
                });
            }
            // Dual touch hack part 1/2
            // This is a hack for laptops with touch screen who may be pinching or scrolling
            // in order to use the wheel zoom tool. If it's a touch screen the WheelZoomTool event
            // will be linked to pinch. But we also want to trigger in the case of a scroll.
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                if (et === 'pinch') {
                    logging_1.logger.debug('Registering scroll on touch screen');
                    return v.connect(this.scroll, function (x) {
                        if (x.id === id) {
                            return v._scroll(x.e);
                        }
                    });
                }
            }
        };
        UIEvents.prototype._hit_test_renderers = function (sx, sy) {
            var i, ref, ref1, view;
            ref = this.plot_view.get_renderer_views();
            for (i = ref.length - 1; i >= 0; i += -1) {
                view = ref[i];
                if (((ref1 = view.model.level) === 'annotation' || ref1 === 'overlay') && view.bbox != null) {
                    if (view.bbox().contains(sx, sy)) {
                        return view;
                    }
                }
            }
            return null;
        };
        UIEvents.prototype._hit_test_frame = function (sx, sy) {
            return this.plot_view.frame.bbox.contains(sx, sy);
        };
        UIEvents.prototype._trigger = function (signal, e) {
            var active_gesture, active_inspectors, base, base_type, cursor, event_type, i, inspector, len, results, view;
            event_type = signal.name;
            base_type = event_type.split(':')[0];
            view = this._hit_test_renderers(e.bokeh.sx, e.bokeh.sy);
            switch (base_type) {
            case 'move':
                active_inspectors = this.toolbar.inspectors.filter(function (t) {
                    return t.active;
                });
                cursor = 'default';
                // the event happened on a renderer
                if (view != null) {
                    if (view.model.cursor != null) {
                        cursor = view.model.cursor();
                    }
                    if (!object_1.isEmpty(active_inspectors)) {
                        // override event_type to cause inspectors to clear overlays
                        signal = this.move_exit;
                        event_type = signal.name;
                    }    // the event happened on the plot frame but off a renderer
                } else if (this._hit_test_frame(e.bokeh.sx, e.bokeh.sy)) {
                    if (!object_1.isEmpty(active_inspectors)) {
                        cursor = 'crosshair';
                    }
                }
                this.plot_view.set_cursor(cursor);
                results = [];
                for (i = 0, len = active_inspectors.length; i < len; i++) {
                    inspector = active_inspectors[i];
                    results.push(this.trigger(signal, e, inspector.id));
                }
                return results;
                break;
            case 'tap':
                if (view != null) {
                    if (typeof view.on_hit === 'function') {
                        view.on_hit(e.bokeh.sx, e.bokeh.sy);
                    }
                }
                active_gesture = this.toolbar.gestures[base_type].active;
                if (active_gesture != null) {
                    return this.trigger(signal, e, active_gesture.id);
                }
                break;
            case 'scroll':
                // Dual touch hack part 2/2
                // This is a hack for laptops with touch screen who may be pinching or scrolling
                // in order to use the wheel zoom tool. If it's a touch screen the WheelZoomTool event
                // will be linked to pinch. But we also want to trigger in the case of a scroll.
                base = 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? 'pinch' : 'scroll';
                active_gesture = this.toolbar.gestures[base].active;
                if (active_gesture != null) {
                    e.preventDefault();
                    e.stopPropagation();
                    return this.trigger(signal, e, active_gesture.id);
                }
                break;
            default:
                active_gesture = this.toolbar.gestures[base_type].active;
                if (active_gesture != null) {
                    return this.trigger(signal, e, active_gesture.id);
                }
            }
        };
        UIEvents.prototype.trigger = function (signal, event, id) {
            if (id === void 0) {
                id = null;
            }
            return signal.emit({
                id: id,
                e: event
            });
        };
        UIEvents.prototype._event_sxy = function (event) {
            var left, top;
            _a = dom_1.offset(this.hit_area), left = _a.left, top = _a.top;
            return {
                sx: event.pageX - left,
                sy: event.pageY - top
            };
            var _a;
        };
        UIEvents.prototype._bokify_hammer = function (e, extras) {
            if (extras === void 0) {
                extras = {};
            }
            var event_cls;
            e.bokeh = object_1.extend(this._event_sxy(e.srcEvent), extras);
            event_cls = bokeh_events_1.BokehEvent.event_class(e);
            if (event_cls != null) {
                return this.plot.trigger_event(event_cls.from_event(e));
            } else {
                return logging_1.logger.debug('Unhandled event of type ' + e.type);
            }
        };
        UIEvents.prototype._bokify_point_event = function (e, extras) {
            if (extras === void 0) {
                extras = {};
            }
            var event_cls;
            e.bokeh = object_1.extend(this._event_sxy(e), extras);
            event_cls = bokeh_events_1.BokehEvent.event_class(e);
            if (event_cls != null) {
                return this.plot.trigger_event(event_cls.from_event(e));
            } else {
                return logging_1.logger.debug('Unhandled event of type ' + e.type);
            }
        };
        UIEvents.prototype._tap = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.tap, e);
        };
        UIEvents.prototype._doubletap = function (e) {
            // NOTE: doubletap event triggered unconditionally
            this._bokify_hammer(e);
            return this.trigger(this.doubletap, e);
        };
        UIEvents.prototype._press = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.press, e);
        };
        UIEvents.prototype._pan_start = function (e) {
            this._bokify_hammer(e);
            // back out delta to get original center point
            e.bokeh.sx -= e.deltaX;
            e.bokeh.sy -= e.deltaY;
            return this._trigger(this.pan_start, e);
        };
        UIEvents.prototype._pan = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.pan, e);
        };
        UIEvents.prototype._pan_end = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.pan_end, e);
        };
        UIEvents.prototype._pinch_start = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.pinch_start, e);
        };
        UIEvents.prototype._pinch = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.pinch, e);
        };
        UIEvents.prototype._pinch_end = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.pinch_end, e);
        };
        UIEvents.prototype._rotate_start = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.rotate_start, e);
        };
        UIEvents.prototype._rotate = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.rotate, e);
        };
        UIEvents.prototype._rotate_end = function (e) {
            this._bokify_hammer(e);
            return this._trigger(this.rotate_end, e);
        };
        UIEvents.prototype._mouse_enter = function (e) {
            this._bokify_point_event(e);
            return this._trigger(this.move_enter, e);
        };
        UIEvents.prototype._mouse_move = function (e) {
            this._bokify_point_event(e);
            return this._trigger(this.move, e);
        };
        UIEvents.prototype._mouse_exit = function (e) {
            this._bokify_point_event(e);
            return this._trigger(this.move_exit, e);
        };
        UIEvents.prototype._mouse_wheel = function (e) {
            this._bokify_point_event(e, { delta: wheel_1.getDeltaY(e) });
            return this._trigger(this.scroll, e);
        };
        UIEvents.prototype._key_down = function (e) {
            // NOTE: keyup event triggered unconditionally
            return this.trigger(this.keydown, e);
        };
        UIEvents.prototype._key_up = function (e) {
            // NOTE: keyup event triggered unconditionally
            return this.trigger(this.keyup, e);
        };
        return UIEvents;
    }();    
},
/*core/util/array*/
function _(require, module, exports) {
    var math_1 = require(29    /* ./math */);
    var slice = Array.prototype.slice;
    function head(array) {
        return array[0];
    }
    exports.head = head;
    function tail(array) {
        return array[array.length - 1];
    }
    exports.tail = tail;
    function last(array) {
        return array[array.length - 1];
    }
    exports.last = last;
    function copy(array) {
        return slice.call(array);
    }
    exports.copy = copy;
    function concat(arrays) {
        return (_a = []).concat.apply(_a, arrays);
        var _a;
    }
    exports.concat = concat;
    function contains(array, value) {
        return array.indexOf(value) !== -1;
    }
    exports.contains = contains;
    function nth(array, index) {
        return array[index >= 0 ? index : array.length + index];
    }
    exports.nth = nth;
    function zip(As, Bs) {
        var n = Math.min(As.length, Bs.length);
        var ABs = new Array(n);
        for (var i = 0; i < n; i++) {
            ABs[i] = [
                As[i],
                Bs[i]
            ];
        }
        return ABs;
    }
    exports.zip = zip;
    function unzip(ABs) {
        var n = ABs.length;
        var As = new Array(n);
        var Bs = new Array(n);
        for (var i = 0; i < n; i++) {
            _a = ABs[i], As[i] = _a[0], Bs[i] = _a[1];
        }
        return [
            As,
            Bs
        ];
        var _a;
    }
    exports.unzip = unzip;
    function range(start, stop, step) {
        if (step === void 0) {
            step = 1;
        }
        if (stop == null) {
            stop = start;
            start = 0;
        }
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
        for (var i = 0; i < length; i++, start += step) {
            range[i] = start;
        }
        return range;
    }
    exports.range = range;
    function linspace(start, stop, num) {
        if (num === void 0) {
            num = 100;
        }
        var step = (stop - start) / (num - 1);
        var array = new Array(num);
        for (var i = 0; i < num; i++) {
            array[i] = start + step * i;
        }
        return array;
    }
    exports.linspace = linspace;
    function transpose(array) {
        var rows = array.length;
        var cols = array[0].length;
        var transposed = [];
        for (var j = 0; j < cols; j++) {
            transposed[j] = [];
            for (var i = 0; i < rows; i++) {
                transposed[j][i] = array[i][j];
            }
        }
        return transposed;
    }
    exports.transpose = transpose;
    function sum(array) {
        return array.reduce(function (a, b) {
            return a + b;
        }, 0);
    }
    exports.sum = sum;
    function cumsum(array) {
        var result = [];
        array.reduce(function (a, b, i) {
            return result[i] = a + b;
        }, 0);
        return result;
    }
    exports.cumsum = cumsum;
    function min(array) {
        var value;
        var result = Infinity;
        for (var i = 0, length_1 = array.length; i < length_1; i++) {
            value = array[i];
            if (value < result) {
                result = value;
            }
        }
        return result;
    }
    exports.min = min;
    function minBy(array, key) {
        if (array.length == 0)
            throw new Error('minBy() called with an empty array');
        var result = array[0];
        var resultComputed = key(result);
        for (var i = 1, length_2 = array.length; i < length_2; i++) {
            var value = array[i];
            var computed = key(value);
            if (computed < resultComputed) {
                result = value;
                resultComputed = computed;
            }
        }
        return result;
    }
    exports.minBy = minBy;
    function max(array) {
        var value;
        var result = -Infinity;
        for (var i = 0, length_3 = array.length; i < length_3; i++) {
            value = array[i];
            if (value > result) {
                result = value;
            }
        }
        return result;
    }
    exports.max = max;
    function maxBy(array, key) {
        if (array.length == 0)
            throw new Error('maxBy() called with an empty array');
        var result = array[0];
        var resultComputed = key(result);
        for (var i = 1, length_4 = array.length; i < length_4; i++) {
            var value = array[i];
            var computed = key(value);
            if (computed > resultComputed) {
                result = value;
                resultComputed = computed;
            }
        }
        return result;
    }
    exports.maxBy = maxBy;
    function argmin(array) {
        return minBy(range(array.length), function (i) {
            return array[i];
        });
    }
    exports.argmin = argmin;
    function argmax(array) {
        return maxBy(range(array.length), function (i) {
            return array[i];
        });
    }
    exports.argmax = argmax;
    function all(array, predicate) {
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var item = array_1[_i];
            if (!predicate(item))
                return false;
        }
        return true;
    }
    exports.all = all;
    function any(array, predicate) {
        for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
            var item = array_2[_i];
            if (predicate(item))
                return true;
        }
        return false;
    }
    exports.any = any;
    function findIndexFactory(dir) {
        return function (array, predicate) {
            var length = array.length;
            var index = dir > 0 ? 0 : length - 1;
            for (; index >= 0 && index < length; index += dir) {
                if (predicate(array[index]))
                    return index;
            }
            return -1;
        };
    }
    exports.findIndex = findIndexFactory(1);
    exports.findLastIndex = findIndexFactory(-1);
    function find(array, predicate) {
        var index = exports.findIndex(array, predicate);
        return index == -1 ? undefined : array[index];
    }
    exports.find = find;
    function findLast(array, predicate) {
        var index = exports.findLastIndex(array, predicate);
        return index == -1 ? undefined : array[index];
    }
    exports.findLast = findLast;
    function sortedIndex(array, value) {
        var low = 0;
        var high = array.length;
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (array[mid] < value)
                low = mid + 1;
            else
                high = mid;
        }
        return low;
    }
    exports.sortedIndex = sortedIndex;
    function sortBy(array, key) {
        var tmp = array.map(function (value, index) {
            return {
                value: value,
                index: index,
                key: key(value)
            };
        });
        tmp.sort(function (left, right) {
            var a = left.key;
            var b = right.key;
            if (a !== b) {
                if (a > b || a === undefined)
                    return 1;
                if (a < b || b === undefined)
                    return -1;
            }
            return left.index - right.index;
        });
        return tmp.map(function (item) {
            return item.value;
        });
    }
    exports.sortBy = sortBy;
    function uniq(array) {
        var result = [];
        for (var _i = 0, array_3 = array; _i < array_3.length; _i++) {
            var value = array_3[_i];
            if (!contains(result, value)) {
                result.push(value);
            }
        }
        return result;
    }
    exports.uniq = uniq;
    function uniqBy(array, key) {
        var result = [];
        var seen = [];
        for (var _i = 0, array_4 = array; _i < array_4.length; _i++) {
            var value = array_4[_i];
            var computed = key(value);
            if (!contains(seen, computed)) {
                seen.push(computed);
                result.push(value);
            }
        }
        return result;
    }
    exports.uniqBy = uniqBy;
    function union() {
        var arrays = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arrays[_i] = arguments[_i];
        }
        return uniq(concat(arrays));
    }
    exports.union = union;
    function intersection(array) {
        var arrays = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            arrays[_i - 1] = arguments[_i];
        }
        var result = [];
        top:
            for (var _a = 0, array_5 = array; _a < array_5.length; _a++) {
                var item = array_5[_a];
                if (contains(result, item))
                    continue;
                for (var _b = 0, arrays_1 = arrays; _b < arrays_1.length; _b++) {
                    var other = arrays_1[_b];
                    if (!contains(other, item))
                        continue top;
                }
                result.push(item);
            }
        return result;
    }
    exports.intersection = intersection;
    function difference(array) {
        var arrays = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            arrays[_i - 1] = arguments[_i];
        }
        var rest = concat(arrays);
        return array.filter(function (value) {
            return !contains(rest, value);
        });
    }
    exports.difference = difference;
    function removeBy(array, key) {
        for (var i = 0; i < array.length;) {
            if (key(array[i]))
                array.splice(i, 1);
            else
                i++;
        }
    }
    exports.removeBy = removeBy;
    // Shuffle a collection, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
    function shuffle(array) {
        var length = array.length;
        var shuffled = new Array(length);
        for (var i = 0; i < length; i++) {
            var rand = math_1.randomIn(0, i);
            if (rand !== i)
                shuffled[i] = shuffled[rand];
            shuffled[rand] = array[i];
        }
        return shuffled;
    }
    exports.shuffle = shuffle;
    function pairwise(array, fn) {
        var n = array.length;
        var result = new Array(n - 1);
        for (var i = 0; i < n - 1; i++) {
            result[i] = fn(array[i], array[i + 1]);
        }
        return result;
    }
    exports.pairwise = pairwise;
    function reversed(array) {
        var n = array.length;
        var result = new Array(n);
        for (var i = 0; i < n; i++) {
            result[n - i - 1] = array[i];
        }
        return result;
    }
    exports.reversed = reversed;
    function repeat(value, n) {
        var result = new Array(n);
        for (var i = 0; i < n; i++) {
            result[i] = value;
        }
        return result;
    }
    exports.repeat = repeat;
    function map(array, fn) {
        var n = array.length;
        var result = new Array(n);
        for (var i = 0; i < n; i++) {
            result[i] = fn(array[i]);
        }
        return result;
    }
    exports.map = map;    
},
/*core/util/bbox*/
function _(require, module, exports) {
    var min = Math.min, max = Math.max;
    function empty() {
        return {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
    }
    exports.empty = empty;
    function positive_x() {
        return {
            minX: Number.MIN_VALUE,
            minY: -Infinity,
            maxX: Infinity,
            maxY: Infinity
        };
    }
    exports.positive_x = positive_x;
    function positive_y() {
        return {
            minX: -Infinity,
            minY: Number.MIN_VALUE,
            maxX: Infinity,
            maxY: Infinity
        };
    }
    exports.positive_y = positive_y;
    function union(a, b) {
        return {
            minX: min(a.minX, b.minX),
            maxX: max(a.maxX, b.maxX),
            minY: min(a.minY, b.minY),
            maxY: max(a.maxY, b.maxY)
        };
    }
    exports.union = union;
    var BBox = function () {
        function BBox(box) {
            if ('x0' in box && 'y0' in box && 'x1' in box && 'y1' in box) {
                var _a = box, x0 = _a.x0, y0 = _a.y0, x1 = _a.x1, y1 = _a.y1;
                if (!(x0 <= x1 && y0 <= y1))
                    throw new Error('invalid bbox {x0: ' + x0 + ', y0: ' + y0 + ', x1: ' + x1 + ', y1: ' + y1 + '}');
                this.x0 = x0;
                this.y0 = y0;
                this.x1 = x1;
                this.y1 = y1;
            } else {
                var _b = box, x = _b.x, y = _b.y, width = _b.width, height = _b.height;
                if (!(width >= 0 && height >= 0))
                    throw new Error('invalid bbox {x: ' + x + ', y: ' + y + ', width: ' + width + ', height: ' + height + '}');
                this.x0 = x;
                this.y0 = y;
                this.x1 = x + width;
                this.y1 = y + height;
            }
        }
        Object.defineProperty(BBox.prototype, 'minX', {
            get: function () {
                return this.x0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'minY', {
            get: function () {
                return this.y0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'maxX', {
            get: function () {
                return this.x1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'maxY', {
            get: function () {
                return this.y1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'left', {
            get: function () {
                return this.x0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'top', {
            get: function () {
                return this.y0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'right', {
            get: function () {
                return this.x1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'bottom', {
            get: function () {
                return this.y1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'p0', {
            get: function () {
                return [
                    this.x0,
                    this.y0
                ];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'p1', {
            get: function () {
                return [
                    this.x1,
                    this.y1
                ];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'x', {
            get: function () {
                return this.x0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'y', {
            get: function () {
                return this.y0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'width', {
            get: function () {
                return this.x1 - this.x0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'height', {
            get: function () {
                return this.y1 - this.y0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'rect', {
            get: function () {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'h_range', {
            get: function () {
                return {
                    start: this.x0,
                    end: this.x1
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'v_range', {
            get: function () {
                return {
                    start: this.y0,
                    end: this.y1
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'ranges', {
            get: function () {
                return [
                    this.h_range,
                    this.v_range
                ];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BBox.prototype, 'aspect', {
            get: function () {
                return this.width / this.height;
            },
            enumerable: true,
            configurable: true
        });
        BBox.prototype.contains = function (x, y) {
            return x >= this.x0 && x <= this.x1 && y >= this.y0 && y <= this.y1;
        };
        BBox.prototype.clip = function (x, y) {
            if (x < this.x0)
                x = this.x0;
            else if (x > this.x1)
                x = this.x1;
            if (y < this.y0)
                y = this.y0;
            else if (y > this.y1)
                y = this.y1;
            return [
                x,
                y
            ];
        };
        BBox.prototype.union = function (that) {
            return new BBox({
                x0: min(this.x0, that.x0),
                y0: min(this.y0, that.y0),
                x1: max(this.x1, that.x1),
                y1: max(this.y1, that.y1)
            });
        };
        return BBox;
    }();
    exports.BBox = BBox;    
},
/*core/util/callback*/
function _(require, module, exports) {
    function delay(func, wait) {
        return setTimeout(func, wait);
    }
    exports.delay = delay;
    var _defer = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : setImmediate;
    function defer(func) {
        return _defer(func);
    }
    exports.defer = defer;
    function throttle(func, wait, options) {
        if (options === void 0) {
            options = {};
        }
        var context, args, result;
        var timeout = null;
        var previous = 0;
        var later = function () {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        };
        return function () {
            var now = Date.now();
            if (!previous && options.leading === false)
                previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout)
                    context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    }
    exports.throttle = throttle;
    function once(func) {
        var done = false;
        var memo;
        return function () {
            if (!done) {
                done = true;
                memo = func();
            }
            return memo;
        };
    }
    exports.once = once;    
},
/*core/util/canvas*/
function _(require, module, exports) {
    function fixup_line_dash(ctx) {
        if (!ctx.setLineDash) {
            ctx.setLineDash = function (dash) {
                ctx.mozDash = dash;
                ctx.webkitLineDash = dash;
            };
        }
        if (!ctx.getLineDash) {
            ctx.getLineDash = function () {
                return ctx.mozDash;
            };
        }
    }
    function fixup_line_dash_offset(ctx) {
        ctx.setLineDashOffset = function (dash_offset) {
            ctx.lineDashOffset = dash_offset;
            ctx.mozDashOffset = dash_offset;
            ctx.webkitLineDashOffset = dash_offset;
        };
        ctx.getLineDashOffset = function () {
            return ctx.mozDashOffset;
        };
    }
    function fixup_image_smoothing(ctx) {
        ctx.setImageSmoothingEnabled = function (value) {
            ctx.imageSmoothingEnabled = value;
            ctx.mozImageSmoothingEnabled = value;
            ctx.oImageSmoothingEnabled = value;
            ctx.webkitImageSmoothingEnabled = value;
            ctx.msImageSmoothingEnabled = value;
        };
        ctx.getImageSmoothingEnabled = function () {
            var val = ctx.imageSmoothingEnabled;
            return val != null ? val : true;
        };
    }
    function fixup_measure_text(ctx) {
        if (ctx.measureText && ctx.html5MeasureText == null) {
            ctx.html5MeasureText = ctx.measureText;
            ctx.measureText = function (text) {
                var textMetrics = ctx.html5MeasureText(text);
                // fake it til you make it
                textMetrics.ascent = ctx.html5MeasureText('m').width * 1.6;
                return textMetrics;
            };
        }
    }
    function fixup_ellipse(ctx) {
        // implementing the ctx.ellipse function with bezier curves
        // we don't implement the startAngle, endAngle and anticlockwise arguments.
        function ellipse_bezier(x, y, radiusX, radiusY, rotation, _startAngle, _endAngle, anticlockwise) {
            if (anticlockwise === void 0) {
                anticlockwise = false;
            }
            var c = 0.551784;
            // see http://www.tinaja.com/glib/ellipse4.pdf
            ctx.translate(x, y);
            ctx.rotate(rotation);
            var rx = radiusX;
            var ry = radiusY;
            if (anticlockwise) {
                rx = -radiusX;
                ry = -radiusY;
            }
            ctx.moveTo(-rx, 0);
            // start point of first curve
            ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);
            ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);
            ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);
            ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);
            ctx.rotate(-rotation);
            ctx.translate(-x, -y);
        }
        if (!ctx.ellipse)
            ctx.ellipse = ellipse_bezier;
    }
    function fixup_ctx(ctx) {
        fixup_line_dash(ctx);
        fixup_line_dash_offset(ctx);
        fixup_image_smoothing(ctx);
        fixup_measure_text(ctx);
        fixup_ellipse(ctx);
    }
    exports.fixup_ctx = fixup_ctx;
    function get_scale_ratio(ctx, hidpi, backend) {
        if (backend == 'svg')
            return 1;
        else if (hidpi) {
            var devicePixelRatio_1 = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
            return devicePixelRatio_1 / backingStoreRatio;
        } else
            return 1;
    }
    exports.get_scale_ratio = get_scale_ratio;    
},
/*core/util/color*/
function _(require, module, exports) {
    var _component2hex, indexOf = [].indexOf;
    var svg_colors = require(38    /* ./svg_colors */);
    _component2hex = function (v) {
        var h;
        h = Number(v).toString(16);
        return h = h.length === 1 ? '0' + h : h;
    };
    exports.color2hex = function (color) {
        var hex, hex_string, rgb, v;
        color = color + '';
        if (color.indexOf('#') === 0) {
            return color;
        } else if (svg_colors[color] != null) {
            return svg_colors[color];
        } else if (color.indexOf('rgb') === 0) {
            rgb = color.replace(/^rgba?\(|\s+|\)$/g, '').split(',');
            hex = function () {
                var j, len, ref, results;
                ref = rgb.slice(0, 3);
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    v = ref[j];
                    results.push(_component2hex(v));
                }
                return results;
            }().join('');
            if (rgb.length === 4) {
                hex = hex + _component2hex(Math.floor(parseFloat(rgb.slice(3)) * 255));
            }
            hex_string = '#' + hex.slice(0, 8);
            // can also be rgba
            return hex_string;
        } else {
            return color;
        }
    };
    exports.color2rgba = function (color, alpha) {
        if (alpha === void 0) {
            alpha = 1;
        }
        var hex, i, rgba;
        if (!color) {
            return [
                0,
                0,
                0,
                0    // transparent
            ];
        }
        // Convert to hex and then to clean version of 6 or 8 chars
        hex = exports.color2hex(color);
        hex = hex.replace(/ |#/g, '');
        if (hex.length <= 4) {
            hex = hex.replace(/(.)/g, '$1$1');
        }
        // Convert pairs to numbers
        hex = hex.match(/../g);
        rgba = function () {
            var j, len, results;
            results = [];
            for (j = 0, len = hex.length; j < len; j++) {
                i = hex[j];
                results.push(parseInt(i, 16) / 255);
            }
            return results;
        }();
        // Ensure correct length, add alpha if necessary
        while (rgba.length < 3) {
            rgba.push(0);
        }
        if (rgba.length < 4) {
            rgba.push(alpha);
        }
        return rgba.slice(0, 4);    // return 4 elements
    };
    exports.valid_rgb = function (value) {
        var contents, params, ref, rgb;
        switch (value.substring(0, 4)) {
        case 'rgba':
            params = {
                start: 'rgba(',
                len: 4,
                alpha: true
            };
            break;
        case 'rgb(':
            params = {
                start: 'rgb(',
                len: 3,
                alpha: false
            };
            break;
        default:
            return false;
        }
        // if '.' and then ',' found, we know decimals are used on rgb
        if (new RegExp('.*?(\\.).*(,)').test(value)) {
            throw new Error('color expects integers for rgb in rgb/rgba tuple, received ' + value);
        }
        // extract the numerical values from inside parens
        contents = value.replace(params.start, '').replace(')', '').split(',').map(parseFloat);
        // check length of array based on rgb/rgba
        if (contents.length !== params.len) {
            throw new Error('color expects rgba ' + expect_len + '-tuple, received ' + value);
        }
        // check for valid numerical values for rgba
        if (params.alpha && !(0 <= (ref = contents[3]) && ref <= 1)) {
            throw new Error('color expects rgba 4-tuple to have alpha value between 0 and 1');
        }
        if (indexOf.call(function () {
                var j, len, ref1, results;
                ref1 = contents.slice(0, 3);
                results = [];
                for (j = 0, len = ref1.length; j < len; j++) {
                    rgb = ref1[j];
                    results.push(0 <= rgb && rgb <= 255);
                }
                return results;
            }(), false) >= 0) {
            throw new Error('color expects rgb to have value between 0 and 255');
        }
        return true;
    };    
},
/*core/util/data_structures*/
function _(require, module, exports) {
    var array_1 = require(22    /* ./array */);
    var eq_1 = require(28    /* ./eq */);
    var types_1 = require(42    /* ./types */);
    var MultiDict = function () {
        function MultiDict() {
            this._dict = {};
        }
        MultiDict.prototype._existing = function (key) {
            if (key in this._dict)
                return this._dict[key];
            else
                return null;
        };
        MultiDict.prototype.add_value = function (key, value) {
            /*
        if value == null
          throw new Error("Can't put null in this dict")
        if isArray(value)
          throw new Error("Can't put arrays in this dict")
        */
            var existing = this._existing(key);
            if (existing == null) {
                this._dict[key] = value;
            } else if (types_1.isArray(existing)) {
                existing.push(value);
            } else {
                this._dict[key] = [
                    existing,
                    value
                ];
            }
        };
        MultiDict.prototype.remove_value = function (key, value) {
            var existing = this._existing(key);
            if (types_1.isArray(existing)) {
                var new_array = array_1.difference(existing, [value]);
                if (new_array.length > 0)
                    this._dict[key] = new_array;
                else
                    delete this._dict[key];
            } else if (eq_1.isEqual(existing, value)) {
                delete this._dict[key];
            }
        };
        MultiDict.prototype.get_one = function (key, duplicate_error) {
            var existing = this._existing(key);
            if (types_1.isArray(existing)) {
                if (existing.length === 1)
                    return existing[0];
                else
                    throw new Error(duplicate_error);
            } else
                return existing;
        };
        return MultiDict;
    }();
    exports.MultiDict = MultiDict;
    var Set = function () {
        function Set(obj) {
            if (obj == null) {
                this.values = [];
            } else if (obj instanceof Set) {
                this.values = array_1.copy(obj.values);
            } else {
                this.values = this._compact(obj);
            }
        }
        Set.prototype._compact = function (array) {
            var newArray = [];
            for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
                var item = array_2[_i];
                if (newArray.indexOf(item) === -1) {
                    newArray.push(item);
                }
            }
            return newArray;
        };
        Set.prototype.push = function (item) {
            if (this.missing(item))
                this.values.push(item);
        };
        Set.prototype.remove = function (item) {
            var i = this.values.indexOf(item);
            this.values = this.values.slice(0, i).concat(this.values.slice(i + 1));
        };
        Set.prototype.length = function () {
            return this.values.length;
        };
        Set.prototype.includes = function (item) {
            return this.values.indexOf(item) != -1;
        };
        Set.prototype.missing = function (item) {
            return !this.includes(item);
        };
        Set.prototype.slice = function (from, to) {
            return this.values.slice(from, to);
        };
        Set.prototype.join = function (str) {
            return this.values.join(str);
        };
        Set.prototype.toString = function () {
            return this.join(', ');
        };
        Set.prototype.union = function (set) {
            set = new Set(set);
            return new Set(this.values.concat(set.values));
        };
        Set.prototype.intersect = function (set) {
            set = new Set(set);
            var newSet = new Set();
            for (var _i = 0, _a = set.values; _i < _a.length; _i++) {
                var item = _a[_i];
                if (this.includes(item) && set.includes(item))
                    newSet.push(item);
            }
            return newSet;
        };
        Set.prototype.diff = function (set) {
            set = new Set(set);
            var newSet = new Set();
            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
                var item = _a[_i];
                if (set.missing(item))
                    newSet.push(item);
            }
            return newSet;
        };
        return Set;
    }();
    exports.Set = Set;    
},
/*core/util/eq*/
function _(require, module, exports) {
    var types_1 = require(42    /* ./types */);
    var toString = Object.prototype.toString;
    // Internal recursive comparison function for `isEqual`.
    function eq(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b)
            return a !== 0 || 1 / a === 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null)
            return a === b;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b))
            return false;
        switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN
            if (+a !== +a)
                return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        }
        var areArrays = className === '[object Array]';
        if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object')
                return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(types_1.isFunction(aCtor) && aCtor instanceof aCtor && types_1.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a)
                return bStack[length] === b;
        }
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
        // Recursively compare objects and arrays.
        if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length)
                return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack))
                    return false;
            }
        } else {
            // Deep compare objects.
            var keys = Object.keys(a);
            var key = void 0;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (Object.keys(b).length !== length)
                return false;
            while (length--) {
                // Deep compare each member
                key = keys[length];
                if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack)))
                    return false;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
    }
    // Perform a deep comparison to check if two objects are equal.
    function isEqual(a, b) {
        return eq(a, b);
    }
    exports.isEqual = isEqual;    
},
/*core/util/math*/
function _(require, module, exports) {
    function angle_norm(angle) {
        while (angle < 0) {
            angle += 2 * Math.PI;
        }
        while (angle > 2 * Math.PI) {
            angle -= 2 * Math.PI;
        }
        return angle;
    }
    exports.angle_norm = angle_norm;
    function angle_dist(lhs, rhs) {
        return Math.abs(angle_norm(lhs - rhs));
    }
    exports.angle_dist = angle_dist;
    function angle_between(mid, lhs, rhs, direction) {
        var norm_mid = angle_norm(mid);
        var d = angle_dist(lhs, rhs);
        var cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;
        if (direction == 'anticlock')
            return cond;
        else
            return !cond;
    }
    exports.angle_between = angle_between;
    function random() {
        return Math.random();
    }
    exports.random = random;
    function randomIn(min, max) {
        if (max == null) {
            max = min;
            min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
    }
    exports.randomIn = randomIn;
    function atan2(start, end) {
        /*
     * Calculate the angle between a line containing start and end points (composed
     * of [x, y] arrays) and the positive x-axis.
     */
        return Math.atan2(end[1] - start[1], end[0] - start[0]);
    }
    exports.atan2 = atan2;
    // http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)
    function rnorm(mu, sigma) {
        // Generate a random normal with a mean of 0 and a sigma of 1
        var r1;
        var r2;
        while (true) {
            r1 = random();
            r2 = random();
            r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));
            if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2)
                break;
        }
        var rn = r2 / r1;
        // Transform the standard normal to meet the characteristics that we want (mu, sigma)
        rn = mu + sigma * rn;
        return rn;
    }
    exports.rnorm = rnorm;
    function clamp(val, min, max) {
        if (val > max)
            return max;
        if (val < min)
            return min;
        return val;
    }
    exports.clamp = clamp;    
},
/*core/util/object*/
function _(require, module, exports) {
    var array_1 = require(22    /* ./array */);
    exports.keys = Object.keys;
    function values(object) {
        var keys = Object.keys(object);
        var length = keys.length;
        var values = new Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = object[keys[i]];
        }
        return values;
    }
    exports.values = values;
    function extend(dest) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
            var source = sources_1[_a];
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    dest[key] = source[key];
                }
            }
        }
        return dest;
    }
    exports.extend = extend;
    function clone(obj) {
        return extend({}, obj);
    }
    exports.clone = clone;
    function merge(obj1, obj2) {
        /*
     * Returns an object with the array values for obj1 and obj2 unioned by key.
     */
        var result = Object.create(Object.prototype);
        var keys = array_1.concat([
            Object.keys(obj1),
            Object.keys(obj2)
        ]);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            var arr1 = obj1.hasOwnProperty(key) ? obj1[key] : [];
            var arr2 = obj2.hasOwnProperty(key) ? obj2[key] : [];
            result[key] = array_1.union(arr1, arr2);
        }
        return result;
    }
    exports.merge = merge;
    function size(obj) {
        return Object.keys(obj).length;
    }
    exports.size = size;
    function isEmpty(obj) {
        return size(obj) === 0;
    }
    exports.isEmpty = isEmpty;    
},
/*core/util/proj4*/
function _(require, module, exports) {
    var latlon_bounds;
    var proj4 = require(345    /* proj4/lib/core */);
    exports.proj4 = proj4;
    var Proj = require(333    /* proj4/lib/Proj */);
    var toPoint = require(339    /* proj4/lib/common/toPoint */);
    var defs = require(349    /* proj4/lib/defs */);
    var transform = require(358    /* proj4/lib/transform */);
    proj4.defaultDatum = 'WGS84';
    // default datum
    proj4.WGS84 = new Proj('WGS84');
    proj4.Proj = Proj;
    proj4.toPoint = toPoint;
    proj4.defs = defs;
    proj4.transform = transform;
    exports.mercator = defs('GOOGLE');
    exports.wgs84 = defs('WGS84');
    exports.mercator_bounds = {
        lon: [
            -20026376.39,
            20026376.39
        ],
        lat: [
            -20048966.1,
            20048966.1
        ]
    };
    latlon_bounds = {
        lon: [
            -180,
            180
        ],
        lat: [
            -85.06,
            85.06
        ]
    };
    exports.clip_mercator = function (low, high, dimension) {
        var max, min;
        _a = exports.mercator_bounds[dimension], min = _a[0], max = _a[1];
        return [
            Math.max(low, min),
            Math.min(high, max)
        ];
        var _a;
    };
    exports.in_bounds = function (value, dimension) {
        return value > latlon_bounds[dimension][0] && value < latlon_bounds[dimension][1];
    };    
},
/*core/util/projections*/
function _(require, module, exports) {
    var proj4_1 = require(31    /* ./proj4 */);
    function project_xy(x, y) {
        var n = Math.min(x.length, y.length);
        var merc_x_s = new Array(n);
        var merc_y_s = new Array(n);
        for (var i = 0; i < n; i++) {
            var _a = proj4_1.proj4(proj4_1.mercator, [
                    x[i],
                    y[i]
                ]), merc_x = _a[0], merc_y = _a[1];
            merc_x_s[i] = merc_x;
            merc_y_s[i] = merc_y;
        }
        return [
            merc_x_s,
            merc_y_s
        ];
    }
    exports.project_xy = project_xy;
    function project_xsys(xs, ys) {
        var n = Math.min(xs.length, ys.length);
        var merc_xs_s = new Array(n);
        var merc_ys_s = new Array(n);
        for (var i = 0; i < n; i++) {
            var _a = project_xy(xs[i], ys[i]), merc_x_s = _a[0], merc_y_s = _a[1];
            merc_xs_s[i] = merc_x_s;
            merc_ys_s[i] = merc_y_s;
        }
        return [
            merc_xs_s,
            merc_ys_s
        ];
    }
    exports.project_xsys = project_xsys;    
},
/*core/util/refs*/
function _(require, module, exports) {
    var types_1 = require(42    /* ./types */);
    // Create a Bokeh reference from a HasProps subclass
    //
    // @param obj [HasProps] the object to create a reference for
    // @return [Object] a Bokeh reference for `obj`
    // @throw Error if `obj` is not a HasProps
    //
    function create_ref(obj) {
        var ref = {
            type: obj.type,
            id: obj.id
        };
        if (obj._subtype != null) {
            ref.subtype = obj._subtype;
        }
        return ref;
    }
    exports.create_ref = create_ref;
    // Determine whether an object has the proper format of a Bokeh reference
    //
    // @param arg [Object] the object to test
    // @return [bool] whether the object is a refererence
    //
    // @note this function does not check that the id and types are valid,
    //   only that the format is correct (all required keys are present)
    //
    function is_ref(arg) {
        if (types_1.isObject(arg)) {
            var keys = Object.keys(arg).sort();
            if (keys.length == 2)
                return keys[0] == 'id' && keys[1] == 'type';
            if (keys.length == 3)
                return keys[0] == 'id' && keys[1] == 'subtype' && keys[2] == 'type';
        }
        return false;
    }
    exports.is_ref = is_ref;    
},
/*core/util/selection*/
function _(require, module, exports) {
    function get_indices(data_source) {
        var selected = data_source.selected;
        if (selected['0d'].glyph)
            return selected['0d'].indices;
        else if (selected['1d'].indices.length > 0)
            return selected['1d'].indices;
        else if (selected['2d'].indices.length > 0)
            return selected['2d'].indices;
        else
            return [];
    }
    exports.get_indices = get_indices;    
},
/*core/util/serialization*/
function _(require, module, exports) {
    var _order, buf, buf16, buf8, k, v;
    var types_1 = require(42    /* ./types */);
    exports.ARRAY_TYPES = {
        float32: Float32Array,
        float64: Float64Array,
        uint8: Uint8Array,
        int8: Int8Array,
        uint16: Uint16Array,
        int16: Int16Array,
        uint32: Uint32Array,
        int32: Int32Array
    };
    exports.DTYPES = {};
    for (k in exports.ARRAY_TYPES) {
        v = exports.ARRAY_TYPES[k];
        exports.DTYPES[v.name] = k;
    }
    // record endian-ness
    buf = new ArrayBuffer(2);
    buf8 = new Uint8Array(buf);
    buf16 = new Uint16Array(buf);
    buf8[0] = 170;
    buf8[1] = 187;
    if (buf16[0] === 48042) {
        _order = 'little';
    } else {
        _order = 'big';
    }
    exports.BYTE_ORDER = _order;
    exports.swap16 = function (a) {
        var i, j, ref, t, x;
        x = new Uint8Array(a.buffer, a.byteOffset, a.length * 2);
        for (i = j = 0, ref = x.length; j < ref; i = j += 2) {
            t = x[i];
            x[i] = x[i + 1];
            x[i + 1] = t;
        }
        return null;
    };
    exports.swap32 = function (a) {
        var i, j, ref, t, x;
        x = new Uint8Array(a.buffer, a.byteOffset, a.length * 4);
        for (i = j = 0, ref = x.length; j < ref; i = j += 4) {
            t = x[i];
            x[i] = x[i + 3];
            x[i + 3] = t;
            t = x[i + 1];
            x[i + 1] = x[i + 2];
            x[i + 2] = t;
        }
        return null;
    };
    exports.swap64 = function (a) {
        var i, j, ref, t, x;
        x = new Uint8Array(a.buffer, a.byteOffset, a.length * 8);
        for (i = j = 0, ref = x.length; j < ref; i = j += 8) {
            t = x[i];
            x[i] = x[i + 7];
            x[i + 7] = t;
            t = x[i + 1];
            x[i + 1] = x[i + 6];
            x[i + 6] = t;
            t = x[i + 2];
            x[i + 2] = x[i + 5];
            x[i + 5] = t;
            t = x[i + 3];
            x[i + 3] = x[i + 4];
            x[i + 4] = t;
        }
        return null;
    };
    exports.process_buffer = function (spec, buffers) {
        var arr, bytes, header, j, len1, need_swap, shape;
        need_swap = spec.order !== exports.BYTE_ORDER;
        shape = spec.shape;
        bytes = null;
        for (j = 0, len1 = buffers.length; j < len1; j++) {
            buf = buffers[j];
            header = JSON.parse(buf[0]);
            if (header.id === spec.__buffer__) {
                bytes = buf[1];
                break;
            }
        }
        arr = new exports.ARRAY_TYPES[spec.dtype](bytes);
        if (need_swap) {
            if (arr.BYTES_PER_ELEMENT === 2) {
                exports.swap16(arr);
            } else if (arr.BYTES_PER_ELEMENT === 4) {
                exports.swap32(arr);
            } else if (arr.BYTES_PER_ELEMENT === 8) {
                exports.swap64(arr);
            }
        }
        return [
            arr,
            shape
        ];
    };
    exports.process_array = function (obj, buffers) {
        if (types_1.isObject(obj) && '__ndarray__' in obj) {
            return exports.decode_base64(obj);
        } else if (types_1.isObject(obj) && '__buffer__' in obj) {
            return exports.process_buffer(obj, buffers);
        } else if (types_1.isArray(obj)) {
            return [
                obj,
                []
            ];
        }
    };
    exports.arrayBufferToBase64 = function (buffer) {
        var b, binary, bytes;
        bytes = new Uint8Array(buffer);
        binary = function () {
            var j, len1, results;
            results = [];
            for (j = 0, len1 = bytes.length; j < len1; j++) {
                b = bytes[j];
                results.push(String.fromCharCode(b));
            }
            return results;
        }();
        return btoa(binary.join(''));
    };
    exports.base64ToArrayBuffer = function (base64) {
        var binary_string, bytes, i, j, len, ref;
        binary_string = atob(base64);
        len = binary_string.length;
        bytes = new Uint8Array(len);
        for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes.buffer;
    };
    exports.decode_base64 = function (input) {
        var array, bytes, dtype, shape;
        bytes = exports.base64ToArrayBuffer(input['__ndarray__']);
        dtype = input['dtype'];
        if (dtype in exports.ARRAY_TYPES) {
            array = new exports.ARRAY_TYPES[dtype](bytes);
        }
        shape = input['shape'];
        return [
            array,
            shape
        ];
    };
    exports.encode_base64 = function (array, shape) {
        var b64, data, dtype;
        b64 = exports.arrayBufferToBase64(array.buffer);
        dtype = exports.DTYPES[array.constructor.name];
        data = {
            __ndarray__: b64,
            shape: shape,
            dtype: dtype
        };
        return data;
    };
    exports.decode_column_data = function (data, buffers) {
        var arr, arrays, j, len1, new_data, new_shapes, obj, shape, shapes;
        new_data = {};
        new_shapes = {};
        for (k in data) {
            v = data[k];
            // might be array of scalars, or might be ragged array or arrays
            if (types_1.isArray(v)) {
                // v is just a regular array of scalars
                if (v.length === 0 || !(types_1.isObject(v[0]) || types_1.isArray(v[0]))) {
                    new_data[k] = v;
                    continue;
                }
                // v is a ragged array of arrays
                arrays = [];
                shapes = [];
                for (j = 0, len1 = v.length; j < len1; j++) {
                    obj = v[j];
                    _a = exports.process_array(obj, buffers), arr = _a[0], shape = _a[1];
                    arrays.push(arr);
                    shapes.push(shape);
                }
                new_data[k] = arrays;
                new_shapes[k] = shapes;
            } else {
                // must be object or array (single array case)
                _b = exports.process_array(v, buffers), arr = _b[0], shape = _b[1];
                new_data[k] = arr;
                new_shapes[k] = shape;
            }
        }
        return [
            new_data,
            new_shapes
        ];
        var _a, _b;
    };
    exports.encode_column_data = function (data, shapes) {
        var i, j, new_array, new_data, ref, ref1, ref2;
        new_data = {};
        for (k in data) {
            v = data[k];
            if ((v != null ? v.buffer : void 0) instanceof ArrayBuffer) {
                v = exports.encode_base64(v, shapes != null ? shapes[k] : void 0);
            } else if (types_1.isArray(v)) {
                new_array = [];
                for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    if (((ref1 = v[i]) != null ? ref1.buffer : void 0) instanceof ArrayBuffer) {
                        new_array.push(exports.encode_base64(v[i], shapes != null ? (ref2 = shapes[k]) != null ? ref2[i] : void 0 : void 0));
                    } else {
                        new_array.push(v[i]);
                    }
                }
                v = new_array;
            }
            new_data[k] = v;
        }
        return new_data;
    };    
},
/*core/util/spatial*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    /// <reference types="@types/rbush" />
    var rbush = require(361    /* rbush */);
    var SpatialIndex = function () {
        function SpatialIndex() {
        }
        return SpatialIndex;
    }();
    exports.SpatialIndex = SpatialIndex;
    var RBush = function (_super) {
        tslib_1.__extends(RBush, _super);
        function RBush(points) {
            var _this = _super.call(this) || this;
            _this.index = rbush();
            _this.index.load(points);
            return _this;
        }
        Object.defineProperty(RBush.prototype, 'bbox', {
            get: function () {
                var _a = this.index.toJSON(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
                return {
                    minX: minX,
                    minY: minY,
                    maxX: maxX,
                    maxY: maxY
                };
            },
            enumerable: true,
            configurable: true
        });
        RBush.prototype.search = function (rect) {
            return this.index.search(rect);
        };
        RBush.prototype.indices = function (rect) {
            var points = this.search(rect);
            var n = points.length;
            var indices = new Array(n);
            for (var j = 0; j < n; j++) {
                indices[j] = points[j].i;
            }
            return indices;
        };
        return RBush;
    }(SpatialIndex);
    exports.RBush = RBush;    
},
/*core/util/string*/
function _(require, module, exports) {
    var settings_1 = require(19    /* ../settings */);
    function startsWith(str, searchString, position) {
        if (position === void 0) {
            position = 0;
        }
        return str.substr(position, searchString.length) == searchString;
    }
    exports.startsWith = startsWith;
    function uuid4() {
        // from ipython project
        // http://www.ietf.org/rfc/rfc4122.txt
        var s = new Array(32);
        var hexDigits = '0123456789ABCDEF';
        for (var i = 0; i < 32; i++) {
            s[i] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
        }
        s[12] = '4';
        // bits 12-15 of the time_hi_and_version field to 0010
        s[16] = hexDigits.substr(s[16].charCodeAt(0) & 3 | 8, 1);
        // bits 6-7 of the clock_seq_hi_and_reserved to 01
        return s.join('');
    }
    exports.uuid4 = uuid4;
    var counter = 1000;
    function uniqueId(prefix) {
        var id = settings_1.settings.dev ? 'j' + counter++ : uuid4();
        if (prefix != null)
            return prefix + '-' + id;
        else
            return id;
    }
    exports.uniqueId = uniqueId;
    function escape(s) {
        return s.replace(/(?:[&<>"'`])/g, function (ch) {
            switch (ch) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '"':
                return '&quot;';
            case '\'':
                return '&#x27;';
            case '`':
                return '&#x60;';
            default:
                return ch;
            }
        });
    }
    exports.escape = escape;
    function unescape(s) {
        return s.replace(/&(amp|lt|gt|quot|#x27|#x60);/g, function (_, entity) {
            switch (entity) {
            case 'amp':
                return '&';
            case 'lt':
                return '<';
            case 'gt':
                return '>';
            case 'quot':
                return '"';
            case '#x27':
                return '\'';
            case '#x60':
                return '`';
            default:
                return entity;
            }
        });
    }
    exports.unescape = unescape;    
},
/*core/util/svg_colors*/
function _(require, module, exports) {
    exports.indianred = '#CD5C5C';
    exports.lightcoral = '#F08080';
    exports.salmon = '#FA8072';
    exports.darksalmon = '#E9967A';
    exports.lightsalmon = '#FFA07A';
    exports.crimson = '#DC143C';
    exports.red = '#FF0000';
    exports.firebrick = '#B22222';
    exports.darkred = '#8B0000';
    exports.pink = '#FFC0CB';
    exports.lightpink = '#FFB6C1';
    exports.hotpink = '#FF69B4';
    exports.deeppink = '#FF1493';
    exports.mediumvioletred = '#C71585';
    exports.palevioletred = '#DB7093';
    exports.coral = '#FF7F50';
    exports.tomato = '#FF6347';
    exports.orangered = '#FF4500';
    exports.darkorange = '#FF8C00';
    exports.orange = '#FFA500';
    exports.gold = '#FFD700';
    exports.yellow = '#FFFF00';
    exports.lightyellow = '#FFFFE0';
    exports.lemonchiffon = '#FFFACD';
    exports.lightgoldenrodyellow = '#FAFAD2';
    exports.papayawhip = '#FFEFD5';
    exports.moccasin = '#FFE4B5';
    exports.peachpuff = '#FFDAB9';
    exports.palegoldenrod = '#EEE8AA';
    exports.khaki = '#F0E68C';
    exports.darkkhaki = '#BDB76B';
    exports.lavender = '#E6E6FA';
    exports.thistle = '#D8BFD8';
    exports.plum = '#DDA0DD';
    exports.violet = '#EE82EE';
    exports.orchid = '#DA70D6';
    exports.fuchsia = '#FF00FF';
    exports.magenta = '#FF00FF';
    exports.mediumorchid = '#BA55D3';
    exports.mediumpurple = '#9370DB';
    exports.blueviolet = '#8A2BE2';
    exports.darkviolet = '#9400D3';
    exports.darkorchid = '#9932CC';
    exports.darkmagenta = '#8B008B';
    exports.purple = '#800080';
    exports.indigo = '#4B0082';
    exports.slateblue = '#6A5ACD';
    exports.darkslateblue = '#483D8B';
    exports.mediumslateblue = '#7B68EE';
    exports.greenyellow = '#ADFF2F';
    exports.chartreuse = '#7FFF00';
    exports.lawngreen = '#7CFC00';
    exports.lime = '#00FF00';
    exports.limegreen = '#32CD32';
    exports.palegreen = '#98FB98';
    exports.lightgreen = '#90EE90';
    exports.mediumspringgreen = '#00FA9A';
    exports.springgreen = '#00FF7F';
    exports.mediumseagreen = '#3CB371';
    exports.seagreen = '#2E8B57';
    exports.forestgreen = '#228B22';
    exports.green = '#008000';
    exports.darkgreen = '#006400';
    exports.yellowgreen = '#9ACD32';
    exports.olivedrab = '#6B8E23';
    exports.olive = '#808000';
    exports.darkolivegreen = '#556B2F';
    exports.mediumaquamarine = '#66CDAA';
    exports.darkseagreen = '#8FBC8F';
    exports.lightseagreen = '#20B2AA';
    exports.darkcyan = '#008B8B';
    exports.teal = '#008080';
    exports.aqua = '#00FFFF';
    exports.cyan = '#00FFFF';
    exports.lightcyan = '#E0FFFF';
    exports.paleturquoise = '#AFEEEE';
    exports.aquamarine = '#7FFFD4';
    exports.turquoise = '#40E0D0';
    exports.mediumturquoise = '#48D1CC';
    exports.darkturquoise = '#00CED1';
    exports.cadetblue = '#5F9EA0';
    exports.steelblue = '#4682B4';
    exports.lightsteelblue = '#B0C4DE';
    exports.powderblue = '#B0E0E6';
    exports.lightblue = '#ADD8E6';
    exports.skyblue = '#87CEEB';
    exports.lightskyblue = '#87CEFA';
    exports.deepskyblue = '#00BFFF';
    exports.dodgerblue = '#1E90FF';
    exports.cornflowerblue = '#6495ED';
    exports.royalblue = '#4169E1';
    exports.blue = '#0000FF';
    exports.mediumblue = '#0000CD';
    exports.darkblue = '#00008B';
    exports.navy = '#000080';
    exports.midnightblue = '#191970';
    exports.cornsilk = '#FFF8DC';
    exports.blanchedalmond = '#FFEBCD';
    exports.bisque = '#FFE4C4';
    exports.navajowhite = '#FFDEAD';
    exports.wheat = '#F5DEB3';
    exports.burlywood = '#DEB887';
    exports.tan = '#D2B48C';
    exports.rosybrown = '#BC8F8F';
    exports.sandybrown = '#F4A460';
    exports.goldenrod = '#DAA520';
    exports.darkgoldenrod = '#B8860B';
    exports.peru = '#CD853F';
    exports.chocolate = '#D2691E';
    exports.saddlebrown = '#8B4513';
    exports.sienna = '#A0522D';
    exports.brown = '#A52A2A';
    exports.maroon = '#800000';
    exports.white = '#FFFFFF';
    exports.snow = '#FFFAFA';
    exports.honeydew = '#F0FFF0';
    exports.mintcream = '#F5FFFA';
    exports.azure = '#F0FFFF';
    exports.aliceblue = '#F0F8FF';
    exports.ghostwhite = '#F8F8FF';
    exports.whitesmoke = '#F5F5F5';
    exports.seashell = '#FFF5EE';
    exports.beige = '#F5F5DC';
    exports.oldlace = '#FDF5E6';
    exports.floralwhite = '#FFFAF0';
    exports.ivory = '#FFFFF0';
    exports.antiquewhite = '#FAEBD7';
    exports.linen = '#FAF0E6';
    exports.lavenderblush = '#FFF0F5';
    exports.mistyrose = '#FFE4E1';
    exports.gainsboro = '#DCDCDC';
    exports.lightgray = '#D3D3D3';
    exports.lightgrey = '#D3D3D3';
    exports.silver = '#C0C0C0';
    exports.darkgray = '#A9A9A9';
    exports.darkgrey = '#A9A9A9';
    exports.gray = '#808080';
    exports.grey = '#808080';
    exports.dimgray = '#696969';
    exports.dimgrey = '#696969';
    exports.lightslategray = '#778899';
    exports.lightslategrey = '#778899';
    exports.slategray = '#708090';
    exports.slategrey = '#708090';
    exports.darkslategray = '#2F4F4F';
    exports.darkslategrey = '#2F4F4F';
    exports.black = '#000000';    
},
/*core/util/templating*/
function _(require, module, exports) {
    var _format_number;
    var sprintf_js_1 = require(362    /* sprintf-js */);
    var Numbro = require(332    /* numbro */);
    var tz = require(363    /* timezone */);
    var string_1 = require(37    /* ./string */);
    var types_1 = require(42    /* ./types */);
    _format_number = function (number) {
        var format;
        if (types_1.isNumber(number)) {
            format = function () {
                switch (false) {
                case Math.floor(number) !== number:
                    return '%d';
                case !(Math.abs(number) > 0.1 && Math.abs(number) < 1000):
                    return '%0.3f';
                default:
                    return '%0.3e';
                }
            }();
            return sprintf_js_1.sprintf(format, number);
        } else {
            return '' + number    // get strings for categorical types
;
        }
    };
    exports.replace_placeholders = function (string, data_source, i, formatters, special_vars) {
        if (special_vars === void 0) {
            special_vars = {};
        }
        string = string.replace(/(^|[^\$])\$(\w+)/g, function (match, prefix, name) {
            return prefix + '@$' + name;
        });
        string = string.replace(/(^|[^@])@(?:(\$?\w+)|{([^{}]+)})(?:{([^{}]+)})?/g, function (match, prefix, name, long_name, format) {
            var ref, replacement, value;
            name = long_name != null ? long_name : name;
            value = name[0] === '$' ? special_vars[name.substring(1)] : (ref = data_source.get_column(name)) != null ? ref[i] : void 0;
            replacement = null;
            if (value == null) {
                replacement = '???';
            } else {
                // 'safe' format, just return the value as is
                if (format === 'safe') {
                    return '' + prefix + value;
                } else if (format != null) {
                    // see if the field has an entry in the formatters dict
                    if (formatters != null && name in formatters) {
                        if (formatters[name] === 'numeral') {
                            replacement = Numbro.format(value, format);
                        } else if (formatters[name] === 'datetime') {
                            replacement = tz(value, format);
                        } else if (formatters[name] === 'printf') {
                            replacement = sprintf_js_1.sprintf(format, value);
                        } else {
                            throw new Error('Unknown tooltip field formatter type \'' + formatters[name] + '\'');
                        }
                    } else {
                        // if not assume the format string is Numbro
                        replacement = Numbro.format(value, format);
                    }
                } else {
                    // no format supplied, just use a basic default numeric format
                    replacement = _format_number(value);
                }
            }
            return replacement = '' + prefix + string_1.escape(replacement);
        });
        return string;
    };    
},
/*core/util/text*/
function _(require, module, exports) {
    var dom_1 = require(5    /* ../dom */);
    var cache = {};
    function get_text_height(font) {
        if (cache[font] != null)
            return cache[font];
        var text = dom_1.span({ style: { font: font } }, 'Hg');
        var block = dom_1.div({
            style: {
                display: 'inline-block',
                width: '1px',
                height: '0px'
            }
        });
        var elem = dom_1.div({}, text, block);
        document.body.appendChild(elem);
        try {
            block.style.verticalAlign = 'baseline';
            var ascent = dom_1.offset(block).top - dom_1.offset(text).top;
            block.style.verticalAlign = 'bottom';
            var height = dom_1.offset(block).top - dom_1.offset(text).top;
            var result = {
                height: height,
                ascent: ascent,
                descent: height - ascent
            };
            cache[font] = result;
            return result;
        } finally {
            document.body.removeChild(elem);
        }
    }
    exports.get_text_height = get_text_height;    
},
/*core/util/throttle*/
function _(require, module, exports) {
    var _delay_animation, delay_animation;
    _delay_animation = function (f) {
        return f();
    };
    delay_animation = (typeof window !== 'undefined' && window !== null ? window.requestAnimationFrame : void 0) || (typeof window !== 'undefined' && window !== null ? window.mozRequestAnimationFrame : void 0) || (typeof window !== 'undefined' && window !== null ? window.webkitRequestAnimationFrame : void 0) || (typeof window !== 'undefined' && window !== null ? window.msRequestAnimationFrame : void 0) || _delay_animation;
    // Returns a function, that, when invoked, will only be triggered at
    // most once during a given window of time.
    // In addition, if the browser supports requestAnimationFrame, the
    // throttled function will be run no more frequently than request
    // animation frame allows.
    // @param func [function] the function to throttle
    // @param wait [number] time in milliseconds to use for window
    // @return [function] throttled function
    exports.throttle = function (func, wait) {
        var args, context, later, pending, previous, result, timeout;
        _a = [
            null,
            null,
            null,
            null
        ], context = _a[0], args = _a[1], timeout = _a[2], result = _a[3];
        previous = 0;
        pending = false;
        later = function () {
            previous = new Date();
            timeout = null;
            pending = false;
            return result = func.apply(context, args);
        };
        return function () {
            var now, remaining;
            now = new Date();
            remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 && !pending) {
                clearTimeout(timeout);
                pending = true;
                delay_animation(later);
            } else if (!timeout && !pending) {
                timeout = setTimeout(function () {
                    return delay_animation(later);
                }, remaining);
            }
            return result;
        };
        var _a;
    };    
},
/*core/util/types*/
function _(require, module, exports) {
    var toString = Object.prototype.toString;
    function isBoolean(obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    }
    exports.isBoolean = isBoolean;
    function isNumber(obj) {
        return toString.call(obj) === '[object Number]';
    }
    exports.isNumber = isNumber;
    function isInteger(obj) {
        return isNumber(obj) && isFinite(obj) && Math.floor(obj) === obj;
    }
    exports.isInteger = isInteger;
    function isString(obj) {
        return toString.call(obj) === '[object String]';
    }
    exports.isString = isString;
    function isStrictNaN(obj) {
        return isNumber(obj) && obj !== +obj;
    }
    exports.isStrictNaN = isStrictNaN;
    function isFunction(obj) {
        return toString.call(obj) === '[object Function]';
    }
    exports.isFunction = isFunction;
    function isArray(obj) {
        return Array.isArray(obj);
    }
    exports.isArray = isArray;
    function isObject(obj) {
        var tp = typeof obj;
        return tp === 'function' || tp === 'object' && !!obj;
    }
    exports.isObject = isObject;    
},
/*core/util/wheel*/
function _(require, module, exports) {
    function fontSize(element) {
        var value = getComputedStyle(element).fontSize;
        if (value != null)
            return parseInt(value, 10);
        return null;
    }
    function lineHeight(element) {
        var parent = element.offsetParent || document.body;
        return fontSize(parent) || fontSize(element) || 16;
    }
    function pageHeight(element) {
        return element.clientHeight;    // XXX: should be content height?
    }
    function getDeltaY(event) {
        var deltaY = -event.deltaY;
        if (event.target instanceof HTMLElement) {
            switch (event.deltaMode) {
            case event.DOM_DELTA_LINE:
                deltaY *= lineHeight(event.target);
                break;
            case event.DOM_DELTA_PAGE:
                deltaY *= pageHeight(event.target);
                break;
            }
        }
        return deltaY;
    }
    exports.getDeltaY = getDeltaY;    
},
/*core/util/zoom*/
function _(require, module, exports) {
    var math_1 = require(29    /* ./math */);
    // Module for zoom-related functions
    function scale_highlow(range, factor, center) {
        var _a = [
                range.start,
                range.end
            ], low = _a[0], high = _a[1];
        var x = center != null ? center : (high + low) / 2;
        var x0 = low - (low - x) * factor;
        var x1 = high - (high - x) * factor;
        return [
            x0,
            x1
        ];
    }
    exports.scale_highlow = scale_highlow;
    function get_info(scales, _a) {
        var sxy0 = _a[0], sxy1 = _a[1];
        var info = {};
        for (var name_1 in scales) {
            var scale = scales[name_1];
            var _b = scale.r_invert(sxy0, sxy1), start = _b[0], end = _b[1];
            info[name_1] = {
                start: start,
                end: end
            };
        }
        return info;
    }
    exports.get_info = get_info;
    function scale_range(frame, factor, h_axis, v_axis, center) {
        /*
     * Utility function for zoom tools to calculate/create the zoom_info object
     * of the form required by ``PlotCanvasView.update_range``
     *
     * Parameters:
     *   frame : CartesianFrame
     *   factor : Number
     *   h_axis : Boolean, optional
     *     whether to zoom the horizontal axis (default = true)
     *   v_axis : Boolean, optional
     *     whether to zoom the horizontal axis (default = true)
     *   center : object, optional
     *     of form {'x': Number, 'y', Number}
     *
     * Returns:
     *   object:
     */
        if (h_axis === void 0) {
            h_axis = true;
        }
        if (v_axis === void 0) {
            v_axis = true;
        }
        // clamp the  magnitude of factor, if it is > 1 bad things happen
        factor = math_1.clamp(factor, -0.9, 0.9);
        var hfactor = h_axis ? factor : 0;
        var _a = scale_highlow(frame.bbox.h_range, hfactor, center != null ? center.x : undefined), sx0 = _a[0], sx1 = _a[1];
        var xrs = get_info(frame.xscales, [
            sx0,
            sx1
        ]);
        var vfactor = v_axis ? factor : 0;
        var _b = scale_highlow(frame.bbox.v_range, vfactor, center != null ? center.y : undefined), sy0 = _b[0], sy1 = _b[1];
        var yrs = get_info(frame.yscales, [
            sy0,
            sy1
        ]);
        // OK this sucks we can't set factor independently in each direction. It is used
        // for GMap plots, and GMap plots always preserve aspect, so effective the value
        // of 'dimensions' is ignored.
        return {
            xrs: xrs,
            yrs: yrs,
            factor: factor
        };
    }
    exports.scale_range = scale_range;    
},
/*core/view*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var signaling_1 = require(20    /* ./signaling */);
    var string_1 = require(37    /* ./util/string */);
    var View = function (_super) {
        tslib_1.__extends(View, _super);
        function View(options) {
            var _this = _super.call(this) || this;
            _this.removed = new signaling_1.Signal(_this, 'removed');
            if (options.model != null)
                _this.model = options.model;
            else
                throw new Error('model of a view wasn\'t configured');
            _this._parent = options.parent;
            _this.id = options.id || string_1.uniqueId();
            _this.initialize(options);
            if (options.connect_signals !== false)
                _this.connect_signals();
            return _this;
        }
        View.getters = function (specs) {
            for (var name_1 in specs) {
                var fn = specs[name_1];
                Object.defineProperty(this.prototype, name_1, { get: fn });
            }
        };
        View.prototype.initialize = function (_options) {
        };
        View.prototype.remove = function () {
            this._parent = undefined;
            this.disconnect_signals();
            this.removed.emit(undefined);
        };
        View.prototype.toString = function () {
            return this.model.type + 'View(' + this.id + ')';
        };
        Object.defineProperty(View.prototype, 'parent', {
            get: function () {
                if (this._parent !== undefined)
                    return this._parent;
                else
                    throw new Error('parent of a view wasn\'t configured');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View.prototype, 'is_root', {
            get: function () {
                return this.parent === null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View.prototype, 'root', {
            get: function () {
                return this.is_root ? this : this.parent.root;
            },
            enumerable: true,
            configurable: true
        });
        View.prototype.connect_signals = function () {
        };
        View.prototype.disconnect_signals = function () {
            signaling_1.Signal.disconnectReceiver(this);
        };
        View.prototype.notify_finished = function () {
            this.root.notify_finished();
        };
        return View;
    }(signaling_1.Signalable());
    exports.View = View;    
},
/*core/visuals*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var ContextProperties, hasProp = {}.hasOwnProperty;
    var mixins = require(16    /* ./property_mixins */);
    var color_1 = require(26    /* ./util/color */);
    ContextProperties = function () {
        function ContextProperties(obj, prefix) {
            if (prefix === void 0) {
                prefix = '';
            }
            var attr, do_spec, j, len, ref;
            this.obj = obj;
            this.prefix = prefix;
            this.cache = {};
            do_spec = obj.properties[prefix + this.do_attr].spec;
            this.doit = do_spec.value !== null;
            ref = this.attrs;
            for (j = 0, len = ref.length; j < len; j++) {
                attr = ref[j];
                this[attr] = obj.properties[prefix + attr];
            }
        }
        ContextProperties.prototype.warm_cache = function (source) {
            var attr, j, len, prop, ref, results;
            ref = this.attrs;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                attr = ref[j];
                prop = this.obj.properties[this.prefix + attr];
                if (prop.spec.value !== void 0) {
                    results.push(this.cache[attr] = prop.spec.value);
                } else {
                    results.push(this.cache[attr + '_array'] = prop.array(source));
                }
            }
            return results;
        };
        ContextProperties.prototype.cache_select = function (attr, i) {
            var prop;
            prop = this.obj.properties[this.prefix + attr];
            if (prop.spec.value !== void 0) {
                return this.cache[attr] = prop.spec.value;
            } else {
                return this.cache[attr] = this.cache[attr + '_array'][i];
            }
        };
        ContextProperties.prototype.set_vectorize = function (ctx, i) {
            if (this.all_indices != null) {
                return this._set_vectorize(ctx, this.all_indices[i]);
            } else {
                return this._set_vectorize(ctx, i);    //all_indices is set by a Visuals instance associated with a CDSView
            }
        };
        return ContextProperties;
    }();
    var Line = function (_super) {
        tslib_1.__extends(Line, _super);
        function Line() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Line.prototype.set_value = function (ctx) {
            ctx.strokeStyle = this.line_color.value();
            ctx.globalAlpha = this.line_alpha.value();
            ctx.lineWidth = this.line_width.value();
            ctx.lineJoin = this.line_join.value();
            ctx.lineCap = this.line_cap.value();
            ctx.setLineDash(this.line_dash.value());
            return ctx.setLineDashOffset(this.line_dash_offset.value());
        };
        Line.prototype._set_vectorize = function (ctx, i) {
            this.cache_select('line_color', i);
            if (ctx.strokeStyle !== this.cache.line_color) {
                ctx.strokeStyle = this.cache.line_color;
            }
            this.cache_select('line_alpha', i);
            if (ctx.globalAlpha !== this.cache.line_alpha) {
                ctx.globalAlpha = this.cache.line_alpha;
            }
            this.cache_select('line_width', i);
            if (ctx.lineWidth !== this.cache.line_width) {
                ctx.lineWidth = this.cache.line_width;
            }
            this.cache_select('line_join', i);
            if (ctx.lineJoin !== this.cache.line_join) {
                ctx.lineJoin = this.cache.line_join;
            }
            this.cache_select('line_cap', i);
            if (ctx.lineCap !== this.cache.line_cap) {
                ctx.lineCap = this.cache.line_cap;
            }
            this.cache_select('line_dash', i);
            if (ctx.getLineDash() !== this.cache.line_dash) {
                ctx.setLineDash(this.cache.line_dash);
            }
            this.cache_select('line_dash_offset', i);
            if (ctx.getLineDashOffset() !== this.cache.line_dash_offset) {
                return ctx.setLineDashOffset(this.cache.line_dash_offset);
            }
        };
        Line.prototype.color_value = function () {
            var color;
            color = color_1.color2rgba(this.line_color.value(), this.line_alpha.value());
            return 'rgba(' + color[0] * 255 + ',' + color[1] * 255 + ',' + color[2] * 255 + ',' + color[3] + ')';
        };
        return Line;
    }(ContextProperties);
    exports.Line = Line;
    ;
    Line.prototype.attrs = Object.keys(mixins.line());
    Line.prototype.do_attr = 'line_color';
    var Fill = function (_super) {
        tslib_1.__extends(Fill, _super);
        function Fill() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Fill.prototype.set_value = function (ctx) {
            ctx.fillStyle = this.fill_color.value();
            return ctx.globalAlpha = this.fill_alpha.value();
        };
        Fill.prototype._set_vectorize = function (ctx, i) {
            this.cache_select('fill_color', i);
            if (ctx.fillStyle !== this.cache.fill_color) {
                ctx.fillStyle = this.cache.fill_color;
            }
            this.cache_select('fill_alpha', i);
            if (ctx.globalAlpha !== this.cache.fill_alpha) {
                return ctx.globalAlpha = this.cache.fill_alpha;
            }
        };
        Fill.prototype.color_value = function () {
            var color;
            color = color_1.color2rgba(this.fill_color.value(), this.fill_alpha.value());
            return 'rgba(' + color[0] * 255 + ',' + color[1] * 255 + ',' + color[2] * 255 + ',' + color[3] + ')';
        };
        return Fill;
    }(ContextProperties);
    exports.Fill = Fill;
    ;
    Fill.prototype.attrs = Object.keys(mixins.fill());
    Fill.prototype.do_attr = 'fill_color';
    var Text = function (_super) {
        tslib_1.__extends(Text, _super);
        function Text() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Text.prototype.cache_select = function (name, i) {
            var val;
            if (name === 'font') {
                val = _super.prototype.cache_select.call(this, 'text_font_style', i) + ' ' + _super.prototype.cache_select.call(this, 'text_font_size', i) + ' ' + _super.prototype.cache_select.call(this, 'text_font', i);
                return this.cache.font = val;
            } else {
                return _super.prototype.cache_select.call(this, name, i);
            }
        };
        Text.prototype.font_value = function () {
            var font, font_size, font_style;
            font = this.text_font.value();
            font_size = this.text_font_size.value();
            font_style = this.text_font_style.value();
            return font_style + ' ' + font_size + ' ' + font;
        };
        Text.prototype.color_value = function () {
            var color;
            color = color_1.color2rgba(this.text_color.value(), this.text_alpha.value());
            return 'rgba(' + color[0] * 255 + ',' + color[1] * 255 + ',' + color[2] * 255 + ',' + color[3] + ')';
        };
        Text.prototype.set_value = function (ctx) {
            ctx.font = this.font_value();
            ctx.fillStyle = this.text_color.value();
            ctx.globalAlpha = this.text_alpha.value();
            ctx.textAlign = this.text_align.value();
            return ctx.textBaseline = this.text_baseline.value();
        };
        Text.prototype._set_vectorize = function (ctx, i) {
            this.cache_select('font', i);
            if (ctx.font !== this.cache.font) {
                ctx.font = this.cache.font;
            }
            this.cache_select('text_color', i);
            if (ctx.fillStyle !== this.cache.text_color) {
                ctx.fillStyle = this.cache.text_color;
            }
            this.cache_select('text_alpha', i);
            if (ctx.globalAlpha !== this.cache.text_alpha) {
                ctx.globalAlpha = this.cache.text_alpha;
            }
            this.cache_select('text_align', i);
            if (ctx.textAlign !== this.cache.text_align) {
                ctx.textAlign = this.cache.text_align;
            }
            this.cache_select('text_baseline', i);
            if (ctx.textBaseline !== this.cache.text_baseline) {
                return ctx.textBaseline = this.cache.text_baseline;
            }
        };
        return Text;
    }(ContextProperties);
    exports.Text = Text;
    ;
    Text.prototype.attrs = Object.keys(mixins.text());
    Text.prototype.do_attr = 'text_color';
    exports.Visuals = function () {
        function Visuals(model) {
            var cls, j, len, name, prefix, ref, spec;
            ref = model.mixins;
            for (j = 0, len = ref.length; j < len; j++) {
                spec = ref[j];
                _a = spec.split(':'), name = _a[0], _b = _a[1], prefix = _b === void 0 ? '' : _b;
                cls = function () {
                    switch (name) {
                    case 'line':
                        return Line;
                    case 'fill':
                        return Fill;
                    case 'text':
                        return Text;
                    }
                }();
                this[prefix + name] = new cls(model, prefix);
            }
            var _a, _b;
        }
        Visuals.prototype.warm_cache = function (source) {
            var name, prop, ref, results;
            ref = this;
            results = [];
            for (name in ref) {
                if (!hasProp.call(ref, name))
                    continue;
                prop = ref[name];
                if (prop instanceof ContextProperties) {
                    results.push(prop.warm_cache(source));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        Visuals.prototype.set_all_indices = function (all_indices) {
            var name, prop, ref, results;
            ref = this;
            results = [];
            for (name in ref) {
                if (!hasProp.call(ref, name))
                    continue;
                prop = ref[name];
                if (prop instanceof ContextProperties) {
                    results.push(prop.all_indices = all_indices);
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        return Visuals;
    }();    
},
/*document*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var base_1 = require(0    /* ./base */);
    var version_1 = require(248    /* ./version */);
    var logging_1 = require(14    /* ./core/logging */);
    var bokeh_events_1 = require(3    /* core/bokeh_events */);
    var has_props_1 = require(8    /* ./core/has_props */);
    var signaling_1 = require(20    /* ./core/signaling */);
    var refs_1 = require(33    /* ./core/util/refs */);
    var serialization_1 = require(35    /* ./core/util/serialization */);
    var data_structures_1 = require(27    /* ./core/util/data_structures */);
    var array_1 = require(22    /* ./core/util/array */);
    var object_1 = require(30    /* ./core/util/object */);
    var eq_1 = require(28    /* ./core/util/eq */);
    var types_1 = require(42    /* ./core/util/types */);
    var layout_dom_1 = require(139    /* ./models/layouts/layout_dom */);
    var column_data_source_1 = require(173    /* ./models/sources/column_data_source */);
    var model_1 = require(50    /* ./model */);
    var EventManager = function () {
        function EventManager(document) {
            this.document = document;
            /* Document */
            // Dispatches events to the subscribed models
            this.session = null;
            this.subscribed_models = new data_structures_1.Set();
        }
        EventManager.prototype.send_event = function (event) {
            // Send message to Python via session
            if (this.session != null)
                this.session.send_event(event);
        };
        EventManager.prototype.trigger = function (event) {
            for (var _i = 0, _a = this.subscribed_models.values; _i < _a.length; _i++) {
                var model_id = _a[_i];
                if (event.model_id != null && event.model_id !== model_id)
                    continue;
                var model = this.document._all_models[model_id];
                if (model != null)
                    model._process_event(event);
            }
        };
        return EventManager;
    }();
    exports.EventManager = EventManager;
    var DocumentChangedEvent = function () {
        function DocumentChangedEvent(document) {
            this.document = document;
        }
        return DocumentChangedEvent;
    }();
    exports.DocumentChangedEvent = DocumentChangedEvent;
    var ModelChangedEvent = function (_super) {
        tslib_1.__extends(ModelChangedEvent, _super);
        function ModelChangedEvent(document, model, attr, old, new_, setter_id) {
            var _this = _super.call(this, document) || this;
            _this.model = model;
            _this.attr = attr;
            _this.old = old;
            _this.new_ = new_;
            _this.setter_id = setter_id;
            return _this;
        }
        ModelChangedEvent.prototype.json = function (references) {
            if (this.attr === 'id') {
                throw new Error('\'id\' field should never change, whatever code just set it is wrong');
            }
            var value = this.new_;
            var value_json = has_props_1.HasProps._value_to_json(this.attr, value, this.model);
            var value_refs = {};
            has_props_1.HasProps._value_record_references(value, value_refs, true);
            // true = recurse
            if (this.model.id in value_refs && this.model !== value) {
                // we know we don't want a whole new copy of the obj we're
                // patching unless it's also the value itself
                delete value_refs[this.model.id];
            }
            for (var id in value_refs) {
                references[id] = value_refs[id];
            }
            return {
                kind: 'ModelChanged',
                model: this.model.ref(),
                attr: this.attr,
                new: value_json
            };
        };
        return ModelChangedEvent;
    }(DocumentChangedEvent);
    exports.ModelChangedEvent = ModelChangedEvent;
    var TitleChangedEvent = function (_super) {
        tslib_1.__extends(TitleChangedEvent, _super);
        function TitleChangedEvent(document, title, setter_id) {
            var _this = _super.call(this, document) || this;
            _this.title = title;
            _this.setter_id = setter_id;
            return _this;
        }
        TitleChangedEvent.prototype.json = function (_references) {
            return {
                kind: 'TitleChanged',
                title: this.title
            };
        };
        return TitleChangedEvent;
    }(DocumentChangedEvent);
    exports.TitleChangedEvent = TitleChangedEvent;
    var RootAddedEvent = function (_super) {
        tslib_1.__extends(RootAddedEvent, _super);
        function RootAddedEvent(document, model, setter_id) {
            var _this = _super.call(this, document) || this;
            _this.model = model;
            _this.setter_id = setter_id;
            return _this;
        }
        RootAddedEvent.prototype.json = function (references) {
            has_props_1.HasProps._value_record_references(this.model, references, true);
            return {
                kind: 'RootAdded',
                model: this.model.ref()
            };
        };
        return RootAddedEvent;
    }(DocumentChangedEvent);
    exports.RootAddedEvent = RootAddedEvent;
    var RootRemovedEvent = function (_super) {
        tslib_1.__extends(RootRemovedEvent, _super);
        function RootRemovedEvent(document, model, setter_id) {
            var _this = _super.call(this, document) || this;
            _this.model = model;
            _this.setter_id = setter_id;
            return _this;
        }
        RootRemovedEvent.prototype.json = function (_references) {
            return {
                kind: 'RootRemoved',
                model: this.model.ref()
            };
        };
        return RootRemovedEvent;
    }(DocumentChangedEvent);
    exports.RootRemovedEvent = RootRemovedEvent;
    exports.documents = [];
    exports.DEFAULT_TITLE = 'Bokeh Application';
    // This class should match the API of the Python Document class
    // as much as possible.
    var Document = function () {
        function Document() {
            exports.documents.push(this);
            this._init_timestamp = Date.now();
            this._title = exports.DEFAULT_TITLE;
            this._roots = [];
            this._all_models = {};
            this._all_models_by_name = new data_structures_1.MultiDict();
            this._all_models_freeze_count = 0;
            this._callbacks = [];
            this.event_manager = new EventManager(this);
            this.idle = new signaling_1.Signal(this, 'idle');
            this._idle_roots = new WeakMap();
            // TODO: WeakSet would be better
            this._interactive_timestamp = null;
            this._interactive_plot = null;
        }
        Object.defineProperty(Document.prototype, 'layoutables', {
            get: function () {
                return this._roots.filter(function (root) {
                    return root instanceof layout_dom_1.LayoutDOM;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Document.prototype, 'is_idle', {
            get: function () {
                for (var _i = 0, _a = this.layoutables; _i < _a.length; _i++) {
                    var root = _a[_i];
                    if (!this._idle_roots.has(root))
                        return false;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Document.prototype.notify_idle = function (model) {
            this._idle_roots.set(model, true);
            if (this.is_idle) {
                logging_1.logger.info('document idle at ' + (Date.now() - this._init_timestamp) + ' ms');
                this.idle.emit(undefined);
            }
        };
        Document.prototype.clear = function () {
            this._push_all_models_freeze();
            try {
                while (this._roots.length > 0) {
                    this.remove_root(this._roots[0]);
                }
            } finally {
                this._pop_all_models_freeze();
            }
        };
        Document.prototype.interactive_start = function (plot) {
            if (this._interactive_plot == null) {
                this._interactive_plot = plot;
                this._interactive_plot.trigger_event(new bokeh_events_1.LODStart({}));
            }
            this._interactive_timestamp = Date.now();
        };
        Document.prototype.interactive_stop = function (plot) {
            if (this._interactive_plot != null && this._interactive_plot.id === plot.id) {
                this._interactive_plot.trigger_event(new bokeh_events_1.LODEnd({}));
            }
            this._interactive_plot = null;
            this._interactive_timestamp = null;
        };
        Document.prototype.interactive_duration = function () {
            if (this._interactive_timestamp == null)
                return -1;
            else
                return Date.now() - this._interactive_timestamp;
        };
        Document.prototype.destructively_move = function (dest_doc) {
            if (dest_doc === this) {
                throw new Error('Attempted to overwrite a document with itself');
            }
            dest_doc.clear();
            // we have to remove ALL roots before adding any
            // to the new doc or else models referenced from multiple
            // roots could be in both docs at once, which isn't allowed.
            var roots = array_1.copy(this._roots);
            this.clear();
            for (var _i = 0, roots_1 = roots; _i < roots_1.length; _i++) {
                var root = roots_1[_i];
                if (root.document != null)
                    throw new Error('Somehow we didn\'t detach ' + root);
            }
            if (Object.keys(this._all_models).length !== 0) {
                throw new Error('this._all_models still had stuff in it: ' + this._all_models);
            }
            for (var _a = 0, roots_2 = roots; _a < roots_2.length; _a++) {
                var root = roots_2[_a];
                dest_doc.add_root(root);
            }
            dest_doc.set_title(this._title);
        };
        // TODO other fields of doc
        Document.prototype._push_all_models_freeze = function () {
            this._all_models_freeze_count += 1;
        };
        Document.prototype._pop_all_models_freeze = function () {
            this._all_models_freeze_count -= 1;
            if (this._all_models_freeze_count === 0) {
                this._recompute_all_models();
            }
        };
        /*protected*/
        Document.prototype._invalidate_all_models = function () {
            logging_1.logger.debug('invalidating document models');
            // if freeze count is > 0, we'll recompute on unfreeze
            if (this._all_models_freeze_count === 0) {
                this._recompute_all_models();
            }
        };
        Document.prototype._recompute_all_models = function () {
            var new_all_models_set = new data_structures_1.Set();
            for (var _i = 0, _a = this._roots; _i < _a.length; _i++) {
                var r = _a[_i];
                new_all_models_set = new_all_models_set.union(r.references());
            }
            var old_all_models_set = new data_structures_1.Set(object_1.values(this._all_models));
            var to_detach = old_all_models_set.diff(new_all_models_set);
            var to_attach = new_all_models_set.diff(old_all_models_set);
            var recomputed = {};
            for (var _b = 0, _c = new_all_models_set.values; _b < _c.length; _b++) {
                var m = _c[_b];
                recomputed[m.id] = m;
            }
            for (var _d = 0, _e = to_detach.values; _d < _e.length; _d++) {
                var d = _e[_d];
                d.detach_document();
                if (d instanceof model_1.Model && d.name != null)
                    this._all_models_by_name.remove_value(d.name, d);
            }
            for (var _f = 0, _g = to_attach.values; _f < _g.length; _f++) {
                var a = _g[_f];
                a.attach_document(this);
                if (a instanceof model_1.Model && a.name != null)
                    this._all_models_by_name.add_value(a.name, a);
            }
            this._all_models = recomputed;
        };
        Document.prototype.roots = function () {
            return this._roots;
        };
        Document.prototype.add_root = function (model, setter_id) {
            logging_1.logger.debug('Adding root: ' + model);
            if (array_1.contains(this._roots, model))
                return;
            this._push_all_models_freeze();
            try {
                this._roots.push(model);
            } finally {
                this._pop_all_models_freeze();
            }
            this._trigger_on_change(new RootAddedEvent(this, model, setter_id));
        };
        Document.prototype.remove_root = function (model, setter_id) {
            var i = this._roots.indexOf(model);
            if (i < 0)
                return;
            this._push_all_models_freeze();
            try {
                this._roots.splice(i, 1);
            } finally {
                this._pop_all_models_freeze();
            }
            this._trigger_on_change(new RootRemovedEvent(this, model, setter_id));
        };
        Document.prototype.title = function () {
            return this._title;
        };
        Document.prototype.set_title = function (title, setter_id) {
            if (title !== this._title) {
                this._title = title;
                this._trigger_on_change(new TitleChangedEvent(this, title, setter_id));
            }
        };
        Document.prototype.get_model_by_id = function (model_id) {
            if (model_id in this._all_models) {
                return this._all_models[model_id];
            } else {
                return null;
            }
        };
        Document.prototype.get_model_by_name = function (name) {
            return this._all_models_by_name.get_one(name, 'Multiple models are named \'' + name + '\'');
        };
        Document.prototype.on_change = function (callback) {
            if (!array_1.contains(this._callbacks, callback))
                this._callbacks.push(callback);
        };
        Document.prototype.remove_on_change = function (callback) {
            var i = this._callbacks.indexOf(callback);
            if (i >= 0)
                this._callbacks.splice(i, 1);
        };
        Document.prototype._trigger_on_change = function (event) {
            for (var _i = 0, _a = this._callbacks; _i < _a.length; _i++) {
                var cb = _a[_i];
                cb(event);
            }
        };
        // called by the model
        Document.prototype._notify_change = function (model, attr, old, new_, options) {
            if (attr === 'name') {
                this._all_models_by_name.remove_value(old, model);
                if (new_ != null)
                    this._all_models_by_name.add_value(new_, model);
            }
            var setter_id = options != null ? options.setter_id : void 0;
            this._trigger_on_change(new ModelChangedEvent(this, model, attr, old, new_, setter_id));
        };
        Document._references_json = function (references, include_defaults) {
            if (include_defaults === void 0) {
                include_defaults = true;
            }
            var references_json = [];
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var r = references_1[_i];
                var ref = r.ref();
                ref.attributes = r.attributes_as_json(include_defaults);
                // server doesn't want id in here since it's already in ref above
                delete ref.attributes.id;
                references_json.push(ref);
            }
            return references_json;
        };
        Document._instantiate_object = function (obj_id, obj_type, obj_attrs) {
            var full_attrs = object_1.extend({}, obj_attrs, { id: obj_id });
            var model = base_1.Models(obj_type);
            return new model(full_attrs, {
                silent: true,
                defer_initialization: true
            });
        };
        // given a JSON representation of all models in a graph, return a
        // dict of new model objects
        Document._instantiate_references_json = function (references_json, existing_models) {
            // Create all instances, but without setting their props
            var references = {};
            for (var _i = 0, references_json_1 = references_json; _i < references_json_1.length; _i++) {
                var obj = references_json_1[_i];
                var obj_id = obj.id;
                var obj_type = obj.type;
                var obj_attrs = obj.attributes || {};
                var instance = void 0;
                if (obj_id in existing_models)
                    instance = existing_models[obj_id];
                else {
                    instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);
                    if (obj.subtype != null)
                        instance.set_subtype(obj.subtype);
                }
                references[instance.id] = instance;
            }
            return references;
        };
        // if v looks like a ref, or a collection, resolve it, otherwise return it unchanged
        // recurse into collections but not into HasProps
        Document._resolve_refs = function (value, old_references, new_references) {
            function resolve_ref(v) {
                if (refs_1.is_ref(v)) {
                    if (v.id in old_references)
                        return old_references[v.id];
                    else if (v.id in new_references)
                        return new_references[v.id];
                    else
                        throw new Error('reference ' + JSON.stringify(v) + ' isn\'t known (not in Document?)');
                } else if (types_1.isArray(v))
                    return resolve_array(v);
                else if (types_1.isObject(v))
                    return resolve_dict(v);
                else
                    return v;
            }
            function resolve_array(array) {
                var results = [];
                for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
                    var v = array_2[_i];
                    results.push(resolve_ref(v));
                }
                return results;
            }
            function resolve_dict(dict) {
                var resolved = {};
                for (var k in dict) {
                    var v = dict[k];
                    resolved[k] = resolve_ref(v);
                }
                return resolved;
            }
            return resolve_ref(value);
        };
        // given a JSON representation of all models in a graph and new
        // model instances, set the properties on the models from the
        // JSON
        Document._initialize_references_json = function (references_json, old_references, new_references) {
            var to_update = {};
            for (var _i = 0, references_json_2 = references_json; _i < references_json_2.length; _i++) {
                var obj = references_json_2[_i];
                var obj_id = obj.id;
                var obj_attrs = obj.attributes;
                var was_new = !(obj_id in old_references);
                var instance = !was_new ? old_references[obj_id] : new_references[obj_id];
                // replace references with actual instances in obj_attrs
                var resolved_attrs = Document._resolve_refs(obj_attrs, old_references, new_references);
                to_update[instance.id] = [
                    instance,
                    resolved_attrs,
                    was_new
                ];
            }
            function foreach_depth_first(items, f) {
                var already_started = {};
                function foreach_value(v) {
                    if (v instanceof has_props_1.HasProps) {
                        // note that we ignore instances that aren't updated (not in to_update)
                        if (!(v.id in already_started) && v.id in items) {
                            already_started[v.id] = true;
                            var _a = items[v.id], attrs = _a[1], was_new = _a[2];
                            for (var a in attrs) {
                                var e = attrs[a];
                                foreach_value(e);
                            }
                            f(v, attrs, was_new);
                        }
                    } else if (types_1.isArray(v)) {
                        for (var _i = 0, v_1 = v; _i < v_1.length; _i++) {
                            var e = v_1[_i];
                            foreach_value(e);
                        }
                    } else if (types_1.isObject(v)) {
                        for (var k in v) {
                            var e = v[k];
                            foreach_value(e);
                        }
                    }
                }
                for (var k in items) {
                    var _a = items[k], instance = _a[0];
                    foreach_value(instance);
                }
            }
            // this first pass removes all 'refs' replacing them with real instances
            foreach_depth_first(to_update, function (instance, attrs, was_new) {
                if (was_new)
                    instance.setv(attrs, { silent: true });
            });
            // after removing all the refs, we can run the initialize code safely
            foreach_depth_first(to_update, function (instance, attrs, was_new) {
                if (was_new)
                    instance.finalize(attrs, {});
            });
        };
        Document._event_for_attribute_change = function (changed_obj, key, new_value, doc, value_refs) {
            var changed_model = doc.get_model_by_id(changed_obj.id);
            // XXX!
            if (!changed_model.attribute_is_serializable(key))
                return null;
            else {
                var event_1 = {
                    kind: 'ModelChanged',
                    model: {
                        id: changed_obj.id,
                        type: changed_obj.type
                    },
                    attr: key,
                    new: new_value
                };
                has_props_1.HasProps._json_record_references(doc, new_value, value_refs, true);
                // true = recurse
                return event_1;
            }
        };
        Document._events_to_sync_objects = function (from_obj, to_obj, to_doc, value_refs) {
            var from_keys = Object.keys(from_obj.attributes);
            //XXX!
            var to_keys = Object.keys(to_obj.attributes);
            //XXX!
            var removed = array_1.difference(from_keys, to_keys);
            var added = array_1.difference(to_keys, from_keys);
            var shared = array_1.intersection(from_keys, to_keys);
            var events = [];
            for (var _i = 0, removed_1 = removed; _i < removed_1.length; _i++) {
                var key = removed_1[_i];
                // we don't really have a "remove" event - not sure this ever
                // happens even. One way this could happen is if the server
                // does include_defaults=True and we do
                // include_defaults=false ... in that case it'd be best to
                // just ignore this probably. Warn about it, could mean
                // there's a bug if we don't have a key that the server sent.
                logging_1.logger.warn('Server sent key ' + key + ' but we don\'t seem to have it in our JSON');
            }
            for (var _a = 0, added_1 = added; _a < added_1.length; _a++) {
                var key = added_1[_a];
                var new_value = to_obj.attributes[key];
                // XXX!
                events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));
            }
            for (var _b = 0, shared_1 = shared; _b < shared_1.length; _b++) {
                var key = shared_1[_b];
                var old_value = from_obj.attributes[key];
                // XXX!
                var new_value = to_obj.attributes[key];
                // XXX!
                if (old_value == null && new_value == null) {
                } else if (old_value == null || new_value == null) {
                    events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));
                } else {
                    if (!eq_1.isEqual(old_value, new_value))
                        events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));
                }
            }
            return events.filter(function (e) {
                return e != null;
            });
        };
        // we use this to detect changes during document deserialization
        // (in model constructors and initializers)
        Document._compute_patch_since_json = function (from_json, to_doc) {
            var to_json = to_doc.to_json(false);
            // include_defaults=false
            function refs(json) {
                var result = {};
                for (var _i = 0, _a = json.roots.references; _i < _a.length; _i++) {
                    var obj = _a[_i];
                    result[obj.id] = obj;
                }
                return result;
            }
            var from_references = refs(from_json);
            var from_roots = {};
            var from_root_ids = [];
            for (var _i = 0, _a = from_json.roots.root_ids; _i < _a.length; _i++) {
                var r = _a[_i];
                from_roots[r] = from_references[r];
                from_root_ids.push(r);
            }
            var to_references = refs(to_json);
            var to_roots = {};
            var to_root_ids = [];
            for (var _b = 0, _c = to_json.roots.root_ids; _b < _c.length; _b++) {
                var r = _c[_b];
                to_roots[r] = to_references[r];
                to_root_ids.push(r);
            }
            from_root_ids.sort();
            to_root_ids.sort();
            if (array_1.difference(from_root_ids, to_root_ids).length > 0 || array_1.difference(to_root_ids, from_root_ids).length > 0) {
                // this would arise if someone does add_root/remove_root during
                // document deserialization, hopefully they won't ever do so.
                throw new Error('Not implemented: computing add/remove of document roots');
            }
            var value_refs = {};
            var events = [];
            for (var id in to_doc._all_models) {
                if (id in from_references) {
                    var update_model_events = Document._events_to_sync_objects(from_references[id], to_references[id], to_doc, value_refs);
                    events = events.concat(update_model_events);
                }
            }
            return {
                references: Document._references_json(object_1.values(value_refs), false),
                events: events
            };
        };
        Document.prototype.to_json_string = function (include_defaults) {
            if (include_defaults === void 0) {
                include_defaults = true;
            }
            return JSON.stringify(this.to_json(include_defaults));
        };
        Document.prototype.to_json = function (include_defaults) {
            if (include_defaults === void 0) {
                include_defaults = true;
            }
            var root_ids = this._roots.map(function (r) {
                return r.id;
            });
            var root_references = object_1.values(this._all_models);
            return {
                title: this._title,
                roots: {
                    root_ids: root_ids,
                    references: Document._references_json(root_references, include_defaults)
                }
            };
        };
        Document.from_json_string = function (s) {
            var json = JSON.parse(s);
            return Document.from_json(json);
        };
        Document.from_json = function (json) {
            logging_1.logger.debug('Creating Document from JSON');
            var py_version = json.version;
            // XXX!
            var is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;
            var versions_string = 'Library versions: JS (' + version_1.version + ') / Python (' + py_version + ')';
            if (!is_dev && version_1.version !== py_version) {
                logging_1.logger.warn('JS/Python version mismatch');
                logging_1.logger.warn(versions_string);
            } else
                logging_1.logger.debug(versions_string);
            var roots_json = json.roots;
            var root_ids = roots_json.root_ids;
            var references_json = roots_json.references;
            var references = Document._instantiate_references_json(references_json, {});
            Document._initialize_references_json(references_json, {}, references);
            var doc = new Document();
            for (var _i = 0, root_ids_1 = root_ids; _i < root_ids_1.length; _i++) {
                var r = root_ids_1[_i];
                doc.add_root(references[r]);
            }
            // XXX: HasProps
            doc.set_title(json.title);
            // XXX!
            return doc;
        };
        Document.prototype.replace_with_json = function (json) {
            var replacement = Document.from_json(json);
            replacement.destructively_move(this);
        };
        Document.prototype.create_json_patch_string = function (events) {
            return JSON.stringify(this.create_json_patch(events));
        };
        Document.prototype.create_json_patch = function (events) {
            var references = {};
            var json_events = [];
            for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
                var event_2 = events_1[_i];
                if (event_2.document !== this) {
                    logging_1.logger.warn('Cannot create a patch using events from a different document, event had ', event_2.document, ' we are ', this);
                    throw new Error('Cannot create a patch using events from a different document');
                }
                json_events.push(event_2.json(references));
            }
            return {
                events: json_events,
                references: Document._references_json(object_1.values(references))
            };
        };
        Document.prototype.apply_json_patch = function (patch, buffers, setter_id) {
            var references_json = patch.references;
            var events_json = patch.events;
            var references = Document._instantiate_references_json(references_json, this._all_models);
            // The model being changed isn't always in references so add it in
            for (var _i = 0, events_json_1 = events_json; _i < events_json_1.length; _i++) {
                var event_json = events_json_1[_i];
                switch (event_json.kind) {
                case 'RootAdded':
                case 'RootRemoved':
                case 'ModelChanged': {
                        var model_id = event_json.model.id;
                        if (model_id in this._all_models) {
                            references[model_id] = this._all_models[model_id];
                        } else {
                            if (!(model_id in references)) {
                                logging_1.logger.warn('Got an event for unknown model ', event_json.model);
                                throw new Error('event model wasn\'t known');
                            }
                        }
                        break;
                    }
                }
            }
            // split references into old and new so we know whether to initialize or update
            var old_references = {};
            var new_references = {};
            for (var id in references) {
                var value = references[id];
                if (id in this._all_models)
                    old_references[id] = value;
                else
                    new_references[id] = value;
            }
            Document._initialize_references_json(references_json, old_references, new_references);
            for (var _a = 0, events_json_2 = events_json; _a < events_json_2.length; _a++) {
                var event_json = events_json_2[_a];
                switch (event_json.kind) {
                case 'ModelChanged': {
                        var patched_id = event_json.model.id;
                        if (!(patched_id in this._all_models)) {
                            throw new Error('Cannot apply patch to ' + patched_id + ' which is not in the document');
                        }
                        var patched_obj = this._all_models[patched_id];
                        var attr = event_json.attr;
                        var model_type = event_json.model.type;
                        // XXXX currently still need this first branch, some updates (initial?) go through here
                        if (attr === 'data' && model_type === 'ColumnDataSource') {
                            var _b = serialization_1.decode_column_data(event_json.new, buffers), data = _b[0], shapes = _b[1];
                            patched_obj.setv({
                                _shapes: shapes,
                                data: data
                            }, { setter_id: setter_id });
                        } else {
                            var value = Document._resolve_refs(event_json.new, old_references, new_references);
                            patched_obj.setv([
                                attr,
                                value
                            ], { setter_id: setter_id });
                        }
                        break;
                    }
                case 'ColumnDataChanged': {
                        var column_source_id = event_json.column_source.id;
                        if (!(column_source_id in this._all_models)) {
                            throw new Error('Cannot stream to ' + column_source_id + ' which is not in the document');
                        }
                        var column_source = this._all_models[column_source_id];
                        var _c = serialization_1.decode_column_data(event_json.new, buffers), data = _c[0], shapes = _c[1];
                        if (event_json.cols != null) {
                            for (var k in column_source.data) {
                                if (!(k in data)) {
                                    data[k] = column_source.data[k];
                                }
                            }
                            for (var k in column_source._shapes) {
                                if (!(k in shapes)) {
                                    shapes[k] = column_source._shapes[k];
                                }
                            }
                        }
                        column_source.setv({
                            _shapes: shapes,
                            data: data
                        }, {
                            setter_id: setter_id,
                            check_eq: false
                        });
                        break;
                    }
                case 'ColumnsStreamed': {
                        var column_source_id = event_json.column_source.id;
                        if (!(column_source_id in this._all_models)) {
                            throw new Error('Cannot stream to ' + column_source_id + ' which is not in the document');
                        }
                        var column_source = this._all_models[column_source_id];
                        if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {
                            throw new Error('Cannot stream to non-ColumnDataSource');
                        }
                        var data = event_json.data;
                        var rollover = event_json.rollover;
                        column_source.stream(data, rollover);
                        break;
                    }
                case 'ColumnsPatched': {
                        var column_source_id = event_json.column_source.id;
                        if (!(column_source_id in this._all_models)) {
                            throw new Error('Cannot patch ' + column_source_id + ' which is not in the document');
                        }
                        var column_source = this._all_models[column_source_id];
                        if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {
                            throw new Error('Cannot patch non-ColumnDataSource');
                        }
                        var patches = event_json.patches;
                        column_source.patch(patches);
                        break;
                    }
                case 'RootAdded': {
                        var root_id = event_json.model.id;
                        var root_obj = references[root_id];
                        this.add_root(root_obj, setter_id);
                        // XXX: HasProps
                        break;
                    }
                case 'RootRemoved': {
                        var root_id = event_json.model.id;
                        var root_obj = references[root_id];
                        this.remove_root(root_obj, setter_id);
                        // XXX: HasProps
                        break;
                    }
                case 'TitleChanged': {
                        this.set_title(event_json.title, setter_id);
                        break;
                    }
                default:
                    throw new Error('Unknown patch event ' + JSON.stringify(event_json));
                }
            }
        };
        return Document;
    }();
    exports.Document = Document;    
},
/*embed*/
function _(require, module, exports) {
    var _create_view, _embed_items, _get_element, _get_session, _get_ws_url, _handle_notebook_comms, _init_comms, _sessions, _update_comms_callback, add_document_from_session, add_model_from_session, fill_render_item_from_script_tag;
    var base = require(0    /* ./base */);
    var connection_1 = require(1    /* ./client/connection */);
    var logging_1 = require(14    /* ./core/logging */);
    var document_1 = require(47    /* ./document */);
    var dom_1 = require(5    /* ./core/dom */);
    var callback_1 = require(24    /* ./core/util/callback */);
    var string_1 = require(37    /* ./core/util/string */);
    var object_1 = require(30    /* ./core/util/object */);
    var types_1 = require(42    /* ./core/util/types */);
    var receiver_1 = require(246    /* ./protocol/receiver */);
    // Matches Bokeh CSS class selector. Setting all Bokeh parent element class names
    // with this var prevents user configurations where css styling is unset.
    exports.BOKEH_ROOT = 'bk-root';
    _handle_notebook_comms = function (receiver, msg) {
        if (msg.buffers.length > 0) {
            receiver.consume(msg.buffers[0].buffer);
        } else {
            receiver.consume(msg.content.data);
        }
        msg = receiver.message;
        if (msg != null) {
            return this.apply_json_patch(msg.content, msg.buffers);
        }
    };
    _update_comms_callback = function (target, doc, comm) {
        var r;
        if (target === comm.target_name) {
            r = new receiver_1.Receiver();
            return comm.on_msg(_handle_notebook_comms.bind(doc, r));
        }
    };
    _init_comms = function (target, doc) {
        var comm_manager, e, id, promise, ref, update_comms;
        if (typeof Jupyter !== 'undefined' && Jupyter !== null && Jupyter.notebook.kernel != null) {
            logging_1.logger.info('Registering Jupyter comms for target ' + target);
            comm_manager = Jupyter.notebook.kernel.comm_manager;
            update_comms = function (comm) {
                return _update_comms_callback(target, doc, comm);
            };
            ref = comm_manager.comms;
            for (id in ref) {
                promise = ref[id];
                promise.then(update_comms);
            }
            try {
                return comm_manager.register_target(target, function (comm, msg) {
                    var r;
                    logging_1.logger.info('Registering Jupyter comms for target ' + target);
                    r = new receiver_1.Receiver();
                    return comm.on_msg(_handle_notebook_comms.bind(doc, r));
                });
            } catch (error1) {
                e = error1;
                return logging_1.logger.warn('Jupyter comms failed to register. push_notebook() will not function. (exception reported: ' + e + ')');
            }
        } else {
            return console.warn('Jupyter notebooks comms not available. push_notebook() will not function');
        }
    };
    _create_view = function (model) {
        var view;
        view = new model.default_view({
            model: model,
            parent: null
        });
        base.index[model.id] = view;
        return view;
    };
    _get_element = function (item) {
        var child, container, elem, element_id;
        element_id = item['elementid'];
        elem = document.getElementById(element_id);
        if (elem == null) {
            throw new Error('Error rendering Bokeh model: could not find tag with id: ' + element_id);
        }
        if (!document.body.contains(elem)) {
            throw new Error('Error rendering Bokeh model: element with id \'' + element_id + '\' must be under <body>');
        }
        // if autoload script, replace script tag with div for embedding
        if (elem.tagName === 'SCRIPT') {
            fill_render_item_from_script_tag(elem, item);
            container = dom_1.div({ class: exports.BOKEH_ROOT });
            dom_1.replaceWith(elem, container);
            child = dom_1.div();
            container.appendChild(child);
            elem = child;
        }
        return elem;
    };
    // Replace element with a view of model_id from document
    exports.add_model_standalone = function (model_id, element, doc) {
        var model, view;
        model = doc.get_model_by_id(model_id);
        if (model == null) {
            throw new Error('Model ' + model_id + ' was not in document ' + doc);
        }
        view = _create_view(model);
        return view.renderTo(element, true);
    };
    // Fill element with the roots from doc
    exports.add_document_standalone = function (document, element, use_for_title) {
        if (use_for_title === void 0) {
            use_for_title = false;
        }
        var i, len, model, ref, render_model, unrender_model, views;
        // this is a LOCAL index of views used only by this particular rendering
        // call, so we can remove the views we create.
        views = {};
        render_model = function (model) {
            var view;
            view = _create_view(model);
            view.renderTo(element);
            return views[model.id] = view;
        };
        unrender_model = function (model) {
            var view;
            if (model.id in views) {
                view = views[model.id];
                element.removeChild(view.el);
                delete views[model.id];
                return delete base.index[model.id];
            }
        };
        ref = document.roots();
        for (i = 0, len = ref.length; i < len; i++) {
            model = ref[i];
            render_model(model);
        }
        if (use_for_title) {
            window.document.title = document.title();
        }
        document.on_change(function (event) {
            if (event instanceof document_1.RootAddedEvent) {
                return render_model(event.model);
            } else if (event instanceof document_1.RootRemovedEvent) {
                return unrender_model(event.model);
            } else if (use_for_title && event instanceof document_1.TitleChangedEvent) {
                return window.document.title = event.title;
            }
        });
        return views;
    };
    // map { websocket url to map { session id to promise of ClientSession } }
    _sessions = {};
    _get_session = function (websocket_url, session_id, args_string) {
        var subsessions;
        if (websocket_url == null) {
            throw new Error('Missing websocket_url');
        }
        if (!(websocket_url in _sessions)) {
            _sessions[websocket_url] = {};
        }
        subsessions = _sessions[websocket_url];
        if (!(session_id in subsessions)) {
            subsessions[session_id] = connection_1.pull_session(websocket_url, session_id, args_string);
        }
        return subsessions[session_id];
    };
    // Fill element with the roots from session_id
    add_document_from_session = function (element, websocket_url, session_id, use_for_title) {
        var args_string, promise;
        args_string = window.location.search.substr(1);
        promise = _get_session(websocket_url, session_id, args_string);
        return promise.then(function (session) {
            return exports.add_document_standalone(session.document, element, use_for_title);
        }, function (error) {
            logging_1.logger.error('Failed to load Bokeh session ' + session_id + ': ' + error);
            throw error;
        });
    };
    // Replace element with a view of model_id from the given session
    add_model_from_session = function (element, websocket_url, model_id, session_id) {
        var args_string, promise;
        args_string = window.location.search.substr(1);
        promise = _get_session(websocket_url, session_id, args_string);
        return promise.then(function (session) {
            var model, view;
            model = session.document.get_model_by_id(model_id);
            if (model == null) {
                throw new Error('Did not find model ' + model_id + ' in session');
            }
            view = _create_view(model);
            return view.renderTo(element, true);
        }, function (error) {
            logging_1.logger.error('Failed to load Bokeh session ' + session_id + ': ' + error);
            throw error;
        });
    };
    exports.inject_css = function (url) {
        var element;
        element = dom_1.link({
            href: url,
            rel: 'stylesheet',
            type: 'text/css'
        });
        return document.body.appendChild(element);
    };
    exports.inject_raw_css = function (css) {
        var element;
        element = dom_1.style({}, css);
        return document.body.appendChild(element);
    };
    // pull missing render item fields from data- attributes
    fill_render_item_from_script_tag = function (script, item) {
        var info;
        info = script.dataset;
        // length checks are because we put all the attributes on the tag
        // but sometimes set them to empty string
        if (info.bokehLogLevel != null && info.bokehLogLevel.length > 0) {
            logging_1.set_log_level(info.bokehLogLevel);
        }
        if (info.bokehDocId != null && info.bokehDocId.length > 0) {
            item['docid'] = info.bokehDocId;
        }
        if (info.bokehModelId != null && info.bokehModelId.length > 0) {
            item['modelid'] = info.bokehModelId;
        }
        if (info.bokehSessionId != null && info.bokehSessionId.length > 0) {
            item['sessionid'] = info.bokehSessionId;
        }
        return logging_1.logger.info('Will inject Bokeh script tag with params ' + JSON.stringify(item));
    };
    exports.embed_items_notebook = function (docs_json, render_items) {
        var doc, elem, i, item, len, results;
        if (object_1.size(docs_json) !== 1) {
            throw new Error('embed_items_notebook expects exactly one document in docs_json');
        }
        doc = document_1.Document.from_json(object_1.values(docs_json)[0]);
        results = [];
        for (i = 0, len = render_items.length; i < len; i++) {
            item = render_items[i];
            if (item.notebook_comms_target != null) {
                _init_comms(item.notebook_comms_target, doc);
            }
            elem = _get_element(item);
            if (item.modelid != null) {
                results.push(exports.add_model_standalone(item.modelid, elem, doc));
            } else {
                results.push(exports.add_document_standalone(doc, elem, false));
            }
        }
        return results;
    };
    _get_ws_url = function (app_path, absolute_url) {
        var loc, protocol;
        protocol = 'ws:';
        if (window.location.protocol === 'https:') {
            protocol = 'wss:';
        }
        if (absolute_url != null) {
            loc = document.createElement('a');
            loc.href = absolute_url;
        } else {
            loc = window.location;
        }
        if (app_path != null) {
            if (app_path === '/') {
                app_path = '';
            }
        } else {
            app_path = loc.pathname.replace(/\/+$/, '');
        }
        return protocol + '//' + loc.host + app_path + '/ws';
    };
    // TODO (bev) this is currently clunky. Standalone embeds only provide
    // the first two args, whereas server provide the app_app, and *may* prove and
    // absolute_url as well if non-relative links are needed for resources. This function
    // should probably be split in to two pieces to reflect the different usage patterns
    exports.embed_items = function (docs_json, render_items, app_path, absolute_url) {
        return callback_1.defer(function () {
            return _embed_items(docs_json, render_items, app_path, absolute_url);
        });
    };
    _embed_items = function (docs_json, render_items, app_path, absolute_url) {
        var docid, docs, elem, i, item, len, promise, results, use_for_title, websocket_url;
        if (types_1.isString(docs_json)) {
            docs_json = JSON.parse(string_1.unescape(docs_json));
        }
        docs = {};
        for (docid in docs_json) {
            docs[docid] = document_1.Document.from_json(docs_json[docid]);
        }
        results = [];
        for (i = 0, len = render_items.length; i < len; i++) {
            item = render_items[i];
            elem = _get_element(item);
            use_for_title = item.use_for_title != null && item.use_for_title;
            // handle server session cases
            if (item.sessionid != null) {
                websocket_url = _get_ws_url(app_path, absolute_url);
                logging_1.logger.debug('embed: computed ws url: ' + websocket_url);
                if (item.modelid != null) {
                    promise = add_model_from_session(elem, websocket_url, item.modelid, item.sessionid);
                } else {
                    promise = add_document_from_session(elem, websocket_url, item.sessionid, use_for_title);
                }
                results.push(promise.then(function (value) {
                    return console.log('Bokeh items were rendered successfully');
                }, function (error) {
                    return console.log('Error rendering Bokeh items ', error);
                }));    // handle standalone document cases
            } else if (item.docid != null) {
                if (item.modelid != null) {
                    results.push(exports.add_model_standalone(item.modelid, elem, docs[item.docid]));
                } else {
                    results.push(exports.add_document_standalone(docs[item.docid], elem, use_for_title));
                }
            } else {
                throw new Error('Error rendering Bokeh items to element ' + item.elementid + ': no document ID or session ID specified');
            }
        }
        return results;
    };    
},
/*main*/
function _(require, module, exports) {
    require(244    /* ./polyfill */);
    var version_1 = require(248    /* ./version */);
    exports.version = version_1.version;
    var embed = require(48    /* ./embed */);
    exports.embed = embed;
    var logging_1 = require(14    /* ./core/logging */);
    exports.logger = logging_1.logger;
    exports.set_log_level = logging_1.set_log_level;
    var settings_1 = require(19    /* ./core/settings */);
    exports.settings = settings_1.settings;
    var base_1 = require(0    /* ./base */);
    exports.Models = base_1.Models;
    exports.index = base_1.index;
    var document_1 = require(47    /* ./document */);
    exports.documents = document_1.documents;
    var safely_1 = require(247    /* ./safely */);
    exports.safely = safely_1.safely;    
},
/*model*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var has_props_1 = require(8    /* ./core/has_props */);
    var p = require(15    /* ./core/properties */);
    var types_1 = require(42    /* ./core/util/types */);
    var object_1 = require(30    /* ./core/util/object */);
    var logging_1 = require(14    /* ./core/logging */);
    var Model = function (_super) {
        tslib_1.__extends(Model, _super);
        function Model() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Model.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            for (var base_evt in this.js_property_callbacks) {
                var callbacks = this.js_property_callbacks[base_evt];
                var _a = base_evt.split(':'), evt = _a[0], _b = _a[1], attr = _b === void 0 ? null : _b;
                var _loop_1 = function (cb) {
                    var signal = attr != null ? this_1.properties[attr][evt] : this_1[evt];
                    this_1.connect(signal, function () {
                        return cb.execute(_this, {});
                    });
                };
                var this_1 = this;
                for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                    var cb = callbacks_1[_i];
                    _loop_1(cb);
                }
            }
            this.connect(this.properties.js_event_callbacks.change, function () {
                return _this._update_event_callbacks;
            });
            this.connect(this.properties.subscribed_events.change, function () {
                return _this._update_event_callbacks;
            });
        };
        /*protected*/
        Model.prototype._process_event = function (event) {
            if (event.is_applicable_to(this)) {
                event = event._customize_event(this);
                for (var _i = 0, _a = this.js_event_callbacks[event.event_name] || []; _i < _a.length; _i++) {
                    var callback = _a[_i];
                    callback.execute(event, {});
                }
                if (this.document != null) {
                    if (this.subscribed_events.some(function (m) {
                            return m == event.event_name;
                        }))
                        this.document.event_manager.send_event(event);
                }
            }
        };
        Model.prototype.trigger_event = function (event) {
            if (this.document != null)
                this.document.event_manager.trigger(event.set_model_id(this.id));
        };
        Model.prototype._update_event_callbacks = function () {
            if (this.document == null) {
                // File an issue: SidePanel in particular seems to have this issue
                logging_1.logger.warn('WARNING: Document not defined for updating event callbacks');
                return;
            }
            this.document.event_manager.subscribed_models.push(this.id);
        };
        Model.prototype._doc_attached = function () {
            if (!object_1.isEmpty(this.js_event_callbacks) || !object_1.isEmpty(this.subscribed_events))
                this._update_event_callbacks();
        };
        Model.prototype.select = function (selector) {
            if (types_1.isString(selector))
                return this.references().filter(function (ref) {
                    return ref instanceof Model && ref.name === selector;
                });
            else if (selector.prototype instanceof has_props_1.HasProps)
                return this.references().filter(function (ref) {
                    return ref instanceof selector;
                });
            else
                throw new Error('invalid selector');
        };
        Model.prototype.select_one = function (selector) {
            var result = this.select(selector);
            switch (result.length) {
            case 0:
                return null;
            case 1:
                return result[0];
            default:
                throw new Error('found more than one object matching given selector');
            }
        };
        return Model;
    }(has_props_1.HasProps);
    exports.Model = Model;
    Model.prototype.type = 'Model';
    Model.define({
        tags: [
            p.Array,
            []
        ],
        name: [p.String],
        js_property_callbacks: [
            p.Any,
            {}
        ],
        js_event_callbacks: [
            p.Any,
            {}
        ],
        subscribed_events: [
            p.Array,
            []
        ]
    });    
},
/*models/annotations/annotation*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var side_panel_1 = require(12    /* core/layout/side_panel */);
    var p = require(15    /* core/properties */);
    var renderer_1 = require(165    /* ../renderers/renderer */);
    exports.AnnotationView = function (_super) {
        tslib_1.__extends(AnnotationView, _super);
        function AnnotationView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnnotationView.prototype._get_size = function () {
            return new Error('not implemented');
        };
        AnnotationView.prototype.get_size = function () {
            if (this.model.visible) {
                return Math.round(this._get_size());
            } else {
                return 0;
            }
        };
        return AnnotationView;
    }(renderer_1.RendererView);
    var Annotation = function (_super) {
        tslib_1.__extends(Annotation, _super);
        function Annotation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Annotation.prototype.add_panel = function (side) {
            var panel;
            if (this.panel == null || side !== this.panel.side) {
                panel = new side_panel_1.SidePanel({ side: side });
                panel.attach_document(this.document);
                return this.set_panel(panel);
            }
        };
        Annotation.prototype.set_panel = function (panel) {
            this.panel = panel;
            // If the annotation is in a side panel, we need to set level to overlay, so it is visible.
            return this.level = 'overlay';
        };
        return Annotation;
    }(renderer_1.Renderer);
    exports.Annotation = Annotation;
    ;
    Annotation.prototype.type = 'Annotation';
    Annotation.prototype.default_view = exports.AnnotationView;
    Annotation.define({ plot: [p.Instance] });
    Annotation.override({ level: 'annotation' });    
},
/*models/annotations/arrow*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var arrow_head_1 = require(53    /* ./arrow_head */);
    var column_data_source_1 = require(173    /* ../sources/column_data_source */);
    var p = require(15    /* core/properties */);
    var math_1 = require(29    /* core/util/math */);
    exports.ArrowView = function (_super) {
        tslib_1.__extends(ArrowView, _super);
        function ArrowView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ArrowView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            if (this.model.source == null) {
                this.model.source = new column_data_source_1.ColumnDataSource();
            }
            return this.set_data(this.model.source);
        };
        ArrowView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            this.connect(this.model.change, function () {
                return _this.plot_view.request_render();
            });
            this.connect(this.model.source.streaming, function () {
                return this.set_data(this.model.source);
            });
            this.connect(this.model.source.patching, function () {
                return this.set_data(this.model.source);
            });
            return this.connect(this.model.source.change, function () {
                return this.set_data(this.model.source);
            });
        };
        ArrowView.prototype.set_data = function (source) {
            _super.prototype.set_data.call(this, source);
            this.visuals.warm_cache(source);
            return this.plot_view.request_render();
        };
        ArrowView.prototype._map_data = function () {
            var end, frame, start, sx_end, sx_start, sy_end, sy_start;
            frame = this.plot_view.frame;
            if (this.model.start_units === 'data') {
                sx_start = frame.xscales[this.model.x_range_name].v_compute(this._x_start);
                sy_start = frame.yscales[this.model.y_range_name].v_compute(this._y_start);
            } else {
                sx_start = frame.xview.v_compute(this._x_start);
                sy_start = frame.yview.v_compute(this._y_start);
            }
            if (this.model.end_units === 'data') {
                sx_end = frame.xscales[this.model.x_range_name].v_compute(this._x_end);
                sy_end = frame.yscales[this.model.y_range_name].v_compute(this._y_end);
            } else {
                sx_end = frame.xview.v_compute(this._x_end);
                sy_end = frame.yview.v_compute(this._y_end);
            }
            start = [
                sx_start,
                sy_start
            ];
            end = [
                sx_end,
                sy_end
            ];
            return [
                start,
                end
            ];
        };
        ArrowView.prototype.render = function () {
            var ctx, height, width, x, y;
            if (!this.model.visible) {
                return;
            }
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            // Order in this function is important. First we draw all the arrow heads.
            _a = this._map_data(), this.start = _a[0], this.end = _a[1];
            if (this.model.end != null) {
                this._arrow_head(ctx, 'render', this.model.end, this.start, this.end);
            }
            if (this.model.start != null) {
                this._arrow_head(ctx, 'render', this.model.start, this.end, this.start);
            }
            // Next we call .clip on all the arrow heads, inside an initial canvas sized
            // rect, to create an "inverted" clip region for the arrow heads
            ctx.beginPath();
            _b = this.plot_model.canvas.bbox.rect, x = _b.x, y = _b.y, width = _b.width, height = _b.height;
            ctx.rect(x, y, width, height);
            if (this.model.end != null) {
                this._arrow_head(ctx, 'clip', this.model.end, this.start, this.end);
            }
            if (this.model.start != null) {
                this._arrow_head(ctx, 'clip', this.model.start, this.end, this.start);
            }
            ctx.closePath();
            ctx.clip();
            // Finally we draw the arrow body, with the clipping regions set up. This prevents
            // "fat" arrows from overlapping the arrow head in a bad way.
            this._arrow_body(ctx);
            return ctx.restore();
            var _a, _b;
        };
        ArrowView.prototype._arrow_body = function (ctx) {
            var i, j, ref, results;
            if (!this.visuals.line.doit) {
                return;
            }
            results = [];
            for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                this.visuals.line.set_vectorize(ctx, i);
                ctx.beginPath();
                ctx.moveTo(this.start[0][i], this.start[1][i]);
                ctx.lineTo(this.end[0][i], this.end[1][i]);
                results.push(ctx.stroke());
            }
            return results;
        };
        ArrowView.prototype._arrow_head = function (ctx, action, head, start, end) {
            var angle, i, j, ref, results;
            results = [];
            for (i = j = 0, ref = this._x_start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                // arrow head runs orthogonal to arrow body
                angle = Math.PI / 2 + math_1.atan2([
                    start[0][i],
                    start[1][i]
                ], [
                    end[0][i],
                    end[1][i]
                ]);
                ctx.save();
                ctx.translate(end[0][i], end[1][i]);
                ctx.rotate(angle);
                if (action === 'render') {
                    head.render(ctx);
                } else if (action === 'clip') {
                    head.clip(ctx);
                }
                results.push(ctx.restore());
            }
            return results;
        };
        return ArrowView;
    }(annotation_1.AnnotationView);
    var Arrow = function (_super) {
        tslib_1.__extends(Arrow, _super);
        function Arrow() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Arrow;
    }(annotation_1.Annotation);
    exports.Arrow = Arrow;
    ;
    Arrow.prototype.default_view = exports.ArrowView;
    Arrow.prototype.type = 'Arrow';
    Arrow.mixins(['line']);
    Arrow.define({
        x_start: [p.NumberSpec],
        y_start: [p.NumberSpec],
        start_units: [
            p.String,
            'data'
        ],
        start: [
            p.Instance,
            null
        ],
        x_end: [p.NumberSpec],
        y_end: [p.NumberSpec],
        end_units: [
            p.String,
            'data'
        ],
        end: [
            p.Instance,
            function () {
                return new arrow_head_1.OpenHead({});
            }
        ],
        source: [p.Instance],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });    
},
/*models/annotations/arrow_head*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var visuals_1 = require(46    /* core/visuals */);
    var p = require(15    /* core/properties */);
    var ArrowHead = function (_super) {
        tslib_1.__extends(ArrowHead, _super);
        function ArrowHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ArrowHead.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.visuals = new visuals_1.Visuals(this);
        };
        ArrowHead.prototype.render = function (ctx, i) {
            return null;
        };
        ArrowHead.prototype.clip = function (ctx, i) {
            // This method should not begin or close a path
            return null;
        };
        return ArrowHead;
    }(annotation_1.Annotation);
    exports.ArrowHead = ArrowHead;
    ;
    ArrowHead.prototype.type = 'ArrowHead';
    var OpenHead = function (_super) {
        tslib_1.__extends(OpenHead, _super);
        function OpenHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OpenHead.prototype.clip = function (ctx, i) {
            // This method should not begin or close a path
            this.visuals.line.set_vectorize(ctx, i);
            ctx.moveTo(0.5 * this.size, this.size);
            ctx.lineTo(0.5 * this.size, -2);
            ctx.lineTo(-0.5 * this.size, -2);
            ctx.lineTo(-0.5 * this.size, this.size);
            ctx.lineTo(0, 0);
            return ctx.lineTo(0.5 * this.size, this.size);
        };
        OpenHead.prototype.render = function (ctx, i) {
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                ctx.beginPath();
                ctx.moveTo(0.5 * this.size, this.size);
                ctx.lineTo(0, 0);
                ctx.lineTo(-0.5 * this.size, this.size);
                return ctx.stroke();
            }
        };
        return OpenHead;
    }(ArrowHead);
    exports.OpenHead = OpenHead;
    ;
    OpenHead.prototype.type = 'OpenHead';
    OpenHead.mixins(['line']);
    OpenHead.define({
        size: [
            p.Number,
            25
        ]
    });
    var NormalHead = function (_super) {
        tslib_1.__extends(NormalHead, _super);
        function NormalHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NormalHead.prototype.clip = function (ctx, i) {
            // This method should not begin or close a path
            this.visuals.line.set_vectorize(ctx, i);
            ctx.moveTo(0.5 * this.size, this.size);
            ctx.lineTo(0.5 * this.size, -2);
            ctx.lineTo(-0.5 * this.size, -2);
            ctx.lineTo(-0.5 * this.size, this.size);
            return ctx.lineTo(0.5 * this.size, this.size);
        };
        NormalHead.prototype.render = function (ctx, i) {
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                this._normal(ctx, i);
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                this._normal(ctx, i);
                return ctx.stroke();
            }
        };
        NormalHead.prototype._normal = function (ctx, i) {
            ctx.beginPath();
            ctx.moveTo(0.5 * this.size, this.size);
            ctx.lineTo(0, 0);
            ctx.lineTo(-0.5 * this.size, this.size);
            return ctx.closePath();
        };
        return NormalHead;
    }(ArrowHead);
    exports.NormalHead = NormalHead;
    ;
    NormalHead.prototype.type = 'NormalHead';
    NormalHead.mixins([
        'line',
        'fill'
    ]);
    NormalHead.define({
        size: [
            p.Number,
            25
        ]
    });
    NormalHead.override({ fill_color: 'black' });
    var VeeHead = function (_super) {
        tslib_1.__extends(VeeHead, _super);
        function VeeHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        VeeHead.prototype.clip = function (ctx, i) {
            // This method should not begin or close a path
            this.visuals.line.set_vectorize(ctx, i);
            ctx.moveTo(0.5 * this.size, this.size);
            ctx.lineTo(0.5 * this.size, -2);
            ctx.lineTo(-0.5 * this.size, -2);
            ctx.lineTo(-0.5 * this.size, this.size);
            ctx.lineTo(0, 0.5 * this.size);
            return ctx.lineTo(0.5 * this.size, this.size);
        };
        VeeHead.prototype.render = function (ctx, i) {
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, i);
                this._vee(ctx, i);
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                this._vee(ctx, i);
                return ctx.stroke();
            }
        };
        VeeHead.prototype._vee = function (ctx, i) {
            ctx.beginPath();
            ctx.moveTo(0.5 * this.size, this.size);
            ctx.lineTo(0, 0);
            ctx.lineTo(-0.5 * this.size, this.size);
            ctx.lineTo(0, 0.5 * this.size);
            return ctx.closePath();
        };
        return VeeHead;
    }(ArrowHead);
    exports.VeeHead = VeeHead;
    ;
    VeeHead.prototype.type = 'VeeHead';
    VeeHead.mixins([
        'line',
        'fill'
    ]);
    VeeHead.define({
        size: [
            p.Number,
            25
        ]
    });
    VeeHead.override({ fill_color: 'black' });
    var TeeHead = function (_super) {
        tslib_1.__extends(TeeHead, _super);
        function TeeHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TeeHead.prototype.render = function (ctx, i) {
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, i);
                ctx.beginPath();
                ctx.moveTo(0.5 * this.size, 0);
                ctx.lineTo(-0.5 * this.size, 0);
                return ctx.stroke();
            }
        };
        return TeeHead;
    }(ArrowHead);
    exports.TeeHead = TeeHead;
    ;
    TeeHead.prototype.type = 'TeeHead';
    TeeHead.mixins(['line']);
    TeeHead.define({
        size: [
            p.Number,
            25
        ]
    });    
},
/*models/annotations/band*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var column_data_source_1 = require(173    /* ../sources/column_data_source */);
    var p = require(15    /* core/properties */);
    exports.BandView = function (_super) {
        tslib_1.__extends(BandView, _super);
        function BandView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BandView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.set_data(this.model.source);
        };
        BandView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            this.connect(this.model.source.streaming, function () {
                return this.set_data(this.model.source);
            });
            this.connect(this.model.source.patching, function () {
                return this.set_data(this.model.source);
            });
            return this.connect(this.model.source.change, function () {
                return this.set_data(this.model.source);
            });
        };
        BandView.prototype.set_data = function (source) {
            _super.prototype.set_data.call(this, source);
            this.visuals.warm_cache(source);
            return this.plot_view.request_render();
        };
        BandView.prototype._map_data = function () {
            var _base_sx, _lower, _lower_sx, _upper, _upper_sx, base_scale, base_view, dim, frame, i, j, limit_scale, limit_view, xscale, yscale;
            frame = this.plot_view.frame;
            dim = this.model.dimension;
            xscale = frame.xscales[this.model.x_range_name];
            yscale = frame.yscales[this.model.y_range_name];
            limit_scale = dim === 'height' ? yscale : xscale;
            base_scale = dim === 'height' ? xscale : yscale;
            limit_view = dim === 'height' ? frame.yview : frame.xview;
            base_view = dim === 'height' ? frame.xview : frame.yview;
            if (this.model.lower.units === 'data') {
                _lower_sx = limit_scale.v_compute(this._lower);
            } else {
                _lower_sx = limit_view.v_compute(this._lower);
            }
            if (this.model.upper.units === 'data') {
                _upper_sx = limit_scale.v_compute(this._upper);
            } else {
                _upper_sx = limit_view.v_compute(this._upper);
            }
            if (this.model.base.units === 'data') {
                _base_sx = base_scale.v_compute(this._base);
            } else {
                _base_sx = base_view.v_compute(this._base);
            }
            _a = dim === 'height' ? [
                1,
                0
            ] : [
                0,
                1
            ], i = _a[0], j = _a[1];
            _lower = [
                _lower_sx,
                _base_sx
            ];
            _upper = [
                _upper_sx,
                _base_sx
            ];
            this._lower_sx = _lower[i];
            this._lower_sy = _lower[j];
            this._upper_sx = _upper[i];
            return this._upper_sy = _upper[j];
            var _a;
        };
        BandView.prototype.render = function () {
            var ctx, i, k, l, m, n, ref, ref1, ref2, ref3;
            if (!this.model.visible) {
                return;
            }
            this._map_data();
            ctx = this.plot_view.canvas_view.ctx;
            // Draw the band body
            ctx.beginPath();
            ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);
            for (i = k = 0, ref = this._lower_sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);
            }
            // iterate backwards so that the upper end is below the lower start
            for (i = l = ref1 = this._upper_sx.length - 1; ref1 <= 0 ? l <= 0 : l >= 0; i = ref1 <= 0 ? ++l : --l) {
                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);
            }
            ctx.closePath();
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_value(ctx);
                ctx.fill();
            }
            // Draw the lower band edge
            ctx.beginPath();
            ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);
            for (i = m = 0, ref2 = this._lower_sx.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
                ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_value(ctx);
                ctx.stroke();
            }
            // Draw the upper band edge
            ctx.beginPath();
            ctx.moveTo(this._upper_sx[0], this._upper_sy[0]);
            for (i = n = 0, ref3 = this._upper_sx.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {
                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_value(ctx);
                return ctx.stroke();
            }
        };
        return BandView;
    }(annotation_1.AnnotationView);
    var Band = function (_super) {
        tslib_1.__extends(Band, _super);
        function Band() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Band;
    }(annotation_1.Annotation);
    exports.Band = Band;
    ;
    Band.prototype.default_view = exports.BandView;
    Band.prototype.type = 'Band';
    Band.mixins([
        'line',
        'fill'
    ]);
    Band.define({
        lower: [p.DistanceSpec],
        upper: [p.DistanceSpec],
        base: [p.DistanceSpec],
        dimension: [
            p.Dimension,
            'height'
        ],
        source: [
            p.Instance,
            function () {
                return new column_data_source_1.ColumnDataSource();
            }
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    Band.override({
        fill_color: '#fff9ba',
        fill_alpha: 0.4,
        line_color: '#cccccc',
        line_alpha: 0.3
    });    
},
/*models/annotations/box_annotation*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var signaling_1 = require(20    /* core/signaling */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    exports.BoxAnnotationView = function (_super) {
        tslib_1.__extends(BoxAnnotationView, _super);
        function BoxAnnotationView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoxAnnotationView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.plot_view.canvas_overlays.appendChild(this.el);
            this.el.classList.add('bk-shading');
            return dom_1.hide(this.el);
        };
        BoxAnnotationView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            // need to respond to either normal BB change events or silent
            // "data only updates" that tools might want to use
            if (this.model.render_mode === 'css') {
                // dispatch CSS update immediately
                this.connect(this.model.change, function () {
                    return this.render();
                });
                return this.connect(this.model.data_update, function () {
                    return this.render();
                });
            } else {
                this.connect(this.model.change, function () {
                    return _this.plot_view.request_render();
                });
                return this.connect(this.model.data_update, function () {
                    return _this.plot_view.request_render();
                });
            }
        };
        BoxAnnotationView.prototype.render = function () {
            var _this = this;
            var _calc_dim, draw, frame, sbottom, sleft, sright, stop, xscale, yscale;
            if (!this.model.visible && this.model.render_mode === 'css') {
                dom_1.hide(this.el);
            }
            if (!this.model.visible) {
                return;
            }
            // don't render if *all* position are null
            if (this.model.left == null && this.model.right == null && this.model.top == null && this.model.bottom == null) {
                dom_1.hide(this.el);
                return null;
            }
            frame = this.plot_model.frame;
            xscale = frame.xscales[this.model.x_range_name];
            yscale = frame.yscales[this.model.y_range_name];
            _calc_dim = function (dim, dim_units, scale, view, frame_extrema) {
                var sdim;
                if (dim != null) {
                    if (_this.model.screen) {
                        sdim = dim;
                    } else {
                        if (dim_units === 'data') {
                            sdim = scale.compute(dim);
                        } else {
                            sdim = view.compute(dim);
                        }
                    }
                } else {
                    sdim = frame_extrema;
                }
                return sdim;
            };
            sleft = _calc_dim(this.model.left, this.model.left_units, xscale, frame.xview, frame._left.value);
            sright = _calc_dim(this.model.right, this.model.right_units, xscale, frame.xview, frame._right.value);
            stop = _calc_dim(this.model.top, this.model.top_units, yscale, frame.yview, frame._top.value);
            sbottom = _calc_dim(this.model.bottom, this.model.bottom_units, yscale, frame.yview, frame._bottom.value);
            draw = this.model.render_mode === 'css' ? this._css_box.bind(this) : this._canvas_box.bind(this);
            return draw(sleft, sright, sbottom, stop);
        };
        BoxAnnotationView.prototype._css_box = function (sleft, sright, sbottom, stop) {
            var ld, sh, sw;
            sw = Math.abs(sright - sleft);
            sh = Math.abs(sbottom - stop);
            this.el.style.left = sleft + 'px';
            this.el.style.width = sw + 'px';
            this.el.style.top = stop + 'px';
            this.el.style.height = sh + 'px';
            this.el.style.borderWidth = this.model.line_width.value + 'px';
            this.el.style.borderColor = this.model.line_color.value;
            this.el.style.backgroundColor = this.model.fill_color.value;
            this.el.style.opacity = this.model.fill_alpha.value;
            // try our best to honor line dashing in some way, if we can
            ld = this.model.line_dash;
            if (types_1.isArray(ld)) {
                ld = ld.length < 2 ? 'solid' : 'dashed';
            }
            if (types_1.isString(ld)) {
                this.el.style.borderStyle = ld;
            }
            return dom_1.show(this.el);
        };
        BoxAnnotationView.prototype._canvas_box = function (sleft, sright, sbottom, stop) {
            var ctx;
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            ctx.beginPath();
            ctx.rect(sleft, stop, sright - sleft, sbottom - stop);
            this.visuals.fill.set_value(ctx);
            ctx.fill();
            this.visuals.line.set_value(ctx);
            ctx.stroke();
            return ctx.restore();
        };
        return BoxAnnotationView;
    }(annotation_1.AnnotationView);
    var BoxAnnotation = function (_super) {
        tslib_1.__extends(BoxAnnotation, _super);
        function BoxAnnotation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoxAnnotation.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            return this.data_update = new signaling_1.Signal(this, 'data_update');
        };
        BoxAnnotation.prototype.update = function (_a) {
            var left = _a.left, right = _a.right, top = _a.top, bottom = _a.bottom;
            this.setv({
                left: left,
                right: right,
                top: top,
                bottom: bottom,
                screen: true
            }, { silent: true });
            return this.data_update.emit();
        };
        return BoxAnnotation;
    }(annotation_1.Annotation);
    exports.BoxAnnotation = BoxAnnotation;
    ;
    BoxAnnotation.prototype.default_view = exports.BoxAnnotationView;
    BoxAnnotation.prototype.type = 'BoxAnnotation';
    BoxAnnotation.mixins([
        'line',
        'fill'
    ]);
    BoxAnnotation.define({
        render_mode: [
            p.RenderMode,
            'canvas'
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        top: [
            p.Number,
            null
        ],
        top_units: [
            p.SpatialUnits,
            'data'
        ],
        bottom: [
            p.Number,
            null
        ],
        bottom_units: [
            p.SpatialUnits,
            'data'
        ],
        left: [
            p.Number,
            null
        ],
        left_units: [
            p.SpatialUnits,
            'data'
        ],
        right: [
            p.Number,
            null
        ],
        right_units: [
            p.SpatialUnits,
            'data'
        ]
    });
    BoxAnnotation.internal({
        screen: [
            p.Boolean,
            false
        ]
    });
    BoxAnnotation.override({
        fill_color: '#fff9ba',
        fill_alpha: 0.4,
        line_color: '#cccccc',
        line_alpha: 0.3
    });    
},
/*models/annotations/color_bar*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var LONG_DIM_MAX_SCALAR, LONG_DIM_MIN_SCALAR, SHORT_DIM;
    var annotation_1 = require(51    /* ./annotation */);
    var basic_ticker_1 = require(180    /* ../tickers/basic_ticker */);
    var basic_tick_formatter_1 = require(91    /* ../formatters/basic_tick_formatter */);
    var linear_color_mapper_1 = require(146    /* ../mappers/linear_color_mapper */);
    var linear_scale_1 = require(168    /* ../scales/linear_scale */);
    var log_scale_1 = require(169    /* ../scales/log_scale */);
    var range1d_1 = require(160    /* ../ranges/range1d */);
    var p = require(15    /* core/properties */);
    var text_util = require(40    /* core/util/text */);
    var array_1 = require(22    /* core/util/array */);
    var object_1 = require(30    /* core/util/object */);
    var types_1 = require(42    /* core/util/types */);
    SHORT_DIM = 25;
    LONG_DIM_MIN_SCALAR = 0.3;
    LONG_DIM_MAX_SCALAR = 0.8;
    exports.ColorBarView = function (_super) {
        tslib_1.__extends(ColorBarView, _super);
        function ColorBarView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColorBarView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this._set_canvas_image();
        };
        ColorBarView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            this.connect(this.model.properties.visible.change, function () {
                return _this.plot_view.request_render();
            });
            this.connect(this.model.ticker.change, function () {
                return _this.plot_view.request_render();
            });
            this.connect(this.model.formatter.change, function () {
                return _this.plot_view.request_render();
            });
            if (this.model.color_mapper != null) {
                return this.connect(this.model.color_mapper.change, function () {
                    this._set_canvas_image();
                    return this.plot_view.request_render();
                });
            }
        };
        ColorBarView.prototype._get_size = function () {
            var bbox, side;
            if (this.model.color_mapper == null) {
                return 0;
            }
            bbox = this.compute_legend_dimensions();
            side = this.model.panel.side;
            if (side === 'above' || side === 'below') {
                return bbox.height;
            }
            if (side === 'left' || side === 'right') {
                return bbox.width;
            }
        };
        ColorBarView.prototype._set_canvas_image = function () {
            var buf, buf8, canvas, cmap, h, image_ctx, image_data, k, palette, ref, results, w;
            if (this.model.color_mapper == null) {
                return;
            }
            palette = this.model.color_mapper.palette;
            if (this.model.orientation === 'vertical') {
                palette = palette.slice(0).reverse();
            }
            switch (this.model.orientation) {
            case 'vertical':
                _a = [
                    1,
                    palette.length
                ], w = _a[0], h = _a[1];
                break;
            case 'horizontal':
                _b = [
                    palette.length,
                    1
                ], w = _b[0], h = _b[1];
            }
            canvas = document.createElement('canvas');
            _c = [
                w,
                h
            ], canvas.width = _c[0], canvas.height = _c[1];
            image_ctx = canvas.getContext('2d');
            image_data = image_ctx.getImageData(0, 0, w, h);
            // We always want to draw the entire palette linearly, so we create a new
            // LinearColorMapper instance and map a monotonic range of values with
            // length = palette.length to get each palette color in order.
            cmap = new linear_color_mapper_1.LinearColorMapper({ palette: palette });
            buf = cmap.v_map_screen(function () {
                results = [];
                for (var k = 0, ref = palette.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--) {
                    results.push(k);
                }
                return results;
            }.apply(this));
            buf8 = new Uint8Array(buf);
            image_data.data.set(buf8);
            image_ctx.putImageData(image_data, 0, 0);
            return this.image = canvas;
            var _a, _b, _c;
        };
        ColorBarView.prototype.compute_legend_dimensions = function () {
            var image_dimensions, image_height, image_width, label_extent, legend_height, legend_width, padding, tick_extent, title_extent;
            image_dimensions = this.model._computed_image_dimensions();
            _a = [
                image_dimensions.height,
                image_dimensions.width
            ], image_height = _a[0], image_width = _a[1];
            label_extent = this._get_label_extent();
            title_extent = this.model._title_extent();
            tick_extent = this.model._tick_extent();
            padding = this.model.padding;
            switch (this.model.orientation) {
            case 'vertical':
                legend_height = image_height + title_extent + padding * 2;
                legend_width = image_width + tick_extent + label_extent + padding * 2;
                break;
            case 'horizontal':
                legend_height = image_height + title_extent + tick_extent + label_extent + padding * 2;
                legend_width = image_width + padding * 2;
            }
            return {
                height: legend_height,
                width: legend_width
            };
            var _a;
        };
        ColorBarView.prototype.compute_legend_location = function () {
            var hr, legend_dimensions, legend_height, legend_margin, legend_width, location, panel, ref, sx, sy, vr, vx, vy;
            legend_dimensions = this.compute_legend_dimensions();
            _a = [
                legend_dimensions.height,
                legend_dimensions.width
            ], legend_height = _a[0], legend_width = _a[1];
            legend_margin = this.model.margin;
            panel = (ref = this.model.panel) != null ? ref : this.plot_view.frame;
            _b = panel.bbox.ranges, hr = _b[0], vr = _b[1];
            location = this.model.location;
            if (types_1.isString(location)) {
                switch (location) {
                case 'top_left':
                    sx = hr.start + legend_margin;
                    sy = vr.start + legend_margin;
                    break;
                case 'top_center':
                    sx = (hr.end + hr.start) / 2 - legend_width / 2;
                    sy = vr.start + legend_margin;
                    break;
                case 'top_right':
                    sx = hr.end - legend_margin - legend_width;
                    sy = vr.start + legend_margin;
                    break;
                case 'bottom_right':
                    sx = hr.end - legend_margin - legend_width;
                    sy = vr.end - legend_margin - legend_height;
                    break;
                case 'bottom_center':
                    sx = (hr.end + hr.start) / 2 - legend_width / 2;
                    sy = vr.end - legend_margin - legend_height;
                    break;
                case 'bottom_left':
                    sx = hr.start + legend_margin;
                    sy = vr.end - legend_margin - legend_height;
                    break;
                case 'center_left':
                    sx = hr.start + legend_margin;
                    sy = (vr.end + vr.start) / 2 - legend_height / 2;
                    break;
                case 'center':
                    sx = (hr.end + hr.start) / 2 - legend_width / 2;
                    sy = (vr.end + vr.start) / 2 - legend_height / 2;
                    break;
                case 'center_right':
                    sx = hr.end - legend_margin - legend_width;
                    sy = (vr.end + vr.start) / 2 - legend_height / 2;
                }
            } else if (types_1.isArray(location) && location.length === 2) {
                vx = location[0], vy = location[1];
                sx = panel.xview.compute(vx);
                sy = panel.yview.compute(vy) - legend_height;
            }
            return {
                sx: sx,
                sy: sy
            };
            var _a, _b;
        };
        ColorBarView.prototype.render = function () {
            var ctx, image_offset, sx, sy, tick_info;
            if (!this.model.visible || this.model.color_mapper == null) {
                return;
            }
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            _a = this.compute_legend_location(), sx = _a.sx, sy = _a.sy;
            ctx.translate(sx, sy);
            this._draw_bbox(ctx);
            image_offset = this._get_image_offset();
            ctx.translate(image_offset.x, image_offset.y);
            this._draw_image(ctx);
            if (this.model.color_mapper.low != null && this.model.color_mapper.high != null) {
                tick_info = this.model.tick_info();
                this._draw_major_ticks(ctx, tick_info);
                this._draw_minor_ticks(ctx, tick_info);
                this._draw_major_labels(ctx, tick_info);
            }
            if (this.model.title) {
                this._draw_title(ctx);
            }
            return ctx.restore();
            var _a;
        };
        ColorBarView.prototype._draw_bbox = function (ctx) {
            var bbox;
            bbox = this.compute_legend_dimensions();
            ctx.save();
            if (this.visuals.background_fill.doit) {
                this.visuals.background_fill.set_value(ctx);
                ctx.fillRect(0, 0, bbox.width, bbox.height);
            }
            if (this.visuals.border_line.doit) {
                this.visuals.border_line.set_value(ctx);
                ctx.strokeRect(0, 0, bbox.width, bbox.height);
            }
            return ctx.restore();
        };
        ColorBarView.prototype._draw_image = function (ctx) {
            var image;
            image = this.model._computed_image_dimensions();
            ctx.save();
            ctx.setImageSmoothingEnabled(false);
            ctx.globalAlpha = this.model.scale_alpha;
            ctx.drawImage(this.image, 0, 0, image.width, image.height);
            if (this.visuals.bar_line.doit) {
                this.visuals.bar_line.set_value(ctx);
                ctx.strokeRect(0, 0, image.width, image.height);
            }
            return ctx.restore();
        };
        ColorBarView.prototype._draw_major_ticks = function (ctx, tick_info) {
            var i, image, k, nx, ny, ref, sx, sy, tin, tout, x_offset, y_offset;
            if (!this.visuals.major_tick_line.doit) {
                return;
            }
            _a = this.model._normals(), nx = _a[0], ny = _a[1];
            image = this.model._computed_image_dimensions();
            _b = [
                image.width * nx,
                image.height * ny
            ], x_offset = _b[0], y_offset = _b[1];
            _c = tick_info.coords.major, sx = _c[0], sy = _c[1];
            tin = this.model.major_tick_in;
            tout = this.model.major_tick_out;
            ctx.save();
            ctx.translate(x_offset, y_offset);
            this.visuals.major_tick_line.set_value(ctx);
            for (i = k = 0, ref = sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                ctx.beginPath();
                ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));
                ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));
                ctx.stroke();
            }
            return ctx.restore();
            var _a, _b, _c;
        };
        ColorBarView.prototype._draw_minor_ticks = function (ctx, tick_info) {
            var i, image, k, nx, ny, ref, sx, sy, tin, tout, x_offset, y_offset;
            if (!this.visuals.minor_tick_line.doit) {
                return;
            }
            _a = this.model._normals(), nx = _a[0], ny = _a[1];
            image = this.model._computed_image_dimensions();
            _b = [
                image.width * nx,
                image.height * ny
            ], x_offset = _b[0], y_offset = _b[1];
            _c = tick_info.coords.minor, sx = _c[0], sy = _c[1];
            tin = this.model.minor_tick_in;
            tout = this.model.minor_tick_out;
            ctx.save();
            ctx.translate(x_offset, y_offset);
            this.visuals.minor_tick_line.set_value(ctx);
            for (i = k = 0, ref = sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                ctx.beginPath();
                ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));
                ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));
                ctx.stroke();
            }
            return ctx.restore();
            var _a, _b, _c;
        };
        ColorBarView.prototype._draw_major_labels = function (ctx, tick_info) {
            var formatted_labels, i, image, k, nx, ny, ref, standoff, sx, sy, x_offset, x_standoff, y_offset, y_standoff;
            if (!this.visuals.major_label_text.doit) {
                return;
            }
            _a = this.model._normals(), nx = _a[0], ny = _a[1];
            image = this.model._computed_image_dimensions();
            _b = [
                image.width * nx,
                image.height * ny
            ], x_offset = _b[0], y_offset = _b[1];
            standoff = this.model.label_standoff + this.model._tick_extent();
            _c = [
                standoff * nx,
                standoff * ny
            ], x_standoff = _c[0], y_standoff = _c[1];
            _d = tick_info.coords.major, sx = _d[0], sy = _d[1];
            formatted_labels = tick_info.labels.major;
            this.visuals.major_label_text.set_value(ctx);
            ctx.save();
            ctx.translate(x_offset + x_standoff, y_offset + y_standoff);
            for (i = k = 0, ref = sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));
            }
            return ctx.restore();
            var _a, _b, _c, _d;
        };
        ColorBarView.prototype._draw_title = function (ctx) {
            if (!this.visuals.title_text.doit) {
                return;
            }
            ctx.save();
            this.visuals.title_text.set_value(ctx);
            ctx.fillText(this.model.title, 0, -this.model.title_standoff);
            return ctx.restore();
        };
        ColorBarView.prototype._get_label_extent = function () {
            var ctx, label, label_extent, major_labels;
            major_labels = this.model.tick_info().labels.major;
            if (this.model.color_mapper.low != null && this.model.color_mapper.high != null && !object_1.isEmpty(major_labels)) {
                ctx = this.plot_view.canvas_view.ctx;
                ctx.save();
                this.visuals.major_label_text.set_value(ctx);
                switch (this.model.orientation) {
                case 'vertical':
                    label_extent = array_1.max(function () {
                        var k, len, results;
                        results = [];
                        for (k = 0, len = major_labels.length; k < len; k++) {
                            label = major_labels[k];
                            results.push(ctx.measureText(label.toString()).width);
                        }
                        return results;
                    }());
                    break;
                case 'horizontal':
                    label_extent = text_util.get_text_height(this.visuals.major_label_text.font_value()).height;
                }
                label_extent += this.model.label_standoff;
                ctx.restore();
            } else {
                label_extent = 0;
            }
            return label_extent;
        };
        ColorBarView.prototype._get_image_offset = function () {
            var x, y;
            // Returns image offset relative to legend bounding box
            x = this.model.padding;
            y = this.model.padding + this.model._title_extent();
            return {
                x: x,
                y: y
            };
        };
        return ColorBarView;
    }(annotation_1.AnnotationView);
    var ColorBar = function (_super) {
        tslib_1.__extends(ColorBar, _super);
        function ColorBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColorBar.prototype.initialize = function (attrs, options) {
            return _super.prototype.initialize.call(this, attrs, options);
        };
        ColorBar.prototype._normals = function () {
            var i, j;
            if (this.orientation === 'vertical') {
                _a = [
                    1,
                    0
                ], i = _a[0], j = _a[1];
            } else {
                _b = [
                    0,
                    1
                ], i = _b[0], j = _b[1];
            }
            return [
                i,
                j
            ];
            var _a, _b;
        };
        ColorBar.prototype._title_extent = function () {
            var font_value, title_extent;
            font_value = this.title_text_font + ' ' + this.title_text_font_size + ' ' + this.title_text_font_style;
            title_extent = this.title ? text_util.get_text_height(font_value).height + this.title_standoff : 0;
            return title_extent;
        };
        ColorBar.prototype._tick_extent = function () {
            var tick_extent;
            if (this.color_mapper.low != null && this.color_mapper.high != null) {
                tick_extent = array_1.max([
                    this.major_tick_out,
                    this.minor_tick_out
                ]);
            } else {
                tick_extent = 0;
            }
            return tick_extent;
        };
        ColorBar.prototype._computed_image_dimensions = function () {
            /*
        Heuristics to determine ColorBar image dimensions if set to "auto"
  
        Note: Returns the height/width values for the ColorBar's scale image, not
        the dimensions of the entire ColorBar.
  
        If the short dimension (the width of a vertical bar or height of a
        horizontal bar) is set to "auto", the resulting dimension will be set to
        25 px.
  
        For a ColorBar in a side panel with the long dimension (the height of a
        vertical bar or width of a horizontal bar) set to "auto", the
        resulting dimension will be as long as the adjacent frame edge, so that the
        bar "fits" to the plot.
  
        For a ColorBar in the plot frame with the long dimension set to "auto", the
        resulting dimension will be the greater of:
          * The length of the color palette * 25px
          * The parallel frame dimension * 0.30
            (i.e the frame height for a vertical ColorBar)
        But not greater than:
          * The parallel frame dimension * 0.80
         */
            var frame_height, frame_width, height, title_extent, width;
            frame_height = this.plot.plot_canvas.frame._height.value;
            frame_width = this.plot.plot_canvas.frame._width.value;
            title_extent = this._title_extent();
            switch (this.orientation) {
            case 'vertical':
                if (this.height === 'auto') {
                    if (this.panel != null) {
                        height = frame_height - 2 * this.padding - title_extent;
                    } else {
                        height = array_1.max([
                            this.color_mapper.palette.length * SHORT_DIM,
                            frame_height * LONG_DIM_MIN_SCALAR
                        ]);
                        height = array_1.min([
                            height,
                            frame_height * LONG_DIM_MAX_SCALAR - 2 * this.padding - title_extent
                        ]);
                    }
                } else {
                    height = this.height;
                }
                width = this.width === 'auto' ? SHORT_DIM : this.width;
                break;
            case 'horizontal':
                height = this.height === 'auto' ? SHORT_DIM : this.height;
                if (this.width === 'auto') {
                    if (this.panel != null) {
                        width = frame_width - 2 * this.padding;
                    } else {
                        width = array_1.max([
                            this.color_mapper.palette.length * SHORT_DIM,
                            frame_width * LONG_DIM_MIN_SCALAR
                        ]);
                        width = array_1.min([
                            width,
                            frame_width * LONG_DIM_MAX_SCALAR - 2 * this.padding
                        ]);
                    }
                } else {
                    width = this.width;
                }
            }
            return {
                'height': height,
                'width': width
            };
        };
        ColorBar.prototype._tick_coordinate_scale = function (scale_length) {
            /*
        Creates and returns a scale instance that maps the `color_mapper` range
        (low to high) to a screen space range equal to the length of the ColorBar's
        scale image. The scale is used to calculate the tick coordinates in screen
        coordinates for plotting purposes.
  
        Note: the type of color_mapper has to match the type of scale (i.e.
        a LinearColorMapper will require a corresponding LinearScale instance).
        */
            var ranges, scale;
            ranges = {
                'source_range': new range1d_1.Range1d({
                    start: this.color_mapper.low,
                    end: this.color_mapper.high
                }),
                'target_range': new range1d_1.Range1d({
                    start: 0,
                    end: scale_length
                })
            };
            switch (this.color_mapper.type) {
            case 'LinearColorMapper':
                scale = new linear_scale_1.LinearScale(ranges);
                break;
            case 'LogColorMapper':
                scale = new log_scale_1.LogScale(ranges);
            }
            return scale;
        };
        ColorBar.prototype._format_major_labels = function (initial_labels, major_ticks) {
            var formatted_labels, i, k, labels, ref;
            labels = initial_labels;
            // note: passing null as cross_loc probably means MercatorTickFormatters, etc
            // will not function properly in conjunction with colorbars
            formatted_labels = this.formatter.doFormat(labels, null);
            for (i = k = 0, ref = major_ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                if (major_ticks[i] in this.major_label_overrides) {
                    formatted_labels[i] = this.major_label_overrides[major_ticks[i]];
                }
            }
            return formatted_labels;
        };
        ColorBar.prototype.tick_info = function () {
            var coord, coords, end, i, ii, image_dimensions, j, k, l, labels, major_coords, majors, minor_coords, minors, ref, ref1, scale, scale_length, start, ticks;
            image_dimensions = this._computed_image_dimensions();
            switch (this.orientation) {
            case 'vertical':
                scale_length = image_dimensions.height;
                break;
            case 'horizontal':
                scale_length = image_dimensions.width;
            }
            scale = this._tick_coordinate_scale(scale_length);
            _a = this._normals(), i = _a[0], j = _a[1];
            _b = [
                this.color_mapper.low,
                this.color_mapper.high
            ], start = _b[0], end = _b[1];
            // note: passing null as cross_loc probably means MercatorTickers, etc
            // will not function properly in conjunction with colorbars
            ticks = this.ticker.get_ticks(start, end, null, null, this.ticker.desired_num_ticks);
            coords = {
                major: [
                    [],
                    []
                ],
                minor: [
                    [],
                    []
                ]
            };
            majors = ticks.major;
            minors = ticks.minor;
            major_coords = coords.major;
            minor_coords = coords.minor;
            for (ii = k = 0, ref = majors.length; 0 <= ref ? k < ref : k > ref; ii = 0 <= ref ? ++k : --k) {
                if (majors[ii] < start || majors[ii] > end) {
                    continue;
                }
                major_coords[i].push(majors[ii]);
                major_coords[j].push(0);
            }
            for (ii = l = 0, ref1 = minors.length; 0 <= ref1 ? l < ref1 : l > ref1; ii = 0 <= ref1 ? ++l : --l) {
                if (minors[ii] < start || minors[ii] > end) {
                    continue;
                }
                minor_coords[i].push(minors[ii]);
                minor_coords[j].push(0);
            }
            labels = {
                major: this._format_major_labels(major_coords[i].slice(0), majors)    // make deep copy
            };
            major_coords[i] = scale.v_compute(major_coords[i]);
            minor_coords[i] = scale.v_compute(minor_coords[i]);
            // Because we want the scale to be reversed
            if (this.orientation === 'vertical') {
                major_coords[i] = new Float64Array(function () {
                    var len, m, ref2, results;
                    ref2 = major_coords[i];
                    results = [];
                    for (m = 0, len = ref2.length; m < len; m++) {
                        coord = ref2[m];
                        results.push(scale_length - coord);
                    }
                    return results;
                }());
                minor_coords[i] = new Float64Array(function () {
                    var len, m, ref2, results;
                    ref2 = minor_coords[i];
                    results = [];
                    for (m = 0, len = ref2.length; m < len; m++) {
                        coord = ref2[m];
                        results.push(scale_length - coord);
                    }
                    return results;
                }());
            }
            return {
                'ticks': ticks,
                'coords': coords,
                'labels': labels
            };
            var _a, _b;
        };
        return ColorBar;
    }(annotation_1.Annotation);
    exports.ColorBar = ColorBar;
    ;
    ColorBar.prototype.default_view = exports.ColorBarView;
    ColorBar.prototype.type = 'ColorBar';
    ColorBar.mixins([
        'text:major_label_',
        'text:title_',
        'line:major_tick_',
        'line:minor_tick_',
        'line:border_',
        'line:bar_',
        'fill:background_'
    ]);
    ColorBar.define({
        location: [
            p.Any,
            'top_right'
        ],
        orientation: [
            p.Orientation,
            'vertical'
        ],
        title: [p.String],
        title_standoff: [
            p.Number,
            2
        ],
        height: [
            p.Any,
            'auto'
        ],
        width: [
            p.Any,
            'auto'
        ],
        scale_alpha: [
            p.Number,
            1
        ],
        ticker: [
            p.Instance,
            function () {
                return new basic_ticker_1.BasicTicker();
            }
        ],
        formatter: [
            p.Instance,
            function () {
                return new basic_tick_formatter_1.BasicTickFormatter();
            }
        ],
        major_label_overrides: [
            p.Any,
            {}
        ],
        color_mapper: [p.Instance],
        label_standoff: [
            p.Number,
            5
        ],
        margin: [
            p.Number,
            30
        ],
        padding: [
            p.Number,
            10
        ],
        major_tick_in: [
            p.Number,
            5
        ],
        major_tick_out: [
            p.Number,
            0
        ],
        minor_tick_in: [
            p.Number,
            0
        ],
        minor_tick_out: [
            p.Number,
            0
        ]
    });
    ColorBar.override({
        background_fill_color: '#ffffff',
        background_fill_alpha: 0.95,
        bar_line_color: null,
        border_line_color: null,
        major_label_text_align: 'center',
        major_label_text_baseline: 'middle',
        major_label_text_font_size: '8pt',
        major_tick_line_color: '#ffffff',
        minor_tick_line_color: null,
        title_text_font_size: '10pt',
        title_text_font_style: 'italic'
    });    
},
/*models/annotations/index*/
function _(require, module, exports) {
    var annotation_1 = require(51    /* ./annotation */);
    exports.Annotation = annotation_1.Annotation;
    var arrow_1 = require(52    /* ./arrow */);
    exports.Arrow = arrow_1.Arrow;
    var arrow_head_1 = require(53    /* ./arrow_head */);
    exports.ArrowHead = arrow_head_1.ArrowHead;
    var arrow_head_2 = require(53    /* ./arrow_head */);
    exports.OpenHead = arrow_head_2.OpenHead;
    var arrow_head_3 = require(53    /* ./arrow_head */);
    exports.NormalHead = arrow_head_3.NormalHead;
    var arrow_head_4 = require(53    /* ./arrow_head */);
    exports.TeeHead = arrow_head_4.TeeHead;
    var arrow_head_5 = require(53    /* ./arrow_head */);
    exports.VeeHead = arrow_head_5.VeeHead;
    var band_1 = require(54    /* ./band */);
    exports.Band = band_1.Band;
    var box_annotation_1 = require(55    /* ./box_annotation */);
    exports.BoxAnnotation = box_annotation_1.BoxAnnotation;
    var color_bar_1 = require(56    /* ./color_bar */);
    exports.ColorBar = color_bar_1.ColorBar;
    var label_1 = require(58    /* ./label */);
    exports.Label = label_1.Label;
    var label_set_1 = require(59    /* ./label_set */);
    exports.LabelSet = label_set_1.LabelSet;
    var legend_1 = require(60    /* ./legend */);
    exports.Legend = legend_1.Legend;
    var legend_item_1 = require(61    /* ./legend_item */);
    exports.LegendItem = legend_item_1.LegendItem;
    var poly_annotation_1 = require(62    /* ./poly_annotation */);
    exports.PolyAnnotation = poly_annotation_1.PolyAnnotation;
    var span_1 = require(63    /* ./span */);
    exports.Span = span_1.Span;
    var text_annotation_1 = require(64    /* ./text_annotation */);
    exports.TextAnnotation = text_annotation_1.TextAnnotation;
    var title_1 = require(65    /* ./title */);
    exports.Title = title_1.Title;
    var toolbar_panel_1 = require(66    /* ./toolbar_panel */);
    exports.ToolbarPanel = toolbar_panel_1.ToolbarPanel;
    var tooltip_1 = require(67    /* ./tooltip */);
    exports.Tooltip = tooltip_1.Tooltip;
    var whisker_1 = require(68    /* ./whisker */);
    exports.Whisker = whisker_1.Whisker;    
},
/*models/annotations/label*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var text_annotation_1 = require(64    /* ./text_annotation */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    exports.LabelView = function (_super) {
        tslib_1.__extends(LabelView, _super);
        function LabelView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LabelView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.visuals.warm_cache(null);
        };
        LabelView.prototype._get_size = function () {
            var ctx, height, width;
            ctx = this.plot_view.canvas_view.ctx;
            this.visuals.text.set_value(ctx);
            if (this.model.panel.is_horizontal) {
                height = ctx.measureText(this.model.text).ascent;
                return height;
            } else {
                width = ctx.measureText(this.model.text).width;
                return width;
            }
        };
        LabelView.prototype.render = function () {
            var angle, draw, panel, ref, sx, sy, xscale, yscale;
            if (!this.model.visible && this.model.render_mode === 'css') {
                dom_1.hide(this.el);
            }
            if (!this.model.visible) {
                return;
            }
            // Here because AngleSpec does units tranform and label doesn't support specs
            switch (this.model.angle_units) {
            case 'rad':
                angle = -1 * this.model.angle;
                break;
            case 'deg':
                angle = -1 * this.model.angle * Math.PI / 180;
            }
            panel = (ref = this.model.panel) != null ? ref : this.plot_view.frame;
            xscale = this.plot_view.frame.xscales[this.model.x_range_name];
            yscale = this.plot_view.frame.yscales[this.model.y_range_name];
            sx = this.model.x_units === 'data' ? xscale.compute(this.model.x) : panel.xview.compute(this.model.x);
            sy = this.model.y_units === 'data' ? yscale.compute(this.model.y) : panel.yview.compute(this.model.y);
            sx += this.model.x_offset;
            sy -= this.model.y_offset;
            draw = this.model.render_mode === 'canvas' ? this._canvas_text.bind(this) : this._css_text.bind(this);
            return draw(this.plot_view.canvas_view.ctx, this.model.text, sx, sy, angle);
        };
        return LabelView;
    }(text_annotation_1.TextAnnotationView);
    var Label = function (_super) {
        tslib_1.__extends(Label, _super);
        function Label() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Label;
    }(text_annotation_1.TextAnnotation);
    exports.Label = Label;
    ;
    Label.prototype.default_view = exports.LabelView;
    Label.prototype.type = 'Label';
    Label.mixins([
        'text',
        'line:border_',
        'fill:background_'
    ]);
    Label.define({
        x: [p.Number],
        x_units: [
            p.SpatialUnits,
            'data'
        ],
        y: [p.Number],
        y_units: [
            p.SpatialUnits,
            'data'
        ],
        text: [p.String],
        angle: [
            p.Angle,
            0
        ],
        angle_units: [
            p.AngleUnits,
            'rad'
        ],
        x_offset: [
            p.Number,
            0
        ],
        y_offset: [
            p.Number,
            0
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        render_mode: [
            p.RenderMode,
            'canvas'
        ]
    });
    Label.override({
        background_fill_color: null,
        border_line_color: null
    });    
},
/*models/annotations/label_set*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var text_annotation_1 = require(64    /* ./text_annotation */);
    var column_data_source_1 = require(173    /* ../sources/column_data_source */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    exports.LabelSetView = function (_super) {
        tslib_1.__extends(LabelSetView, _super);
        function LabelSetView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LabelSetView.prototype.initialize = function (options) {
            var i, j, ref, results;
            _super.prototype.initialize.call(this, options);
            this.set_data(this.model.source);
            if (this.model.render_mode === 'css') {
                results = [];
                for (i = j = 0, ref = this._text.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    this.title_div = dom_1.div({
                        class: 'bk-annotation-child',
                        style: { display: 'none' }
                    });
                    results.push(this.el.appendChild(this.title_div));
                }
                return results;
            }
        };
        LabelSetView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            if (this.model.render_mode === 'css') {
                // dispatch CSS update immediately
                this.connect(this.model.change, function () {
                    this.set_data(this.model.source);
                    return this.render();
                });
                this.connect(this.model.source.streaming, function () {
                    this.set_data(this.model.source);
                    return this.render();
                });
                this.connect(this.model.source.patching, function () {
                    this.set_data(this.model.source);
                    return this.render();
                });
                return this.connect(this.model.source.change, function () {
                    this.set_data(this.model.source);
                    return this.render();
                });
            } else {
                this.connect(this.model.change, function () {
                    this.set_data(this.model.source);
                    return this.plot_view.request_render();
                });
                this.connect(this.model.source.streaming, function () {
                    this.set_data(this.model.source);
                    return this.plot_view.request_render();
                });
                this.connect(this.model.source.patching, function () {
                    this.set_data(this.model.source);
                    return this.plot_view.request_render();
                });
                return this.connect(this.model.source.change, function () {
                    this.set_data(this.model.source);
                    return this.plot_view.request_render();
                });
            }
        };
        LabelSetView.prototype.set_data = function (source) {
            _super.prototype.set_data.call(this, source);
            return this.visuals.warm_cache(source);
        };
        LabelSetView.prototype._map_data = function () {
            var panel, ref, sx, sy, xscale, yscale;
            xscale = this.plot_view.frame.xscales[this.model.x_range_name];
            yscale = this.plot_view.frame.yscales[this.model.y_range_name];
            panel = (ref = this.model.panel) != null ? ref : this.plot_view.frame;
            sx = this.model.x_units === 'data' ? xscale.v_compute(this._x) : panel.xview.v_compute(this._x);
            sy = this.model.y_units === 'data' ? yscale.v_compute(this._y) : panel.yview.v_compute(this._y);
            return [
                sx,
                sy
            ];
        };
        LabelSetView.prototype.render = function () {
            var ctx, draw, i, j, ref, results, sx, sy;
            if (!this.model.visible && this.model.render_mode === 'css') {
                dom_1.hide(this.el);
            }
            if (!this.model.visible) {
                return;
            }
            draw = this.model.render_mode === 'canvas' ? this._v_canvas_text.bind(this) : this._v_css_text.bind(this);
            ctx = this.plot_view.canvas_view.ctx;
            _a = this._map_data(), sx = _a[0], sy = _a[1];
            results = [];
            for (i = j = 0, ref = this._text.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(draw(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]));
            }
            return results;
            var _a;
        };
        LabelSetView.prototype._get_size = function () {
            var ctx, height, side, width;
            ctx = this.plot_view.canvas_view.ctx;
            this.visuals.text.set_value(ctx);
            side = this.model.panel.side;
            if (side === 'above' || side === 'below') {
                height = ctx.measureText(this._text[0]).ascent;
                return height;
            }
            if (side === 'left' || side === 'right') {
                width = ctx.measureText(this._text[0]).width;
                return width;
            }
        };
        LabelSetView.prototype._v_canvas_text = function (ctx, i, text, sx, sy, angle) {
            var bbox_dims;
            this.visuals.text.set_vectorize(ctx, i);
            bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
            ctx.save();
            ctx.beginPath();
            ctx.translate(sx, sy);
            ctx.rotate(angle);
            ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);
            if (this.visuals.background_fill.doit) {
                this.visuals.background_fill.set_vectorize(ctx, i);
                ctx.fill();
            }
            if (this.visuals.border_line.doit) {
                this.visuals.border_line.set_vectorize(ctx, i);
                ctx.stroke();
            }
            if (this.visuals.text.doit) {
                this.visuals.text.set_vectorize(ctx, i);
                ctx.fillText(text, 0, 0);
            }
            return ctx.restore();
        };
        LabelSetView.prototype._v_css_text = function (ctx, i, text, sx, sy, angle) {
            var bbox_dims, el, ld, line_dash;
            el = this.el.childNodes[i];
            el.textContent = text;
            this.visuals.text.set_vectorize(ctx, i);
            bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
            // attempt to support vector-style ("8 4 8") line dashing for css mode
            ld = this.visuals.border_line.line_dash.value();
            if (types_1.isArray(ld)) {
                line_dash = ld.length < 2 ? 'solid' : 'dashed';
            }
            if (types_1.isString(ld)) {
                line_dash = ld;
            }
            this.visuals.border_line.set_vectorize(ctx, i);
            this.visuals.background_fill.set_vectorize(ctx, i);
            el.style.position = 'absolute';
            el.style.left = sx + bbox_dims[0] + 'px';
            el.style.top = sy + bbox_dims[1] + 'px';
            el.style.color = '' + this.visuals.text.text_color.value();
            el.style.opacity = '' + this.visuals.text.text_alpha.value();
            el.style.font = '' + this.visuals.text.font_value();
            el.style.lineHeight = 'normal';
            // needed to prevent ipynb css override
            if (angle) {
                el.style.transform = 'rotate(' + angle + 'rad)';
            }
            if (this.visuals.background_fill.doit) {
                el.style.backgroundColor = '' + this.visuals.background_fill.color_value();
            }
            if (this.visuals.border_line.doit) {
                el.style.borderStyle = '' + line_dash;
                el.style.borderWidth = this.visuals.border_line.line_width.value() + 'px';
                el.style.borderColor = '' + this.visuals.border_line.color_value();
            }
            return dom_1.show(el);
        };
        return LabelSetView;
    }(text_annotation_1.TextAnnotationView);
    var LabelSet = function (_super) {
        tslib_1.__extends(LabelSet, _super);
        function LabelSet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LabelSet;
    }(text_annotation_1.TextAnnotation);
    exports.LabelSet = LabelSet;
    ;
    LabelSet.prototype.default_view = exports.LabelSetView;
    LabelSet.prototype.type = 'Label';
    LabelSet.mixins([
        'text',
        'line:border_',
        'fill:background_'
    ]);
    LabelSet.define({
        x: [p.NumberSpec],
        y: [p.NumberSpec],
        x_units: [
            p.SpatialUnits,
            'data'
        ],
        y_units: [
            p.SpatialUnits,
            'data'
        ],
        text: [
            p.StringSpec,
            { field: 'text' }
        ],
        angle: [
            p.AngleSpec,
            0
        ],
        x_offset: [
            p.NumberSpec,
            { value: 0 }
        ],
        y_offset: [
            p.NumberSpec,
            { value: 0 }
        ],
        source: [
            p.Instance,
            function () {
                return new column_data_source_1.ColumnDataSource();
            }
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        render_mode: [
            p.RenderMode,
            'canvas'
        ]
    });
    LabelSet.override({
        background_fill_color: null,
        border_line_color: null
    });    
},
/*models/annotations/legend*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var p = require(15    /* core/properties */);
    var text_1 = require(40    /* core/util/text */);
    var bbox_1 = require(23    /* core/util/bbox */);
    var array_1 = require(22    /* core/util/array */);
    var object_1 = require(30    /* core/util/object */);
    var types_1 = require(42    /* core/util/types */);
    var LegendView = function (_super) {
        tslib_1.__extends(LegendView, _super);
        function LegendView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LegendView.prototype.initialize = function (options) {
            return _super.prototype.initialize.call(this, options);
        };
        LegendView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.properties.visible.change, function () {
                return _this.plot_view.request_render();
            });
        };
        LegendView.prototype.compute_legend_bbox = function () {
            var ctx, glyph_height, glyph_width, hr, i, label_height, label_standoff, label_width, legend_height, legend_margin, legend_names, legend_padding, legend_spacing, legend_width, len, location, max_label_width, name, panel, ref, ref1, sx, sy, vr, vx, vy, width;
            legend_names = this.model.get_legend_names();
            glyph_height = this.model.glyph_height;
            glyph_width = this.model.glyph_width;
            label_height = this.model.label_height;
            label_width = this.model.label_width;
            this.max_label_height = array_1.max([
                text_1.get_text_height(this.visuals.label_text.font_value()).height,
                label_height,
                glyph_height
            ]);
            // this is to measure text properties
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            this.visuals.label_text.set_value(ctx);
            this.text_widths = {};
            for (i = 0, len = legend_names.length; i < len; i++) {
                name = legend_names[i];
                this.text_widths[name] = array_1.max([
                    ctx.measureText(name).width,
                    label_width
                ]);
            }
            ctx.restore();
            max_label_width = Math.max(array_1.max(object_1.values(this.text_widths)), 0);
            legend_margin = this.model.margin;
            legend_padding = this.legend_padding;
            legend_spacing = this.model.spacing;
            label_standoff = this.model.label_standoff;
            if (this.model.orientation === 'vertical') {
                legend_height = legend_names.length * this.max_label_height + Math.max(legend_names.length - 1, 0) * legend_spacing + 2 * legend_padding;
                legend_width = max_label_width + glyph_width + label_standoff + 2 * legend_padding;
            } else {
                legend_width = 2 * legend_padding + Math.max(legend_names.length - 1, 0) * legend_spacing;
                ref = this.text_widths;
                for (name in ref) {
                    width = ref[name];
                    legend_width += array_1.max([
                        width,
                        label_width
                    ]) + glyph_width + label_standoff;
                }
                legend_height = this.max_label_height + 2 * legend_padding;
            }
            panel = (ref1 = this.model.panel) != null ? ref1 : this.plot_view.frame;
            _a = panel.bbox.ranges, hr = _a[0], vr = _a[1];
            location = this.model.location;
            if (types_1.isString(location)) {
                switch (location) {
                case 'top_left':
                    sx = hr.start + legend_margin;
                    sy = vr.start + legend_margin;
                    break;
                case 'top_center':
                    sx = (hr.end + hr.start) / 2 - legend_width / 2;
                    sy = vr.start + legend_margin;
                    break;
                case 'top_right':
                    sx = hr.end - legend_margin - legend_width;
                    sy = vr.start + legend_margin;
                    break;
                case 'bottom_right':
                    sx = hr.end - legend_margin - legend_width;
                    sy = vr.end - legend_margin - legend_height;
                    break;
                case 'bottom_center':
                    sx = (hr.end + hr.start) / 2 - legend_width / 2;
                    sy = vr.end - legend_margin - legend_height;
                    break;
                case 'bottom_left':
                    sx = hr.start + legend_margin;
                    sy = vr.end - legend_margin - legend_height;
                    break;
                case 'center_left':
                    sx = hr.start + legend_margin;
                    sy = (vr.end + vr.start) / 2 - legend_height / 2;
                    break;
                case 'center':
                    sx = (hr.end + hr.start) / 2 - legend_width / 2;
                    sy = (vr.end + vr.start) / 2 - legend_height / 2;
                    break;
                case 'center_right':
                    sx = hr.end - legend_margin - legend_width;
                    sy = (vr.end + vr.start) / 2 - legend_height / 2;
                }
            } else if (types_1.isArray(location) && location.length === 2) {
                vx = location[0], vy = location[1];
                sx = panel.xview.compute(vx);
                sy = panel.yview.compute(vy) - legend_height;
            }
            return {
                x: sx,
                y: sy,
                width: legend_width,
                height: legend_height
            };
            var _a;
        };
        LegendView.prototype.bbox = function () {
            var height, width, x, y;
            _a = this.compute_legend_bbox(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
            return new bbox_1.BBox({
                x: x,
                y: y,
                width: width,
                height: height
            });
            var _a;
        };
        LegendView.prototype.on_hit = function (sx, sy) {
            var bbox, field, glyph_height, glyph_width, h, i, item, j, k, l, label, label_standoff, labels, legend_bbox, legend_padding, legend_spacing, len, len1, len2, len3, r, ref, ref1, ref2, vertical, w, x1, x2, xoffset, y1, y2, yoffset;
            glyph_height = this.model.glyph_height;
            glyph_width = this.model.glyph_width;
            legend_padding = this.legend_padding;
            legend_spacing = this.model.spacing;
            label_standoff = this.model.label_standoff;
            xoffset = yoffset = legend_padding;
            legend_bbox = this.compute_legend_bbox();
            vertical = this.model.orientation === 'vertical';
            ref = this.model.items;
            for (i = 0, len = ref.length; i < len; i++) {
                item = ref[i];
                labels = item.get_labels_list_from_label_prop();
                field = item.get_field_from_label_prop();
                for (j = 0, len1 = labels.length; j < len1; j++) {
                    label = labels[j];
                    x1 = legend_bbox.x + xoffset;
                    y1 = legend_bbox.y + yoffset;
                    x2 = x1 + glyph_width;
                    y2 = y1 + glyph_height;
                    if (vertical) {
                        _a = [
                            legend_bbox.width - 2 * legend_padding,
                            this.max_label_height
                        ], w = _a[0], h = _a[1];
                    } else {
                        _b = [
                            this.text_widths[label] + glyph_width + label_standoff,
                            this.max_label_height
                        ], w = _b[0], h = _b[1];
                    }
                    bbox = new bbox_1.BBox({
                        x: x1,
                        y: y1,
                        width: w,
                        height: h
                    });
                    if (bbox.contains(sx, sy)) {
                        switch (this.model.click_policy) {
                        case 'hide':
                            ref1 = item.renderers;
                            for (k = 0, len2 = ref1.length; k < len2; k++) {
                                r = ref1[k];
                                r.visible = !r.visible;
                            }
                            break;
                        case 'mute':
                            ref2 = item.renderers;
                            for (l = 0, len3 = ref2.length; l < len3; l++) {
                                r = ref2[l];
                                r.muted = !r.muted;
                            }
                        }
                        return true;
                    }
                    if (vertical) {
                        yoffset += this.max_label_height + legend_spacing;
                    } else {
                        xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;
                    }
                }
            }
            return false;
            var _a, _b;
        };
        LegendView.prototype.render = function () {
            var bbox, ctx;
            if (!this.model.visible) {
                return;
            }
            if (this.model.items.length === 0) {
                return;
            }
            ctx = this.plot_view.canvas_view.ctx;
            bbox = this.compute_legend_bbox();
            ctx.save();
            this._draw_legend_box(ctx, bbox);
            this._draw_legend_items(ctx, bbox);
            return ctx.restore();
        };
        LegendView.prototype._draw_legend_box = function (ctx, bbox) {
            ctx.beginPath();
            ctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);
            this.visuals.background_fill.set_value(ctx);
            ctx.fill();
            if (this.visuals.border_line.doit) {
                this.visuals.border_line.set_value(ctx);
                return ctx.stroke();
            }
        };
        LegendView.prototype._draw_legend_items = function (ctx, bbox) {
            var active, field, glyph_height, glyph_width, h, i, item, j, k, label, label_standoff, labels, legend_padding, legend_spacing, len, len1, len2, r, ref, ref1, vertical, view, w, x1, x2, xoffset, y1, y2, yoffset;
            glyph_height = this.model.glyph_height;
            glyph_width = this.model.glyph_width;
            legend_padding = this.legend_padding;
            legend_spacing = this.model.spacing;
            label_standoff = this.model.label_standoff;
            xoffset = yoffset = legend_padding;
            vertical = this.model.orientation === 'vertical';
            ref = this.model.items;
            for (i = 0, len = ref.length; i < len; i++) {
                item = ref[i];
                labels = item.get_labels_list_from_label_prop();
                field = item.get_field_from_label_prop();
                if (labels.length === 0) {
                    continue;
                }
                active = function () {
                    switch (this.model.click_policy) {
                    case 'none':
                        return true;
                    case 'hide':
                        return array_1.all(item.renderers, function (r) {
                            return r.visible;
                        });
                    case 'mute':
                        return array_1.all(item.renderers, function (r) {
                            return !r.muted;
                        });
                    }
                }.call(this);
                for (j = 0, len1 = labels.length; j < len1; j++) {
                    label = labels[j];
                    x1 = bbox.x + xoffset;
                    y1 = bbox.y + yoffset;
                    x2 = x1 + glyph_width;
                    y2 = y1 + glyph_height;
                    if (vertical) {
                        yoffset += this.max_label_height + legend_spacing;
                    } else {
                        xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;
                    }
                    this.visuals.label_text.set_value(ctx);
                    ctx.fillText(label, x2 + label_standoff, y1 + this.max_label_height / 2);
                    ref1 = item.renderers;
                    for (k = 0, len2 = ref1.length; k < len2; k++) {
                        r = ref1[k];
                        view = this.plot_view.renderer_views[r.id];
                        view.draw_legend(ctx, x1, x2, y1, y2, field, label);
                    }
                    if (!active) {
                        if (vertical) {
                            _a = [
                                bbox.width - 2 * legend_padding,
                                this.max_label_height
                            ], w = _a[0], h = _a[1];
                        } else {
                            _b = [
                                this.text_widths[label] + glyph_width + label_standoff,
                                this.max_label_height
                            ], w = _b[0], h = _b[1];
                        }
                        ctx.beginPath();
                        ctx.rect(x1, y1, w, h);
                        this.visuals.inactive_fill.set_value(ctx);
                        ctx.fill();
                    }
                }
            }
            return null;
            var _a, _b;
        };
        LegendView.prototype._get_size = function () {
            var bbox, side;
            bbox = this.compute_legend_bbox();
            side = this.model.panel.side;
            if (side === 'above' || side === 'below') {
                return bbox.height + 2 * this.model.margin;
            }
            if (side === 'left' || side === 'right') {
                return bbox.width + 2 * this.model.margin;
            }
        };
        return LegendView;
    }(annotation_1.AnnotationView);
    exports.LegendView = LegendView;
    ;
    LegendView.getters({
        legend_padding: function () {
            if (this.visuals.border_line.line_color.value() != null) {
                return this.model.padding;
            } else {
                return 0;
            }
        }
    });
    var Legend = function (_super) {
        tslib_1.__extends(Legend, _super);
        function Legend() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Legend.prototype.cursor = function () {
            if (this.click_policy === 'none') {
                return null;
            } else {
                return 'pointer';
            }
        };
        Legend.prototype.get_legend_names = function () {
            var i, item, labels, legend_names, len, ref;
            legend_names = [];
            ref = this.items;
            for (i = 0, len = ref.length; i < len; i++) {
                item = ref[i];
                labels = item.get_labels_list_from_label_prop();
                legend_names = legend_names.concat(labels);
            }
            return legend_names;
        };
        return Legend;
    }(annotation_1.Annotation);
    exports.Legend = Legend;
    ;
    Legend.prototype.default_view = LegendView;
    Legend.prototype.type = 'Legend';
    Legend.mixins([
        'text:label_',
        'fill:inactive_',
        'line:border_',
        'fill:background_'
    ]);
    Legend.define({
        orientation: [
            p.Orientation,
            'vertical'
        ],
        location: [
            p.Any,
            'top_right'    // TODO (bev)
        ],
        label_standoff: [
            p.Number,
            5
        ],
        glyph_height: [
            p.Number,
            20
        ],
        glyph_width: [
            p.Number,
            20
        ],
        label_height: [
            p.Number,
            20
        ],
        label_width: [
            p.Number,
            20
        ],
        margin: [
            p.Number,
            10
        ],
        padding: [
            p.Number,
            10
        ],
        spacing: [
            p.Number,
            3
        ],
        items: [
            p.Array,
            []
        ],
        click_policy: [
            p.Any,
            'none'
        ]
    });
    Legend.override({
        border_line_color: '#e5e5e5',
        border_line_alpha: 0.5,
        border_line_width: 1,
        background_fill_color: '#ffffff',
        background_fill_alpha: 0.95,
        inactive_fill_color: 'white',
        inactive_fill_alpha: 0.7,
        label_text_font_size: '10pt',
        label_text_baseline: 'middle'
    });    
},
/*models/annotations/legend_item*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var indexOf = [].indexOf, boundMethodCheck = function (instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new Error('Bound instance method accessed before binding');
            }
        };
    var model_1 = require(50    /* ../../model */);
    var p = require(15    /* core/properties */);
    var logging_1 = require(14    /* core/logging */);
    var array_1 = require(22    /* core/util/array */);
    var column_data_source_1 = require(173    /* ../../models/sources/column_data_source */);
    var LegendItem = function (_super) {
        tslib_1.__extends(LegendItem, _super);
        function LegendItem() {
            var _this = _super.apply(this, arguments) || this;
            _this.get_field_from_label_prop = _this.get_field_from_label_prop.bind(_this);
            _this.get_labels_list_from_label_prop = _this.get_labels_list_from_label_prop.bind(_this);
            return _this;
        }
        LegendItem.prototype._check_data_sources_on_renderers = function () {
            var field, i, len, r, ref, source;
            field = this.get_field_from_label_prop();
            if (field != null) {
                if (this.renderers.length < 1) {
                    return false;
                }
                source = this.renderers[0].data_source;
                if (source != null) {
                    ref = this.renderers;
                    for (i = 0, len = ref.length; i < len; i++) {
                        r = ref[i];
                        if (r.data_source !== source) {
                            return false;
                        }
                    }
                }
            }
            return true;
        };
        LegendItem.prototype._check_field_label_on_data_source = function () {
            var field, source;
            field = this.get_field_from_label_prop();
            if (field != null) {
                if (this.renderers.length < 1) {
                    return false;
                }
                source = this.renderers[0].data_source;
                if (source != null && indexOf.call(source.columns(), field) < 0) {
                    return false;
                }
            }
            return true;
        };
        LegendItem.prototype.initialize = function (attrs, options) {
            var data_source_validation, field_validation;
            _super.prototype.initialize.call(this, attrs, options);
            // Validate data_sources match
            data_source_validation = this._check_data_sources_on_renderers();
            if (!data_source_validation) {
                logging_1.logger.error('Non matching data sources on legend item renderers');
            }
            // Validate label in data_source
            field_validation = this._check_field_label_on_data_source();
            if (!field_validation) {
                return logging_1.logger.error('Bad column name on label: ' + this.label);
            }
        };
        LegendItem.prototype.get_field_from_label_prop = function () {
            boundMethodCheck(this, LegendItem);
            if (this.label != null && this.label.field != null) {
                return this.label.field;
            }
        };
        LegendItem.prototype.get_labels_list_from_label_prop = function () {
            var data, field, source;
            boundMethodCheck(this, LegendItem);
            // Always return a list of the labels
            if (this.label != null && this.label.value != null) {
                return [this.label.value];
            }
            field = this.get_field_from_label_prop();
            if (field != null) {
                if (this.renderers[0] && this.renderers[0].data_source != null) {
                    source = this.renderers[0].data_source;
                } else {
                    return ['No source found'];
                }
                if (source instanceof column_data_source_1.ColumnDataSource) {
                    data = source.get_column(field);
                    if (data != null) {
                        return array_1.uniq(data);
                    } else {
                        return ['Invalid field'];
                    }
                }
            }
            return [];
        };
        return LegendItem;
    }(model_1.Model);
    exports.LegendItem = LegendItem;
    ;
    LegendItem.prototype.type = 'LegendItem';
    LegendItem.define({
        label: [
            p.StringSpec,
            null
        ],
        renderers: [
            p.Array,
            []
        ]
    });    
},
/*models/annotations/poly_annotation*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var signaling_1 = require(20    /* core/signaling */);
    var p = require(15    /* core/properties */);
    exports.PolyAnnotationView = function (_super) {
        tslib_1.__extends(PolyAnnotationView, _super);
        function PolyAnnotationView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PolyAnnotationView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            // need to respond to either normal BB change events or silent
            // "data only updates" that tools might want to use
            this.connect(this.model.change, function () {
                return _this.plot_view.request_render();
            });
            return this.connect(this.model.data_update, function () {
                return _this.plot_view.request_render();
            });
        };
        PolyAnnotationView.prototype.render = function (ctx) {
            var frame, i, j, ref, sx, sy, xs, ys;
            if (!this.model.visible) {
                return;
            }
            xs = this.model.xs;
            ys = this.model.ys;
            if (xs.length !== ys.length) {
                return null;
            }
            if (xs.length < 3 || ys.length < 3) {
                return null;
            }
            frame = this.plot_view.frame;
            ctx = this.plot_view.canvas_view.ctx;
            for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (this.model.xs_units === 'screen') {
                    sx = this.model.screen ? xs[i] : frame.xview.compute(xs[i]);
                }
                if (this.model.ys_units === 'screen') {
                    sy = this.model.screen ? ys[i] : frame.yview.compute(ys[i]);
                }
                if (i === 0) {
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                } else {
                    ctx.lineTo(sx, sy);
                }
            }
            ctx.closePath();
            if (this.visuals.line.doit) {
                this.visuals.line.set_value(ctx);
                ctx.stroke();
            }
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_value(ctx);
                return ctx.fill();
            }
        };
        return PolyAnnotationView;
    }(annotation_1.AnnotationView);
    var PolyAnnotation = function (_super) {
        tslib_1.__extends(PolyAnnotation, _super);
        function PolyAnnotation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PolyAnnotation.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            return this.data_update = new signaling_1.Signal(this, 'data_update');
        };
        PolyAnnotation.prototype.update = function (_a) {
            var xs = _a.xs, ys = _a.ys;
            this.setv({
                xs: xs,
                ys: ys,
                screen: true
            }, { silent: true });
            return this.data_update.emit();
        };
        return PolyAnnotation;
    }(annotation_1.Annotation);
    exports.PolyAnnotation = PolyAnnotation;
    ;
    PolyAnnotation.prototype.default_view = exports.PolyAnnotationView;
    PolyAnnotation.prototype.type = 'PolyAnnotation';
    PolyAnnotation.mixins([
        'line',
        'fill'
    ]);
    PolyAnnotation.define({
        xs: [
            p.Array,
            []
        ],
        xs_units: [
            p.SpatialUnits,
            'data'
        ],
        ys: [
            p.Array,
            []
        ],
        ys_units: [
            p.SpatialUnits,
            'data'
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    PolyAnnotation.internal({
        screen: [
            p.Boolean,
            false
        ]
    });
    PolyAnnotation.override({
        fill_color: '#fff9ba',
        fill_alpha: 0.4,
        line_color: '#cccccc',
        line_alpha: 0.3
    });    
},
/*models/annotations/span*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    exports.SpanView = function (_super) {
        tslib_1.__extends(SpanView, _super);
        function SpanView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SpanView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.plot_view.canvas_overlays.appendChild(this.el);
            this.el.style.position = 'absolute';
            return dom_1.hide(this.el);
        };
        SpanView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            if (this.model.for_hover) {
                return this.connect(this.model.properties.computed_location.change, function () {
                    return this._draw_span();
                });
            } else {
                if (this.model.render_mode === 'canvas') {
                    this.connect(this.model.change, function () {
                        return _this.plot_view.request_render();
                    });
                    return this.connect(this.model.properties.location.change, function () {
                        return _this.plot_view.request_render();
                    });
                } else {
                    this.connect(this.model.change, function () {
                        return this.render();
                    });
                    return this.connect(this.model.properties.location.change, function () {
                        return this._draw_span();
                    });
                }
            }
        };
        SpanView.prototype.render = function () {
            if (!this.model.visible && this.model.render_mode === 'css') {
                dom_1.hide(this.el);
            }
            if (!this.model.visible) {
                return;
            }
            return this._draw_span();
        };
        SpanView.prototype._draw_span = function () {
            var _this = this;
            var _calc_dim, ctx, frame, height, loc, sleft, stop, width, xscale, yscale;
            loc = this.model.for_hover ? this.model.computed_location : this.model.location;
            if (loc == null) {
                dom_1.hide(this.el);
                return;
            }
            frame = this.plot_view.frame;
            xscale = frame.xscales[this.model.x_range_name];
            yscale = frame.yscales[this.model.y_range_name];
            _calc_dim = function (scale, view) {
                if (_this.model.for_hover) {
                    return _this.model.computed_location;
                } else {
                    if (_this.model.location_units === 'data') {
                        return scale.compute(loc);
                    } else {
                        return view.compute(loc);
                    }
                }
            };
            if (this.model.dimension === 'width') {
                stop = _calc_dim(yscale, frame.yview);
                sleft = frame._left.value;
                width = frame._width.value;
                height = this.model.properties.line_width.value();
            } else {
                stop = frame._top.value;
                sleft = _calc_dim(xscale, frame.xview);
                width = this.model.properties.line_width.value();
                height = frame._height.value;
            }
            if (this.model.render_mode === 'css') {
                this.el.style.top = stop + 'px';
                this.el.style.left = sleft + 'px';
                this.el.style.width = width + 'px';
                this.el.style.height = height + 'px';
                this.el.style.zIndex = 1000;
                this.el.style.backgroundColor = this.model.properties.line_color.value();
                this.el.style.opacity = this.model.properties.line_alpha.value();
                return dom_1.show(this.el);
            } else if (this.model.render_mode === 'canvas') {
                ctx = this.plot_view.canvas_view.ctx;
                ctx.save();
                ctx.beginPath();
                this.visuals.line.set_value(ctx);
                ctx.moveTo(sleft, stop);
                if (this.model.dimension === 'width') {
                    ctx.lineTo(sleft + width, stop);
                } else {
                    ctx.lineTo(sleft, stop + height);
                }
                ctx.stroke();
                return ctx.restore();
            }
        };
        return SpanView;
    }(annotation_1.AnnotationView);
    var Span = function (_super) {
        tslib_1.__extends(Span, _super);
        function Span() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Span;
    }(annotation_1.Annotation);
    exports.Span = Span;
    ;
    Span.prototype.default_view = exports.SpanView;
    Span.prototype.type = 'Span';
    Span.mixins(['line']);
    Span.define({
        render_mode: [
            p.RenderMode,
            'canvas'
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        location: [
            p.Number,
            null
        ],
        location_units: [
            p.SpatialUnits,
            'data'
        ],
        dimension: [
            p.Dimension,
            'width'
        ]
    });
    Span.override({ line_color: 'black' });
    Span.internal({
        for_hover: [
            p.Boolean,
            false
        ],
        computed_location: [
            p.Number,
            null    // absolute screen coordinate
        ]
    });    
},
/*models/annotations/text_annotation*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var dom_1 = require(5    /* core/dom */);
    var types_1 = require(42    /* core/util/types */);
    var text_1 = require(40    /* core/util/text */);
    exports.TextAnnotationView = function (_super) {
        tslib_1.__extends(TextAnnotationView, _super);
        function TextAnnotationView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextAnnotationView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            if (this.model.render_mode === 'css') {
                this.el.classList.add('bk-annotation');
                return this.plot_view.canvas_overlays.appendChild(this.el);
            }
        };
        TextAnnotationView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            if (this.model.render_mode === 'css') {
                // dispatch CSS update immediately
                return this.connect(this.model.change, function () {
                    return this.render();
                });
            } else {
                return this.connect(this.model.change, function () {
                    return _this.plot_view.request_render();
                });
            }
        };
        TextAnnotationView.prototype._calculate_text_dimensions = function (ctx, text) {
            var height, width;
            width = ctx.measureText(text).width;
            height = text_1.get_text_height(this.visuals.text.font_value()).height;
            return [
                width,
                height
            ];
        };
        TextAnnotationView.prototype._calculate_bounding_box_dimensions = function (ctx, text) {
            var height, width, x_offset, y_offset;
            _a = this._calculate_text_dimensions(ctx, text), width = _a[0], height = _a[1];
            switch (ctx.textAlign) {
            case 'left':
                x_offset = 0;
                break;
            case 'center':
                x_offset = -width / 2;
                break;
            case 'right':
                x_offset = -width;
            }
            // guestimated from https://www.w3.org/TR/2dcontext/#dom-context-2d-textbaseline
            switch (ctx.textBaseline) {
            case 'top':
                y_offset = 0;
                break;
            case 'middle':
                y_offset = -0.5 * height;
                break;
            case 'bottom':
                y_offset = -1 * height;
                break;
            case 'alphabetic':
                y_offset = -0.8 * height;
                break;
            case 'hanging':
                y_offset = -0.17 * height;
                break;
            case 'ideographic':
                y_offset = -0.83 * height;
            }
            return [
                x_offset,
                y_offset,
                width,
                height
            ];
            var _a;
        };
        TextAnnotationView.prototype._get_size = function () {
            var ctx;
            ctx = this.plot_view.canvas_view.ctx;
            this.visuals.text.set_value(ctx);
            return ctx.measureText(this.model.text).ascent;
        };
        TextAnnotationView.prototype.render = function () {
            return null;
        };
        TextAnnotationView.prototype._canvas_text = function (ctx, text, sx, sy, angle) {
            var bbox_dims;
            this.visuals.text.set_value(ctx);
            bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
            ctx.save();
            ctx.beginPath();
            ctx.translate(sx, sy);
            if (angle) {
                ctx.rotate(angle);
            }
            ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);
            if (this.visuals.background_fill.doit) {
                this.visuals.background_fill.set_value(ctx);
                ctx.fill();
            }
            if (this.visuals.border_line.doit) {
                this.visuals.border_line.set_value(ctx);
                ctx.stroke();
            }
            if (this.visuals.text.doit) {
                this.visuals.text.set_value(ctx);
                ctx.fillText(text, 0, 0);
            }
            return ctx.restore();
        };
        TextAnnotationView.prototype._css_text = function (ctx, text, sx, sy, angle) {
            var bbox_dims, ld, line_dash;
            dom_1.hide(this.el);
            this.visuals.text.set_value(ctx);
            bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);
            // attempt to support vector string-style ("8 4 8") line dashing for css mode
            ld = this.visuals.border_line.line_dash.value();
            if (types_1.isArray(ld)) {
                if (ld.length < 2) {
                    line_dash = 'solid';
                } else {
                    line_dash = 'dashed';
                }
            }
            if (types_1.isString(ld)) {
                line_dash = ld;
            }
            this.visuals.border_line.set_value(ctx);
            this.visuals.background_fill.set_value(ctx);
            this.el.style.position = 'absolute';
            this.el.style.left = sx + bbox_dims[0] + 'px';
            this.el.style.top = sy + bbox_dims[1] + 'px';
            this.el.style.color = '' + this.visuals.text.text_color.value();
            this.el.style.opacity = '' + this.visuals.text.text_alpha.value();
            this.el.style.font = '' + this.visuals.text.font_value();
            this.el.style.lineHeight = 'normal';
            // needed to prevent ipynb css override
            if (angle) {
                this.el.style.transform = 'rotate(' + angle + 'rad)';
            }
            if (this.visuals.background_fill.doit) {
                this.el.style.backgroundColor = '' + this.visuals.background_fill.color_value();
            }
            if (this.visuals.border_line.doit) {
                this.el.style.borderStyle = '' + line_dash;
                this.el.style.borderWidth = this.visuals.border_line.line_width.value() + 'px';
                this.el.style.borderColor = '' + this.visuals.border_line.color_value();
            }
            this.el.textContent = text;
            return dom_1.show(this.el);
        };
        return TextAnnotationView;
    }(annotation_1.AnnotationView);
    var TextAnnotation = function (_super) {
        tslib_1.__extends(TextAnnotation, _super);
        function TextAnnotation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TextAnnotation;
    }(annotation_1.Annotation);
    exports.TextAnnotation = TextAnnotation;
    ;
    TextAnnotation.prototype.type = 'TextAnnotation';
    TextAnnotation.prototype.default_view = exports.TextAnnotationView;    
},
/*models/annotations/title*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var text_annotation_1 = require(64    /* ./text_annotation */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var Visuals = require(46    /* core/visuals */);
    exports.TitleView = function (_super) {
        tslib_1.__extends(TitleView, _super);
        function TitleView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TitleView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.visuals.text = new Visuals.Text(this.model);
        };
        TitleView.prototype._get_location = function () {
            var hmargin, panel, sx, sy, vmargin;
            panel = this.model.panel;
            hmargin = this.model.offset;
            vmargin = 5;
            switch (panel.side) {
            case 'above':
            case 'below':
                switch (this.model.vertical_align) {
                case 'top':
                    sy = panel._top.value + vmargin;
                    break;
                case 'middle':
                    sy = panel._vcenter.value;
                    break;
                case 'bottom':
                    sy = panel._bottom.value - vmargin;
                }
                switch (this.model.align) {
                case 'left':
                    sx = panel._left.value + hmargin;
                    break;
                case 'center':
                    sx = panel._hcenter.value;
                    break;
                case 'right':
                    sx = panel._right.value - hmargin;
                }
                break;
            case 'left':
                switch (this.model.vertical_align) {
                case 'top':
                    sx = panel._left.value - vmargin;
                    break;
                case 'middle':
                    sx = panel._hcenter.value;
                    break;
                case 'bottom':
                    sx = panel._right.value + vmargin;
                }
                switch (this.model.align) {
                case 'left':
                    sy = panel._bottom.value - hmargin;
                    break;
                case 'center':
                    sy = panel._vcenter.value;
                    break;
                case 'right':
                    sy = panel._top.value + hmargin;
                }
                break;
            case 'right':
                switch (this.model.vertical_align) {
                case 'top':
                    sx = panel._right.value - vmargin;
                    break;
                case 'middle':
                    sx = panel._hcenter.value;
                    break;
                case 'bottom':
                    sx = panel._left.value + vmargin;
                }
                switch (this.model.align) {
                case 'left':
                    sy = panel._top.value + hmargin;
                    break;
                case 'center':
                    sy = panel._vcenter.value;
                    break;
                case 'right':
                    sy = panel._bottom.value - hmargin;
                }
            }
            return [
                sx,
                sy
            ];
        };
        TitleView.prototype.render = function () {
            var angle, draw, sx, sy, text;
            if (!this.model.visible) {
                if (this.model.render_mode === 'css') {
                    dom_1.hide(this.el);
                }
                return;
            }
            text = this.model.text;
            if (text == null || text.length === 0) {
                return;
            }
            this.model.text_baseline = this.model.vertical_align;
            this.model.text_align = this.model.align;
            _a = this._get_location(), sx = _a[0], sy = _a[1];
            angle = this.model.panel.get_label_angle_heuristic('parallel');
            draw = this.model.render_mode === 'canvas' ? this._canvas_text.bind(this) : this._css_text.bind(this);
            return draw(this.plot_view.canvas_view.ctx, text, sx, sy, angle);
            var _a;
        };
        TitleView.prototype._get_size = function () {
            var ctx, text;
            text = this.model.text;
            if (text == null || text.length === 0) {
                return 0;
            } else {
                ctx = this.plot_view.canvas_view.ctx;
                this.visuals.text.set_value(ctx);
                return ctx.measureText(text).ascent + 10;
            }
        };
        return TitleView;
    }(text_annotation_1.TextAnnotationView);
    var Title = function (_super) {
        tslib_1.__extends(Title, _super);
        function Title() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Title;
    }(text_annotation_1.TextAnnotation);
    exports.Title = Title;
    ;
    Title.prototype.default_view = exports.TitleView;
    Title.prototype.type = 'Title';
    Title.mixins([
        'line:border_',
        'fill:background_'
    ]);
    Title.define({
        text: [p.String],
        text_font: [
            p.Font,
            'helvetica'
        ],
        text_font_size: [
            p.FontSizeSpec,
            '10pt'
        ],
        text_font_style: [
            p.FontStyle,
            'bold'
        ],
        text_color: [
            p.ColorSpec,
            '#444444'
        ],
        text_alpha: [
            p.NumberSpec,
            1
        ],
        vertical_align: [
            p.VerticalAlign,
            'bottom'
        ],
        align: [
            p.TextAlign,
            'left'
        ],
        offset: [
            p.Number,
            0
        ],
        render_mode: [
            p.RenderMode,
            'canvas'
        ]
    });
    Title.override({
        background_fill_color: null,
        border_line_color: null
    });
    Title.internal({
        text_align: [
            p.TextAlign,
            'left'
        ],
        text_baseline: [
            p.TextBaseline,
            'bottom'
        ]
    });    
},
/*models/annotations/toolbar_panel*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var build_views_1 = require(4    /* core/build_views */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    exports.ToolbarPanelView = function (_super) {
        tslib_1.__extends(ToolbarPanelView, _super);
        function ToolbarPanelView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolbarPanelView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.plot_view.canvas_events.appendChild(this.el);
            this._toolbar_views = {};
            return build_views_1.build_views(this._toolbar_views, [this.model.toolbar], { parent: this });
        };
        ToolbarPanelView.prototype.remove = function () {
            build_views_1.remove_views(this._toolbar_views);
            return _super.prototype.remove.call(this);
        };
        ToolbarPanelView.prototype.render = function () {
            var panel, toolbar;
            _super.prototype.render.call(this);
            if (!this.model.visible) {
                dom_1.hide(this.el);
                return;
            }
            panel = this.model.panel;
            this.el.style.position = 'absolute';
            this.el.style.left = panel._left.value + 'px';
            this.el.style.top = panel._top.value + 'px';
            this.el.style.width = panel._width.value + 'px';
            this.el.style.height = panel._height.value + 'px';
            this.el.style.overflow = 'hidden';
            toolbar = this._toolbar_views[this.model.toolbar.id];
            toolbar.render();
            dom_1.empty(this.el);
            this.el.appendChild(toolbar.el);
            return dom_1.show(this.el);
        };
        ToolbarPanelView.prototype._get_size = function () {
            return 30;
        };
        return ToolbarPanelView;
    }(annotation_1.AnnotationView);
    var ToolbarPanel = function (_super) {
        tslib_1.__extends(ToolbarPanel, _super);
        function ToolbarPanel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ToolbarPanel;
    }(annotation_1.Annotation);
    exports.ToolbarPanel = ToolbarPanel;
    ;
    ToolbarPanel.prototype.type = 'ToolbarPanel';
    ToolbarPanel.prototype.default_view = exports.ToolbarPanelView;
    ToolbarPanel.define({ toolbar: [p.Instance] });    
},
/*models/annotations/tooltip*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var TooltipView = function (_super) {
        tslib_1.__extends(TooltipView, _super);
        function TooltipView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TooltipView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            // TODO (bev) really probably need multiple divs
            this.plot_view.canvas_overlays.appendChild(this.el);
            this.el.style.zIndex = 1010;
            return dom_1.hide(this.el);
        };
        TooltipView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.properties.data.change, function () {
                return this._draw_tips();
            });
        };
        TooltipView.prototype.render = function () {
            if (!this.model.visible) {
                return;
            }
            return this._draw_tips();
        };
        TooltipView.prototype._draw_tips = function () {
            var arrow_size, attachment, content, data, frame, i, left, len, side, sx, sy, tip, top, val;
            data = this.model.data;
            dom_1.empty(this.el);
            dom_1.hide(this.el);
            if (this.model.custom) {
                this.el.classList.add('bk-tooltip-custom');
            } else {
                this.el.classList.remove('bk-tooltip-custom');
            }
            if (data.length === 0) {
                return;
            }
            frame = this.plot_view.frame;
            for (i = 0, len = data.length; i < len; i++) {
                val = data[i];
                sx = val[0], sy = val[1], content = val[2];
                if (this.model.inner_only && !frame.bbox.contains(sx, sy)) {
                    continue;
                }
                tip = dom_1.div({}, content);
                this.el.appendChild(tip);
            }
            attachment = this.model.attachment;
            switch (attachment) {
            case 'horizontal':
                side = sx < frame._hcenter.value ? 'right' : 'left';
                break;
            case 'vertical':
                side = sy < frame._vcenter.value ? 'below' : 'above';
                break;
            default:
                side = attachment;
            }
            this.el.classList.remove('bk-right');
            this.el.classList.remove('bk-left');
            this.el.classList.remove('bk-above');
            this.el.classList.remove('bk-below');
            arrow_size = 10;
            // XXX: keep in sync with less
            dom_1.show(this.el);
            // XXX: {offset,client}Width() gives 0 when display="none"
            switch (side) {
            case 'right':
                this.el.classList.add('bk-left');
                left = sx + (this.el.offsetWidth - this.el.clientWidth) + arrow_size;
                top = sy - this.el.offsetHeight / 2;
                break;
            case 'left':
                this.el.classList.add('bk-right');
                left = sx - this.el.offsetWidth - arrow_size;
                top = sy - this.el.offsetHeight / 2;
                break;
            case 'above':
                this.el.classList.add('bk-above');
                top = sy + (this.el.offsetHeight - this.el.clientHeight) + arrow_size;
                left = Math.round(sx - this.el.offsetWidth / 2);
                break;
            case 'below':
                this.el.classList.add('bk-below');
                top = sy - this.el.offsetHeight - arrow_size;
                left = Math.round(sx - this.el.offsetWidth / 2);
            }
            if (this.model.show_arrow) {
                this.el.classList.add('bk-tooltip-arrow');
            }
            // TODO (bev) this is not currently bulletproof. If there are
            // two hits, not colocated and one is off the screen, that can
            // be problematic
            if (this.el.childNodes.length > 0) {
                this.el.style.top = top + 'px';
                return this.el.style.left = left + 'px';
            } else {
                return dom_1.hide(this.el);
            }
        };
        return TooltipView;
    }(annotation_1.AnnotationView);
    exports.TooltipView = TooltipView;
    ;
    TooltipView.prototype.className = 'bk-tooltip';
    var Tooltip = function (_super) {
        tslib_1.__extends(Tooltip, _super);
        function Tooltip() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Tooltip.prototype.clear = function () {
            return this.data = [];
        };
        Tooltip.prototype.add = function (sx, sy, content) {
            var data;
            data = this.data;
            data.push([
                sx,
                sy,
                content
            ]);
            this.data = data;
            // TODO (bev) not sure why this is now necessary
            return this.properties.data.change.emit();
        };
        return Tooltip;
    }(annotation_1.Annotation);
    exports.Tooltip = Tooltip;
    ;
    Tooltip.prototype.default_view = TooltipView;
    Tooltip.prototype.type = 'Tooltip';
    Tooltip.define({
        attachment: [
            p.String,
            'horizontal'    // TODO enum: "horizontal" | "vertical" | "left" | "right" | "above" | "below"
        ],
        inner_only: [
            p.Bool,
            true
        ],
        show_arrow: [
            p.Bool,
            true
        ]
    });
    Tooltip.override({ level: 'overlay' });
    Tooltip.internal({
        data: [
            p.Any,
            []
        ],
        custom: [p.Any]
    });    
},
/*models/annotations/whisker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var annotation_1 = require(51    /* ./annotation */);
    var column_data_source_1 = require(173    /* ../sources/column_data_source */);
    var arrow_head_1 = require(53    /* ./arrow_head */);
    var p = require(15    /* core/properties */);
    exports.WhiskerView = function (_super) {
        tslib_1.__extends(WhiskerView, _super);
        function WhiskerView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WhiskerView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.set_data(this.model.source);
        };
        WhiskerView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            this.connect(this.model.source.streaming, function () {
                return this.set_data(this.model.source);
            });
            this.connect(this.model.source.patching, function () {
                return this.set_data(this.model.source);
            });
            return this.connect(this.model.source.change, function () {
                return this.set_data(this.model.source);
            });
        };
        WhiskerView.prototype.set_data = function (source) {
            _super.prototype.set_data.call(this, source);
            this.visuals.warm_cache(source);
            return this.plot_view.request_render();
        };
        WhiskerView.prototype._map_data = function () {
            var _base_sx, _lower, _lower_sx, _upper, _upper_sx, base_scale, base_view, dim, frame, i, j, limit_scale, limit_view, xscale, yscale;
            frame = this.plot_model.frame;
            dim = this.model.dimension;
            xscale = frame.xscales[this.model.x_range_name];
            yscale = frame.yscales[this.model.y_range_name];
            limit_scale = dim === 'height' ? yscale : xscale;
            base_scale = dim === 'height' ? xscale : yscale;
            limit_view = dim === 'height' ? frame.yview : frame.xview;
            base_view = dim === 'height' ? frame.xview : frame.yview;
            if (this.model.lower.units === 'data') {
                _lower_sx = limit_scale.v_compute(this._lower);
            } else {
                _lower_sx = limit_view.v_compute(this._lower);
            }
            if (this.model.upper.units === 'data') {
                _upper_sx = limit_scale.v_compute(this._upper);
            } else {
                _upper_sx = limit_view.v_compute(this._upper);
            }
            if (this.model.base.units === 'data') {
                _base_sx = base_scale.v_compute(this._base);
            } else {
                _base_sx = base_view.v_compute(this._base);
            }
            _a = dim === 'height' ? [
                1,
                0
            ] : [
                0,
                1
            ], i = _a[0], j = _a[1];
            _lower = [
                _lower_sx,
                _base_sx
            ];
            _upper = [
                _upper_sx,
                _base_sx
            ];
            this._lower_sx = _lower[i];
            this._lower_sy = _lower[j];
            this._upper_sx = _upper[i];
            return this._upper_sy = _upper[j];
            var _a;
        };
        WhiskerView.prototype.render = function () {
            var angle, ctx, i, k, l, m, ref, ref1, ref2, results;
            if (!this.model.visible) {
                return;
            }
            this._map_data();
            ctx = this.plot_view.canvas_view.ctx;
            if (this.visuals.line.doit) {
                for (i = k = 0, ref = this._lower_sx.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                    this.visuals.line.set_vectorize(ctx, i);
                    ctx.beginPath();
                    ctx.moveTo(this._lower_sx[i], this._lower_sy[i]);
                    ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);
                    ctx.stroke();
                }
            }
            angle = this.model.dimension === 'height' ? 0 : Math.PI / 2;
            if (this.model.lower_head != null) {
                for (i = l = 0, ref1 = this._lower_sx.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                    ctx.save();
                    ctx.translate(this._lower_sx[i], this._lower_sy[i]);
                    ctx.rotate(angle + Math.PI);
                    this.model.lower_head.render(ctx, i);
                    ctx.restore();
                }
            }
            if (this.model.upper_head != null) {
                results = [];
                for (i = m = 0, ref2 = this._upper_sx.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
                    ctx.save();
                    ctx.translate(this._upper_sx[i], this._upper_sy[i]);
                    ctx.rotate(angle);
                    this.model.upper_head.render(ctx, i);
                    results.push(ctx.restore());
                }
                return results;
            }
        };
        return WhiskerView;
    }(annotation_1.AnnotationView);
    var Whisker = function (_super) {
        tslib_1.__extends(Whisker, _super);
        function Whisker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Whisker;
    }(annotation_1.Annotation);
    exports.Whisker = Whisker;
    ;
    Whisker.prototype.default_view = exports.WhiskerView;
    Whisker.prototype.type = 'Whisker';
    Whisker.mixins(['line']);
    Whisker.define({
        lower: [p.DistanceSpec],
        lower_head: [
            p.Instance,
            function () {
                return new arrow_head_1.TeeHead({
                    level: 'underlay',
                    size: 10
                });
            }
        ],
        upper: [p.DistanceSpec],
        upper_head: [
            p.Instance,
            function () {
                return new arrow_head_1.TeeHead({
                    level: 'underlay',
                    size: 10
                });
            }
        ],
        base: [p.DistanceSpec],
        dimension: [
            p.Dimension,
            'height'
        ],
        source: [
            p.Instance,
            function () {
                return new column_data_source_1.ColumnDataSource();
            }
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    Whisker.override({ level: 'underlay' });    
},
/*models/axes/axis*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var side_panel_1 = require(12    /* core/layout/side_panel */);
    var guide_renderer_1 = require(163    /* ../renderers/guide_renderer */);
    var renderer_1 = require(165    /* ../renderers/renderer */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    exports.AxisView = function (_super) {
        tslib_1.__extends(AxisView, _super);
        function AxisView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AxisView.prototype.render = function () {
            var ctx, extents, tick_coords;
            if (this.model.visible === false) {
                return;
            }
            extents = {
                tick: this._tick_extent(),
                tick_label: this._tick_label_extents(),
                axis_label: this._axis_label_extent()
            };
            tick_coords = this.model.tick_coords;
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            this._draw_rule(ctx, extents);
            this._draw_major_ticks(ctx, extents, tick_coords);
            this._draw_minor_ticks(ctx, extents, tick_coords);
            this._draw_major_labels(ctx, extents, tick_coords);
            this._draw_axis_label(ctx, extents, tick_coords);
            if (this._render != null) {
                this._render(ctx, extents, tick_coords);
            }
            return ctx.restore();
        };
        AxisView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.change, function () {
                return _this.plot_view.request_render();
            });
        };
        AxisView.prototype._get_size = function () {
            return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();
        };
        AxisView.prototype.get_size = function () {
            if (this.model.visible) {
                return Math.round(this._get_size());
            } else {
                return 0;
            }
        };
        // drawing sub functions -----------------------------------------------------
        AxisView.prototype._draw_rule = function (ctx, extents, tick_coords) {
            var i, k, nx, ny, ref, sx, sy, x, xoff, y, yoff;
            if (!this.visuals.axis_line.doit) {
                return;
            }
            _a = this.model.rule_coords, x = _a[0], y = _a[1];
            _b = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name), sx = _b[0], sy = _b[1];
            _c = this.model.normals, nx = _c[0], ny = _c[1];
            _d = this.model.offsets, xoff = _d[0], yoff = _d[1];
            this.visuals.axis_line.set_value(ctx);
            ctx.beginPath();
            ctx.moveTo(Math.round(sx[0] + nx * xoff), Math.round(sy[0] + ny * yoff));
            for (i = k = 1, ref = sx.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
                sx = Math.round(sx[i] + nx * xoff);
                sy = Math.round(sy[i] + ny * yoff);
                ctx.lineTo(sx, sy);
            }
            ctx.stroke();
            var _a, _b, _c, _d;
        };
        AxisView.prototype._draw_major_ticks = function (ctx, extents, tick_coords) {
            var tin, tout, visuals;
            tin = this.model.major_tick_in;
            tout = this.model.major_tick_out;
            visuals = this.visuals.major_tick_line;
            this._draw_ticks(ctx, tick_coords.major, tin, tout, visuals);
        };
        AxisView.prototype._draw_minor_ticks = function (ctx, extents, tick_coords) {
            var tin, tout, visuals;
            tin = this.model.minor_tick_in;
            tout = this.model.minor_tick_out;
            visuals = this.visuals.minor_tick_line;
            this._draw_ticks(ctx, tick_coords.minor, tin, tout, visuals);
        };
        AxisView.prototype._draw_major_labels = function (ctx, extents, tick_coords) {
            var coords, labels, orient, standoff, visuals;
            coords = tick_coords.major;
            labels = this.model.compute_labels(coords[this.model.dimension]);
            orient = this.model.major_label_orientation;
            standoff = extents.tick + this.model.major_label_standoff;
            visuals = this.visuals.major_label_text;
            this._draw_oriented_labels(ctx, labels, coords, orient, this.model.panel_side, standoff, visuals);
        };
        AxisView.prototype._draw_axis_label = function (ctx, extents, tick_coords) {
            var coords, standoff, sx, sy, visuals;
            if (this.model.axis_label == null || this.model.axis_label.length === 0) {
                return;
            }
            switch (this.model.panel.side) {
            case 'above':
                sx = this.model.panel._hcenter.value;
                sy = this.model.panel._bottom.value;
                break;
            case 'below':
                sx = this.model.panel._hcenter.value;
                sy = this.model.panel._top.value;
                break;
            case 'left':
                sx = this.model.panel._right.value;
                sy = this.model.panel._vcenter._value;
                break;
            case 'right':
                sx = this.model.panel._left.value;
                sy = this.model.panel._vcenter._value;
            }
            coords = [
                [sx],
                [sy]
            ];
            standoff = extents.tick + array_1.sum(extents.tick_label) + this.model.axis_label_standoff;
            visuals = this.visuals.axis_label_text;
            this._draw_oriented_labels(ctx, [this.model.axis_label], coords, 'parallel', this.model.panel_side, standoff, visuals, 'screen');
        };
        AxisView.prototype._draw_ticks = function (ctx, coords, tin, tout, visuals) {
            var i, k, nx, nxin, nxout, ny, nyin, nyout, ref, sx0, sx1, sxs, sy0, sy1, sys, x, xoff, y, yoff;
            if (!visuals.doit || coords.length === 0) {
                return;
            }
            x = coords[0], y = coords[1];
            _a = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name), sxs = _a[0], sys = _a[1];
            _b = this.model.normals, nx = _b[0], ny = _b[1];
            _c = this.model.offsets, xoff = _c[0], yoff = _c[1];
            _d = [
                nx * (xoff - tin),
                ny * (yoff - tin)
            ], nxin = _d[0], nyin = _d[1];
            _e = [
                nx * (xoff + tout),
                ny * (yoff + tout)
            ], nxout = _e[0], nyout = _e[1];
            visuals.set_value(ctx);
            for (i = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                sx0 = Math.round(sxs[i] + nxout);
                sy0 = Math.round(sys[i] + nyout);
                sx1 = Math.round(sxs[i] + nxin);
                sy1 = Math.round(sys[i] + nyin);
                ctx.beginPath();
                ctx.moveTo(sx0, sy0);
                ctx.lineTo(sx1, sy1);
                ctx.stroke();
            }
            var _a, _b, _c, _d, _e;
        };
        AxisView.prototype._draw_oriented_labels = function (ctx, labels, coords, orient, side, standoff, visuals, units) {
            if (units === void 0) {
                units = 'data';
            }
            var angle, dxs, dys, i, k, nx, nxd, ny, nyd, ref, sx, sxs, sy, sys, xoff, yoff;
            if (!visuals.doit || labels.length === 0) {
                return;
            }
            if (units === 'screen') {
                sxs = coords[0], sys = coords[1];
                _a = [
                    0,
                    0
                ], xoff = _a[0], yoff = _a[1];
            } else {
                dxs = coords[0], dys = coords[1];
                _b = this.plot_view.map_to_screen(dxs, dys, this.model.x_range_name, this.model.y_range_name), sxs = _b[0], sys = _b[1];
                _c = this.model.offsets, xoff = _c[0], yoff = _c[1];
            }
            _d = this.model.normals, nx = _d[0], ny = _d[1];
            nxd = nx * (xoff + standoff);
            nyd = ny * (yoff + standoff);
            visuals.set_value(ctx);
            this.model.panel.apply_label_text_heuristics(ctx, orient);
            if (types_1.isString(orient)) {
                angle = this.model.panel.get_label_angle_heuristic(orient);
            } else {
                angle = -orient;
            }
            for (i = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                sx = Math.round(sxs[i] + nxd);
                sy = Math.round(sys[i] + nyd);
                ctx.translate(sx, sy);
                ctx.rotate(angle);
                ctx.fillText(labels[i], 0, 0);
                ctx.rotate(-angle);
                ctx.translate(-sx, -sy);
            }
            var _a, _b, _c, _d;
        };
        // extents sub functions -----------------------------------------------------
        AxisView.prototype._axis_label_extent = function () {
            var standoff, visuals;
            if (this.model.axis_label == null || this.model.axis_label === '') {
                return 0;
            }
            standoff = this.model.axis_label_standoff;
            visuals = this.visuals.axis_label_text;
            return this._oriented_labels_extent([this.model.axis_label], 'parallel', this.model.panel_side, standoff, visuals);
        };
        AxisView.prototype._tick_extent = function () {
            return this.model.major_tick_out;
        };
        AxisView.prototype._tick_label_extent = function () {
            return array_1.sum(this._tick_label_extents());
        };
        AxisView.prototype._tick_label_extents = function () {
            var coords, labels, orient, standoff, visuals;
            coords = this.model.tick_coords.major;
            labels = this.model.compute_labels(coords[this.model.dimension]);
            orient = this.model.major_label_orientation;
            standoff = this.model.major_label_standoff;
            visuals = this.visuals.major_label_text;
            return [this._oriented_labels_extent(labels, orient, this.model.panel_side, standoff, visuals)];
        };
        AxisView.prototype._tick_label_extent = function () {
            return array_1.sum(this._tick_label_extents());
        };
        AxisView.prototype._oriented_labels_extent = function (labels, orient, side, standoff, visuals) {
            var angle, c, ctx, extent, h, hscale, i, k, ref, s, val, w;
            if (labels.length === 0) {
                return 0;
            }
            ctx = this.plot_view.canvas_view.ctx;
            visuals.set_value(ctx);
            if (types_1.isString(orient)) {
                hscale = 1;
                angle = this.model.panel.get_label_angle_heuristic(orient);
            } else {
                hscale = 2;
                angle = -orient;
            }
            angle = Math.abs(angle);
            c = Math.cos(angle);
            s = Math.sin(angle);
            extent = 0;
            for (i = k = 0, ref = labels.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                w = ctx.measureText(labels[i]).width * 1.1;
                h = ctx.measureText(labels[i]).ascent * 0.9;
                if (side === 'above' || side === 'below') {
                    val = w * s + h / hscale * c;
                } else {
                    val = w * c + h / hscale * s;
                }
                // update extent if current value is larger
                if (val > extent) {
                    extent = val;
                }
            }
            // only apply the standoff if we already have non-zero extent
            if (extent > 0) {
                extent += standoff;
            }
            return extent;
        };
        return AxisView;
    }(renderer_1.RendererView);
    var Axis = function (_super) {
        tslib_1.__extends(Axis, _super);
        function Axis() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Axis.prototype.compute_labels = function (ticks) {
            var i, k, labels, ref;
            labels = this.formatter.doFormat(ticks, this);
            for (i = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                if (ticks[i] in this.major_label_overrides) {
                    labels[i] = this.major_label_overrides[ticks[i]];
                }
            }
            return labels;
        };
        Axis.prototype.label_info = function (coords) {
            var info, orient;
            orient = this.major_label_orientation;
            info = {
                dim: this.dimension,
                coords: coords,
                side: this.panel_side,
                orient: orient,
                standoff: this.major_label_standoff
            };
            return info;
        };
        Axis.prototype.add_panel = function (side) {
            this.panel = new side_panel_1.SidePanel({ side: side });
            this.panel.attach_document(this.document);
            return this.panel_side = side;
        };
        Axis.prototype._offsets = function () {
            var frame, side, xoff, yoff;
            side = this.panel_side;
            _a = [
                0,
                0
            ], xoff = _a[0], yoff = _a[1];
            frame = this.plot.plot_canvas.frame;
            switch (side) {
            case 'below':
                yoff = Math.abs(this.panel._top.value - frame._bottom.value);
                break;
            case 'above':
                yoff = Math.abs(this.panel._bottom.value - frame._top.value);
                break;
            case 'right':
                xoff = Math.abs(this.panel._left.value - frame._right.value);
                break;
            case 'left':
                xoff = Math.abs(this.panel._right.value - frame._left.value);
            }
            return [
                xoff,
                yoff
            ];
            var _a;
        };
        Axis.prototype._ranges = function () {
            var frame, i, j, ranges;
            i = this.dimension;
            j = (i + 1) % 2;
            frame = this.plot.plot_canvas.frame;
            ranges = [
                frame.x_ranges[this.x_range_name],
                frame.y_ranges[this.y_range_name]
            ];
            return [
                ranges[i],
                ranges[j]
            ];
        };
        Axis.prototype._computed_bounds = function () {
            var cross_range, end, range, range_bounds, ref, start, user_bounds;
            _a = this.ranges, range = _a[0], cross_range = _a[1];
            user_bounds = (ref = this.bounds) != null ? ref : 'auto';
            range_bounds = [
                range.min,
                range.max
            ];
            if (user_bounds === 'auto') {
                return range_bounds;
            }
            if (types_1.isArray(user_bounds)) {
                if (Math.abs(user_bounds[0] - user_bounds[1]) > Math.abs(range_bounds[0] - range_bounds[1])) {
                    start = Math.max(Math.min(user_bounds[0], user_bounds[1]), range_bounds[0]);
                    end = Math.min(Math.max(user_bounds[0], user_bounds[1]), range_bounds[1]);
                } else {
                    start = Math.min(user_bounds[0], user_bounds[1]);
                    end = Math.max(user_bounds[0], user_bounds[1]);
                }
                return [
                    start,
                    end
                ];
            }
            logging_1.logger.error('user bounds \'' + user_bounds + '\' not understood');
            return null;
            var _a;
        };
        Axis.prototype._rule_coords = function () {
            var coords, cross_range, end, i, j, range, start, xs, ys;
            i = this.dimension;
            j = (i + 1) % 2;
            _a = this.ranges, range = _a[0], cross_range = _a[1];
            _b = this.computed_bounds, start = _b[0], end = _b[1];
            xs = new Array(2);
            ys = new Array(2);
            coords = [
                xs,
                ys
            ];
            coords[i][0] = Math.max(start, range.min);
            coords[i][1] = Math.min(end, range.max);
            if (coords[i][0] > coords[i][1]) {
                coords[i][0] = coords[i][1] = 0 / 0;
            }
            coords[j][0] = this.loc;
            coords[j][1] = this.loc;
            return coords;
            var _a, _b;
        };
        Axis.prototype._tick_coords = function () {
            var coords, cross_range, end, i, ii, j, k, l, majors, minor_coords, minor_xs, minor_ys, minors, range, range_max, range_min, ref, ref1, start, ticks, xs, ys;
            i = this.dimension;
            j = (i + 1) % 2;
            _a = this.ranges, range = _a[0], cross_range = _a[1];
            _b = this.computed_bounds, start = _b[0], end = _b[1];
            ticks = this.ticker.get_ticks(start, end, range, this.loc, {});
            majors = ticks.major;
            minors = ticks.minor;
            xs = [];
            ys = [];
            coords = [
                xs,
                ys
            ];
            minor_xs = [];
            minor_ys = [];
            minor_coords = [
                minor_xs,
                minor_ys
            ];
            _c = [
                range.min,
                range.max
            ], range_min = _c[0], range_max = _c[1];
            for (ii = k = 0, ref = majors.length; 0 <= ref ? k < ref : k > ref; ii = 0 <= ref ? ++k : --k) {
                if (majors[ii] < range_min || majors[ii] > range_max) {
                    continue;
                }
                coords[i].push(majors[ii]);
                coords[j].push(this.loc);
            }
            for (ii = l = 0, ref1 = minors.length; 0 <= ref1 ? l < ref1 : l > ref1; ii = 0 <= ref1 ? ++l : --l) {
                if (minors[ii] < range_min || minors[ii] > range_max) {
                    continue;
                }
                minor_coords[i].push(minors[ii]);
                minor_coords[j].push(this.loc);
            }
            return {
                'major': coords,
                'minor': minor_coords
            };
            var _a, _b, _c;
        };
        Axis.prototype._get_loc = function () {
            var cend, cross_range, cstart, range, side;
            _a = this.ranges, range = _a[0], cross_range = _a[1];
            cstart = cross_range.start;
            cend = cross_range.end;
            side = this.panel_side;
            switch (side) {
            case 'left':
            case 'below':
                return cross_range.start;
            case 'right':
            case 'above':
                return cross_range.end;
            }
            var _a;
        };
        return Axis;
    }(guide_renderer_1.GuideRenderer);
    exports.Axis = Axis;
    ;
    Axis.prototype.default_view = exports.AxisView;
    Axis.prototype.type = 'Axis';
    Axis.mixins([
        'line:axis_',
        'line:major_tick_',
        'line:minor_tick_',
        'text:major_label_',
        'text:axis_label_'
    ]);
    Axis.define({
        bounds: [
            p.Any,
            'auto'    // TODO (bev)
        ],
        ticker: [
            p.Instance,
            null
        ],
        formatter: [
            p.Instance,
            null
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        axis_label: [
            p.String,
            ''
        ],
        axis_label_standoff: [
            p.Int,
            5
        ],
        major_label_standoff: [
            p.Int,
            5
        ],
        major_label_orientation: [
            p.Any,
            'horizontal'    // TODO: p.Orientation | p.Number
        ],
        major_label_overrides: [
            p.Any,
            {}
        ],
        major_tick_in: [
            p.Number,
            2
        ],
        major_tick_out: [
            p.Number,
            6
        ],
        minor_tick_in: [
            p.Number,
            0
        ],
        minor_tick_out: [
            p.Number,
            4
        ]
    });
    Axis.override({
        axis_line_color: 'black',
        major_tick_line_color: 'black',
        minor_tick_line_color: 'black',
        major_label_text_font_size: '8pt',
        major_label_text_align: 'center',
        major_label_text_baseline: 'alphabetic',
        axis_label_text_font_size: '10pt',
        axis_label_text_font_style: 'italic'
    });
    Axis.internal({ panel_side: [p.Any] });
    Axis.getters({
        computed_bounds: function () {
            return this._computed_bounds();
        },
        rule_coords: function () {
            return this._rule_coords();
        },
        tick_coords: function () {
            return this._tick_coords();
        },
        ranges: function () {
            return this._ranges();
        },
        normals: function () {
            return this.panel._normals;
        },
        dimension: function () {
            return this.panel._dim;
        },
        offsets: function () {
            return this._offsets();
        },
        loc: function () {
            return this._get_loc();
        }
    });    
},
/*models/axes/categorical_axis*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var axis_1 = require(69    /* ./axis */);
    var categorical_tick_formatter_1 = require(92    /* ../formatters/categorical_tick_formatter */);
    var categorical_ticker_1 = require(181    /* ../tickers/categorical_ticker */);
    exports.CategoricalAxisView = function (_super) {
        tslib_1.__extends(CategoricalAxisView, _super);
        function CategoricalAxisView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CategoricalAxisView.prototype._render = function (ctx, extents, tick_coords) {
            return this._draw_group_separators(ctx, extents, tick_coords);
        };
        CategoricalAxisView.prototype._draw_group_separators = function (ctx, extents, tick_coords) {
            var alt, coords, cross_range, dim, end, first, i, ind, j, k, l, last, loc, pt, range, ref, ref1, ref2, start, tex, ticks;
            _a = this.model.ranges, range = _a[0], cross_range = _a[1];
            _b = this.model.computed_bounds, start = _b[0], end = _b[1];
            loc = this.model.loc;
            ticks = this.model.ticker.get_ticks(start, end, range, loc, {});
            _c = this.model.ranges, range = _c[0], cross_range = _c[1];
            if (!range.tops || range.tops.length < 2 || !this.visuals.separator_line.doit) {
                return;
            }
            dim = this.model.dimension;
            alt = (dim + 1) % 2;
            coords = [
                [],
                []
            ];
            ind = 0;
            for (i = k = 0, ref = range.tops.length - 1; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                for (j = l = ref1 = ind, ref2 = range.factors.length; ref1 <= ref2 ? l < ref2 : l > ref2; j = ref1 <= ref2 ? ++l : --l) {
                    if (range.factors[j][0] === range.tops[i + 1]) {
                        _d = [
                            range.factors[j - 1],
                            range.factors[j]
                        ], first = _d[0], last = _d[1];
                        ind = j;
                        break;
                    }
                }
                pt = (range.synthetic(first) + range.synthetic(last)) / 2;
                if (pt > start && pt < end) {
                    coords[dim].push(pt);
                    coords[alt].push(this.model.loc);
                }
            }
            tex = this._tick_label_extent();
            this._draw_ticks(ctx, coords, -3, tex - 6, this.visuals.separator_line);
            var _a, _b, _c, _d;
        };
        CategoricalAxisView.prototype._draw_major_labels = function (ctx, extents, tick_coords) {
            var alt, coords, dim, i, info, k, labels, loc, orient, ref, standoff, visuals;
            info = this._get_factor_info();
            loc = this.model.loc;
            dim = this.model.dimension;
            alt = (dim + 1) % 2;
            standoff = extents.tick + this.model.major_label_standoff;
            for (i = k = 0, ref = info.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                _a = info[i], labels = _a[0], coords = _a[1], orient = _a[2], visuals = _a[3];
                this._draw_oriented_labels(ctx, labels, coords, orient, this.model.panel_side, standoff, visuals);
                standoff += extents.tick_label[i];
            }
            var _a;
        };
        CategoricalAxisView.prototype._tick_label_extents = function () {
            var dim_coords, extent, extents, info, k, labels, len, orient, visuals;
            info = this._get_factor_info();
            extents = [];
            for (k = 0, len = info.length; k < len; k++) {
                _a = info[k], labels = _a[0], dim_coords = _a[1], orient = _a[2], visuals = _a[3];
                extent = this._oriented_labels_extent(labels, orient, this.model.panel_side, this.model.major_label_standoff, visuals);
                extents.push(extent);
            }
            return extents;
            var _a;
        };
        CategoricalAxisView.prototype._get_factor_info = function () {
            var coords, cross_range, end, info, labels, loc, mid_labels, range, start, ticks, x;
            _a = this.model.ranges, range = _a[0], cross_range = _a[1];
            _b = this.model.computed_bounds, start = _b[0], end = _b[1];
            loc = this.model.loc;
            ticks = this.model.ticker.get_ticks(start, end, range, loc, {});
            coords = this.model.tick_coords;
            info = [];
            if (range.levels === 1) {
                labels = this.model.formatter.doFormat(ticks.major, this);
                info.push([
                    labels,
                    coords.major,
                    this.model.major_label_orientation,
                    this.visuals.major_label_text
                ]);
            } else if (range.levels === 2) {
                labels = this.model.formatter.doFormat(function () {
                    var k, len, ref, results;
                    ref = ticks.major;
                    results = [];
                    for (k = 0, len = ref.length; k < len; k++) {
                        x = ref[k];
                        results.push(x[1]);
                    }
                    return results;
                }(), this);
                info.push([
                    labels,
                    coords.major,
                    this.model.major_label_orientation,
                    this.visuals.major_label_text
                ]);
                info.push([
                    ticks.tops,
                    coords.tops,
                    'parallel',
                    this.visuals.group_text
                ]);
            } else if (range.levels === 3) {
                labels = this.model.formatter.doFormat(function () {
                    var k, len, ref, results;
                    ref = ticks.major;
                    results = [];
                    for (k = 0, len = ref.length; k < len; k++) {
                        x = ref[k];
                        results.push(x[2]);
                    }
                    return results;
                }(), this);
                mid_labels = function () {
                    var k, len, ref, results;
                    ref = ticks.mids;
                    results = [];
                    for (k = 0, len = ref.length; k < len; k++) {
                        x = ref[k];
                        results.push(x[1]);
                    }
                    return results;
                }();
                info.push([
                    labels,
                    coords.major,
                    this.model.major_label_orientation,
                    this.visuals.major_label_text
                ]);
                info.push([
                    mid_labels,
                    coords.mids,
                    'parallel',
                    this.visuals.subgroup_text
                ]);
                info.push([
                    ticks.tops,
                    coords.tops,
                    'parallel',
                    this.visuals.group_text
                ]);
            }
            return info;
            var _a, _b;
        };
        return CategoricalAxisView;
    }(axis_1.AxisView);
    var CategoricalAxis = function (_super) {
        tslib_1.__extends(CategoricalAxis, _super);
        function CategoricalAxis() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CategoricalAxis.prototype._tick_coords = function () {
            var coords, cross_range, end, i, j, range, start, ticks, x;
            i = this.dimension;
            j = (i + 1) % 2;
            _a = this.ranges, range = _a[0], cross_range = _a[1];
            _b = this.computed_bounds, start = _b[0], end = _b[1];
            ticks = this.ticker.get_ticks(start, end, range, this.loc, {});
            coords = {
                major: [
                    [],
                    []
                ],
                mids: [
                    [],
                    []
                ],
                tops: [
                    [],
                    []
                ],
                minor: []
            };
            coords.major[i] = ticks.major;
            coords.major[j] = function () {
                var k, len, ref, results;
                ref = ticks.major;
                results = [];
                for (k = 0, len = ref.length; k < len; k++) {
                    x = ref[k];
                    results.push(this.loc);
                }
                return results;
            }.call(this);
            if (range.levels === 3) {
                coords.mids[i] = ticks.mids;
                coords.mids[j] = function () {
                    var k, len, ref, results;
                    ref = ticks.mids;
                    results = [];
                    for (k = 0, len = ref.length; k < len; k++) {
                        x = ref[k];
                        results.push(this.loc);
                    }
                    return results;
                }.call(this);
            }
            if (range.levels > 1) {
                coords.tops[i] = ticks.tops;
                coords.tops[j] = function () {
                    var k, len, ref, results;
                    ref = ticks.tops;
                    results = [];
                    for (k = 0, len = ref.length; k < len; k++) {
                        x = ref[k];
                        results.push(this.loc);
                    }
                    return results;
                }.call(this);
            }
            return coords;
            var _a, _b;
        };
        return CategoricalAxis;
    }(axis_1.Axis);
    exports.CategoricalAxis = CategoricalAxis;
    ;
    CategoricalAxis.prototype.default_view = exports.CategoricalAxisView;
    CategoricalAxis.prototype.type = 'CategoricalAxis';
    CategoricalAxis.mixins([
        'line:separator_',
        'text:group_',
        'text:subgroup_'
    ]);
    CategoricalAxis.override({
        ticker: function () {
            return new categorical_ticker_1.CategoricalTicker();
        },
        formatter: function () {
            return new categorical_tick_formatter_1.CategoricalTickFormatter();
        },
        separator_line_color: 'lightgrey',
        separator_line_width: 2,
        group_text_font_style: 'bold',
        group_text_font_size: '8pt',
        group_text_color: 'grey',
        subgroup_text_font_style: 'bold',
        subgroup_text_font_size: '8pt'
    });    
},
/*models/axes/continuous_axis*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var axis_1 = require(69    /* ./axis */);
    var ContinuousAxis = function (_super) {
        tslib_1.__extends(ContinuousAxis, _super);
        function ContinuousAxis() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ContinuousAxis;
    }(axis_1.Axis);
    exports.ContinuousAxis = ContinuousAxis;
    ;
    ContinuousAxis.prototype.type = 'ContinuousAxis';    
},
/*models/axes/datetime_axis*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var linear_axis_1 = require(74    /* ./linear_axis */);
    var datetime_tick_formatter_1 = require(93    /* ../formatters/datetime_tick_formatter */);
    var datetime_ticker_1 = require(184    /* ../tickers/datetime_ticker */);
    exports.DatetimeAxisView = function (_super) {
        tslib_1.__extends(DatetimeAxisView, _super);
        function DatetimeAxisView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DatetimeAxisView;
    }(linear_axis_1.LinearAxisView);
    var DatetimeAxis = function (_super) {
        tslib_1.__extends(DatetimeAxis, _super);
        function DatetimeAxis() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DatetimeAxis;
    }(linear_axis_1.LinearAxis);
    exports.DatetimeAxis = DatetimeAxis;
    ;
    DatetimeAxis.prototype.default_view = exports.DatetimeAxisView;
    DatetimeAxis.prototype.type = 'DatetimeAxis';
    DatetimeAxis.override({
        ticker: function () {
            return new datetime_ticker_1.DatetimeTicker();
        },
        formatter: function () {
            return new datetime_tick_formatter_1.DatetimeTickFormatter();
        }
    });    
},
/*models/axes/index*/
function _(require, module, exports) {
    var axis_1 = require(69    /* ./axis */);
    exports.Axis = axis_1.Axis;
    var categorical_axis_1 = require(70    /* ./categorical_axis */);
    exports.CategoricalAxis = categorical_axis_1.CategoricalAxis;
    var continuous_axis_1 = require(71    /* ./continuous_axis */);
    exports.ContinuousAxis = continuous_axis_1.ContinuousAxis;
    var datetime_axis_1 = require(72    /* ./datetime_axis */);
    exports.DatetimeAxis = datetime_axis_1.DatetimeAxis;
    var linear_axis_1 = require(74    /* ./linear_axis */);
    exports.LinearAxis = linear_axis_1.LinearAxis;
    var log_axis_1 = require(75    /* ./log_axis */);
    exports.LogAxis = log_axis_1.LogAxis;    
},
/*models/axes/linear_axis*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var axis_1 = require(69    /* ./axis */);
    var continuous_axis_1 = require(71    /* ./continuous_axis */);
    var basic_tick_formatter_1 = require(91    /* ../formatters/basic_tick_formatter */);
    var basic_ticker_1 = require(180    /* ../tickers/basic_ticker */);
    exports.LinearAxisView = function (_super) {
        tslib_1.__extends(LinearAxisView, _super);
        function LinearAxisView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LinearAxisView;
    }(axis_1.AxisView);
    var LinearAxis = function (_super) {
        tslib_1.__extends(LinearAxis, _super);
        function LinearAxis() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LinearAxis;
    }(continuous_axis_1.ContinuousAxis);
    exports.LinearAxis = LinearAxis;
    ;
    LinearAxis.prototype.default_view = exports.LinearAxisView;
    LinearAxis.prototype.type = 'LinearAxis';
    LinearAxis.override({
        ticker: function () {
            return new basic_ticker_1.BasicTicker();
        },
        formatter: function () {
            return new basic_tick_formatter_1.BasicTickFormatter();
        }
    });    
},
/*models/axes/log_axis*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var axis_1 = require(69    /* ./axis */);
    var continuous_axis_1 = require(71    /* ./continuous_axis */);
    var log_tick_formatter_1 = require(96    /* ../formatters/log_tick_formatter */);
    var log_ticker_1 = require(188    /* ../tickers/log_ticker */);
    exports.LogAxisView = function (_super) {
        tslib_1.__extends(LogAxisView, _super);
        function LogAxisView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LogAxisView;
    }(axis_1.AxisView);
    var LogAxis = function (_super) {
        tslib_1.__extends(LogAxis, _super);
        function LogAxis() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LogAxis;
    }(continuous_axis_1.ContinuousAxis);
    exports.LogAxis = LogAxis;
    ;
    LogAxis.prototype.default_view = exports.LogAxisView;
    LogAxis.prototype.type = 'LogAxis';
    LogAxis.override({
        ticker: function () {
            return new log_ticker_1.LogTicker();
        },
        formatter: function () {
            return new log_tick_formatter_1.LogTickFormatter();
        }
    });    
},
/*models/callbacks/customjs*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var p = require(15    /* core/properties */);
    var object_1 = require(30    /* core/util/object */);
    var model_1 = require(50    /* ../../model */);
    var CustomJS = function (_super) {
        tslib_1.__extends(CustomJS, _super);
        function CustomJS() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomJS.prototype.execute = function (cb_obj, cb_data) {
            return this.func.apply(cb_obj, this.values.concat(cb_obj, cb_data, require, {}));
        };
        CustomJS.prototype._make_values = function () {
            return object_1.values(this.args);
        };
        CustomJS.prototype._make_func = function () {
            // this relies on Object.keys(args) and values(args) returning keys and values
            // in the same order
            return new (Function.bind.apply(Function, [void 0].concat(Object.keys(this.args), [
                'cb_obj',
                'cb_data',
                'require',
                'exports',
                this.code
            ])))();
        };
        return CustomJS;
    }(model_1.Model);
    exports.CustomJS = CustomJS;
    ;
    CustomJS.prototype.type = 'CustomJS';
    CustomJS.define({
        args: [
            p.Any,
            {}
        ],
        code: [
            p.String,
            ''
        ]
    });
    CustomJS.getters({
        values: function () {
            return this._make_values();
        },
        func: function () {
            return this._make_func();
        }
    });    
},
/*models/callbacks/index*/
function _(require, module, exports) {
    var customjs_1 = require(76    /* ./customjs */);
    exports.CustomJS = customjs_1.CustomJS;
    var open_url_1 = require(78    /* ./open_url */);
    exports.OpenURL = open_url_1.OpenURL;    
},
/*models/callbacks/open_url*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var p = require(15    /* core/properties */);
    var selection_1 = require(34    /* core/util/selection */);
    var templating_1 = require(39    /* core/util/templating */);
    var OpenURL = function (_super) {
        tslib_1.__extends(OpenURL, _super);
        function OpenURL() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OpenURL.prototype.execute = function (cb_obj, cb_data) {
            var i, j, len, ref, url;
            ref = selection_1.get_indices(cb_data.source);
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                url = templating_1.replace_placeholders(this.url, cb_data.source, i);
                window.open(url);
            }
            return null;
        };
        return OpenURL;
    }(model_1.Model);
    exports.OpenURL = OpenURL;
    ;
    OpenURL.prototype.type = 'OpenURL';
    OpenURL.define({
        url: [
            p.String,
            'http://'    // TODO (bev) better type
        ]
    });    
},
/*models/canvas/canvas*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var layout_canvas_1 = require(11    /* core/layout/layout_canvas */);
    var dom_view_1 = require(6    /* core/dom_view */);
    var solver_1 = require(13    /* core/layout/solver */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var dom_1 = require(5    /* core/dom */);
    var canvas_1 = require(25    /* core/util/canvas */);
    var canvas2svg = require(249    /* canvas2svg */);
    // fixes up a problem with some versions of IE11
    // ref: http://stackoverflow.com/questions/22062313/imagedata-set-in-internetexplorer
    if (window.CanvasPixelArray != null) {
        CanvasPixelArray.prototype.set = function (arr) {
            var i, j, ref, results;
            results = [];
            for (i = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(this[i] = arr[i]);
            }
            return results;
        };
    }
    var CanvasView = function (_super) {
        tslib_1.__extends(CanvasView, _super);
        function CanvasView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CanvasView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.map_el = this.model.map ? this.el.appendChild(dom_1.div({ class: 'bk-canvas-map' })) : null;
            switch (this.model.output_backend) {
            case 'canvas':
            case 'webgl':
                this.canvas_el = this.el.appendChild(dom_1.canvas({ class: 'bk-canvas' }));
                this._ctx = this.canvas_el.getContext('2d');
                break;
            case 'svg':
                this._ctx = new canvas2svg();
                this.canvas_el = this.el.appendChild(this._ctx.getSvg());
            }
            this.overlays_el = this.el.appendChild(dom_1.div({ class: 'bk-canvas-overlays' }));
            this.events_el = this.el.appendChild(dom_1.div({ class: 'bk-canvas-events' }));
            this.ctx = this.get_ctx();
            // work around canvas incompatibilities
            canvas_1.fixup_ctx(this.ctx);
            return logging_1.logger.debug('CanvasView initialized');
        };
        // Method exists so that context can be stubbed in unit tests
        CanvasView.prototype.get_ctx = function () {
            return this._ctx;
        };
        CanvasView.prototype.get_canvas_element = function () {
            return this.canvas_el;
        };
        CanvasView.prototype.prepare_canvas = function () {
            var height, pixel_ratio, width;
            // Ensure canvas has the correct size, taking HIDPI into account
            width = this.model._width.value;
            height = this.model._height.value;
            this.el.style.width = width + 'px';
            this.el.style.height = height + 'px';
            pixel_ratio = canvas_1.get_scale_ratio(this.ctx, this.model.use_hidpi, this.model.output_backend);
            this.model.pixel_ratio = pixel_ratio;
            this.canvas_el.style.width = width + 'px';
            this.canvas_el.style.height = height + 'px';
            this.canvas_el.setAttribute('width', width * pixel_ratio);
            this.canvas_el.setAttribute('height', height * pixel_ratio);
            return logging_1.logger.debug('Rendering CanvasView with width: ' + width + ', height: ' + height + ', pixel ratio: ' + pixel_ratio);
        };
        CanvasView.prototype.set_dims = function (_a) {
            var width = _a[0], height = _a[1];
            // XXX: for whatever reason we need to protect against those nonsense values,
            //      that appear in the middle of updating layout. Otherwise we would get
            //      all possible errors from the layout solver.
            if (width === 0 || height === 0) {
                return;
            }
            if (width !== this.model._width.value) {
                if (this._width_constraint != null && this.solver.has_constraint(this._width_constraint)) {
                    this.solver.remove_constraint(this._width_constraint);
                }
                this._width_constraint = solver_1.EQ(this.model._width, -width);
                this.solver.add_constraint(this._width_constraint);
            }
            if (height !== this.model._height.value) {
                if (this._height_constraint != null && this.solver.has_constraint(this._height_constraint)) {
                    this.solver.remove_constraint(this._height_constraint);
                }
                this._height_constraint = solver_1.EQ(this.model._height, -height);
                this.solver.add_constraint(this._height_constraint);
            }
            return this.solver.update_variables();
        };
        return CanvasView;
    }(dom_view_1.DOMView);
    exports.CanvasView = CanvasView;
    ;
    CanvasView.prototype.className = 'bk-canvas-wrapper';
    var Canvas = function (_super) {
        tslib_1.__extends(Canvas, _super);
        function Canvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Canvas;
    }(layout_canvas_1.LayoutCanvas);
    exports.Canvas = Canvas;
    ;
    Canvas.prototype.type = 'Canvas';
    Canvas.prototype.default_view = CanvasView;
    Canvas.internal({
        map: [
            p.Boolean,
            false
        ],
        use_hidpi: [
            p.Boolean,
            true
        ],
        pixel_ratio: [
            p.Number,
            1
        ],
        output_backend: [
            p.OutputBackend,
            'canvas'
        ]
    });
    Canvas.getters({
        panel: function () {
            return this;
        }
    });    
},
/*models/canvas/cartesian_frame*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var categorical_scale_1 = require(166    /* ../scales/categorical_scale */);
    var linear_scale_1 = require(168    /* ../scales/linear_scale */);
    var log_scale_1 = require(169    /* ../scales/log_scale */);
    var range1d_1 = require(160    /* ../ranges/range1d */);
    var data_range1d_1 = require(156    /* ../ranges/data_range1d */);
    var factor_range_1 = require(157    /* ../ranges/factor_range */);
    var layout_canvas_1 = require(11    /* core/layout/layout_canvas */);
    var p = require(15    /* core/properties */);
    var CartesianFrame = function (_super) {
        tslib_1.__extends(CartesianFrame, _super);
        function CartesianFrame() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CartesianFrame.prototype.initialize = function (attrs, options) {
            var _this = this;
            _super.prototype.initialize.call(this, attrs, options);
            this._configure_scales();
            return this.connect(this.change, function () {
                return _this._configure_scales();
            });
        };
        CartesianFrame.prototype.get_editables = function () {
            return _super.prototype.get_editables.call(this).concat([
                this._width,
                this._height
            ]);
        };
        CartesianFrame.prototype.map_to_screen = function (x, y, x_name, y_name) {
            if (x_name === void 0) {
                x_name = 'default';
            }
            if (y_name === void 0) {
                y_name = 'default';
            }
            var sx, sy;
            sx = this.xscales[x_name].v_compute(x);
            sy = this.yscales[y_name].v_compute(y);
            return [
                sx,
                sy
            ];
        };
        CartesianFrame.prototype._get_ranges = function (range, extra_ranges) {
            var extra_range, name, ranges;
            ranges = {};
            ranges['default'] = range;
            if (extra_ranges != null) {
                for (name in extra_ranges) {
                    extra_range = extra_ranges[name];
                    ranges[name] = extra_range;
                }
            }
            return ranges;
        };
        CartesianFrame.prototype._get_scales = function (scale, ranges, frame_range) {
            var name, range, s, scales;
            scales = {};
            for (name in ranges) {
                range = ranges[name];
                if (range instanceof data_range1d_1.DataRange1d || range instanceof range1d_1.Range1d) {
                    if (!(scale instanceof log_scale_1.LogScale) && !(scale instanceof linear_scale_1.LinearScale)) {
                        throw new Error('Range ' + range.type + ' is incompatible is Scale ' + scale.type);
                    }
                    // special case because CategoricalScale is a subclass of LinearScale, should be removed in future
                    if (scale instanceof categorical_scale_1.CategoricalScale) {
                        throw new Error('Range ' + range.type + ' is incompatible is Scale ' + scale.type);
                    }
                }
                if (range instanceof factor_range_1.FactorRange) {
                    if (!(scale instanceof categorical_scale_1.CategoricalScale)) {
                        throw new Error('Range ' + range.type + ' is incompatible is Scale ' + scale.type);
                    }
                }
                if (scale instanceof log_scale_1.LogScale && range instanceof data_range1d_1.DataRange1d) {
                    range.scale_hint = 'log';
                }
                s = scale.clone();
                s.setv({
                    source_range: range,
                    target_range: frame_range
                });
                scales[name] = s;
            }
            return scales;
        };
        CartesianFrame.prototype._configure_frame_ranges = function () {
            // data to/from screen space transform (left-bottom <-> left-top origin)
            this._h_target = new range1d_1.Range1d({
                start: this._left.value,
                end: this._right.value
            });
            return this._v_target = new range1d_1.Range1d({
                start: this._bottom._value,
                end: this._top.value
            });
        };
        CartesianFrame.prototype._configure_scales = function () {
            this._configure_frame_ranges();
            this._x_ranges = this._get_ranges(this.x_range, this.extra_x_ranges);
            this._y_ranges = this._get_ranges(this.y_range, this.extra_y_ranges);
            this._xscales = this._get_scales(this.x_scale, this._x_ranges, this._h_target);
            return this._yscales = this._get_scales(this.y_scale, this._y_ranges, this._v_target);
        };
        CartesianFrame.prototype._update_scales = function () {
            var name, ref, ref1, scale;
            this._configure_frame_ranges();
            ref = this._xscales;
            for (name in ref) {
                scale = ref[name];
                scale.target_range = this._h_target;
            }
            ref1 = this._yscales;
            for (name in ref1) {
                scale = ref1[name];
                scale.target_range = this._v_target;
            }
            return null;
        };
        Object.defineProperty(CartesianFrame.prototype, 'x_ranges', {
            get: function () {
                return this._x_ranges;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CartesianFrame.prototype, 'y_ranges', {
            get: function () {
                return this._y_ranges;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CartesianFrame.prototype, 'xscales', {
            get: function () {
                return this._xscales;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CartesianFrame.prototype, 'yscales', {
            get: function () {
                return this._yscales;
            },
            enumerable: true,
            configurable: true
        });
        ;
        return CartesianFrame;
    }(layout_canvas_1.LayoutCanvas);
    exports.CartesianFrame = CartesianFrame;
    ;
    CartesianFrame.prototype.type = 'CartesianFrame';
    CartesianFrame.getters({
        panel: function () {
            return this;
        }
    });
    CartesianFrame.internal({
        extra_x_ranges: [
            p.Any,
            {}
        ],
        extra_y_ranges: [
            p.Any,
            {}
        ],
        x_range: [p.Instance],
        y_range: [p.Instance],
        x_scale: [p.Instance],
        y_scale: [p.Instance]
    });    
},
/*models/canvas/index*/
function _(require, module, exports) {
    var canvas_1 = require(79    /* ./canvas */);
    exports.Canvas = canvas_1.Canvas;
    var cartesian_frame_1 = require(80    /* ./cartesian_frame */);
    exports.CartesianFrame = cartesian_frame_1.CartesianFrame;    
},
/*models/expressions/expression*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    exports.Expression = function (_super) {
        tslib_1.__extends(Expression, _super);
        function Expression() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Expression.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._connected = {};
            return this._result = {};
        };
        Expression.prototype._v_compute = function (source) {
            if (this._connected[source.id] == null) {
                this.connect(source.change, function () {
                    return this._result[source.id] = null;
                });
                this._connected[source.id] = true;
            }
            if (this._result[source.id] != null) {
                return this._result[source.id];
            }
            this._result[source.id] = this.v_compute(source);
            return this._result[source.id];
        };
        return Expression;
    }(model_1.Model);    
},
/*models/expressions/index*/
function _(require, module, exports) {
    var expression_1 = require(82    /* ./expression */);
    exports.Expression = expression_1.Expression;
    var stack_1 = require(84    /* ./stack */);
    exports.Stack = stack_1.Stack;    
},
/*models/expressions/stack*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var expression_1 = require(82    /* ./expression */);
    var p = require(15    /* core/properties */);
    var Stack = function (_super) {
        tslib_1.__extends(Stack, _super);
        function Stack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Stack.prototype.v_compute = function (source) {
            var f, i, j, k, len, len1, ref, ref1, result, x;
            result = new Float64Array(source.get_length());
            ref = this.fields;
            for (j = 0, len = ref.length; j < len; j++) {
                f = ref[j];
                ref1 = source.data[f];
                for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
                    x = ref1[i];
                    result[i] += x;
                }
            }
            return result;
        };
        return Stack;
    }(expression_1.Expression);
    exports.Stack = Stack;
    ;
    Stack.define({
        fields: [
            p.Array,
            []
        ]
    });    
},
/*models/filters/boolean_filter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var filter_1 = require(87    /* ./filter */);
    var p = require(15    /* core/properties */);
    var logging_1 = require(14    /* core/logging */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    var BooleanFilter = function (_super) {
        tslib_1.__extends(BooleanFilter, _super);
        function BooleanFilter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BooleanFilter.prototype.compute_indices = function (source) {
            var i, ref, ref1;
            if (((ref = this.booleans) != null ? ref.length : void 0) > 0) {
                if (array_1.all(this.booleans, types_1.isBoolean)) {
                    if (this.booleans.length !== source.get_length()) {
                        logging_1.logger.warn('BooleanFilter ' + this.id + ': length of booleans doesn\'t match data source');
                    }
                    return function () {
                        var j, len, ref1, results;
                        ref1 = array_1.range(0, this.booleans.length);
                        results = [];
                        for (j = 0, len = ref1.length; j < len; j++) {
                            i = ref1[j];
                            if (this.booleans[i] === true) {
                                results.push(i);
                            }
                        }
                        return results;
                    }.call(this);
                } else {
                    logging_1.logger.warn('BooleanFilter ' + this.id + ': booleans should be array of booleans, defaulting to no filtering');
                    return null;
                }
            } else {
                if (((ref1 = this.booleans) != null ? ref1.length : void 0) === 0) {
                    logging_1.logger.warn('BooleanFilter ' + this.id + ': booleans is empty, defaulting to no filtering');
                } else {
                    logging_1.logger.warn('BooleanFilter ' + this.id + ': booleans was not set, defaulting to no filtering');
                }
                return null;
            }
        };
        return BooleanFilter;
    }(filter_1.Filter);
    exports.BooleanFilter = BooleanFilter;
    ;
    BooleanFilter.prototype.type = 'BooleanFilter';
    BooleanFilter.define({
        booleans: [
            p.Array,
            null
        ]
    });    
},
/*models/filters/customjs_filter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var filter_1 = require(87    /* ./filter */);
    var p = require(15    /* core/properties */);
    var object_1 = require(30    /* core/util/object */);
    var CustomJSFilter = function (_super) {
        tslib_1.__extends(CustomJSFilter, _super);
        function CustomJSFilter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomJSFilter.prototype.compute_indices = function (source) {
            this.filter = this.func.apply(this, this.values.concat([
                source,
                require,
                {}
            ]));
            return _super.prototype.compute_indices.call(this);
        };
        CustomJSFilter.prototype._make_values = function () {
            return object_1.values(this.args);
        };
        CustomJSFilter.prototype._make_func = function () {
            // this relies on Object.keys(args) and values(args) returning keys and values
            // in the same order
            return new (Function.bind.apply(Function, [void 0].concat(Object.keys(this.args), [
                'source',
                'require',
                'exports',
                this.code
            ])))();
        };
        return CustomJSFilter;
    }(filter_1.Filter);
    exports.CustomJSFilter = CustomJSFilter;
    ;
    CustomJSFilter.prototype.type = 'CustomJSFilter';
    CustomJSFilter.define({
        args: [
            p.Any,
            {}
        ],
        code: [
            p.String,
            ''
        ]
    });
    CustomJSFilter.getters({
        values: function () {
            return this._make_values();
        },
        func: function () {
            return this._make_func();
        }
    });    
},
/*models/filters/filter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    var array_1 = require(22    /* core/util/array */);
    var logging_1 = require(14    /* core/logging */);
    var Filter = function (_super) {
        tslib_1.__extends(Filter, _super);
        function Filter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Filter.prototype.initialize = function (options) {
            return _super.prototype.initialize.call(this, options);
        };
        Filter.prototype.compute_indices = function () {
            var i, ref;
            if (((ref = this.filter) != null ? ref.length : void 0) >= 0) {
                if (array_1.all(this.filter, types_1.isBoolean)) {
                    return function () {
                        var j, len, ref1, results;
                        ref1 = array_1.range(0, this.filter.length);
                        results = [];
                        for (j = 0, len = ref1.length; j < len; j++) {
                            i = ref1[j];
                            if (this.filter[i] === true) {
                                results.push(i);
                            }
                        }
                        return results;
                    }.call(this);
                } else if (array_1.all(this.filter, types_1.isInteger)) {
                    return this.filter;
                } else {
                    logging_1.logger.warn('Filter ' + this.id + ': filter should either be array of only booleans or only integers, defaulting to no filtering');
                    return null;
                }
            } else {
                logging_1.logger.warn('Filter ' + this.id + ': filter was not set to be an array, defaulting to no filtering');
                return null;
            }
        };
        return Filter;
    }(model_1.Model);
    exports.Filter = Filter;
    ;
    Filter.prototype.type = 'Filter';
    Filter.define({
        filter: [
            p.Array,
            null
        ]
    });    
},
/*models/filters/group_filter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var filter_1 = require(87    /* ./filter */);
    var p = require(15    /* core/properties */);
    var logging_1 = require(14    /* core/logging */);
    var GroupFilter = function (_super) {
        tslib_1.__extends(GroupFilter, _super);
        function GroupFilter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GroupFilter.prototype.compute_indices = function (source) {
            var column, i;
            column = source.get_column(this.column_name);
            if (column == null) {
                logging_1.logger.warn('group filter: groupby column not found in data source');
                return null;
            } else {
                this.indices = function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = source.get_length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        if (column[i] === this.group) {
                            results.push(i);
                        }
                    }
                    return results;
                }.call(this);
                if (this.indices.length === 0) {
                    logging_1.logger.warn('group filter: group \'' + this.group + '\' did not match any values in column \'' + this.column_name + '\'');
                }
                return this.indices;
            }
        };
        return GroupFilter;
    }(filter_1.Filter);
    exports.GroupFilter = GroupFilter;
    ;
    GroupFilter.prototype.type = 'GroupFilter';
    GroupFilter.define({
        column_name: [p.String],
        group: [p.String]
    });    
},
/*models/filters/index*/
function _(require, module, exports) {
    var boolean_filter_1 = require(85    /* ./boolean_filter */);
    exports.BooleanFilter = boolean_filter_1.BooleanFilter;
    var customjs_filter_1 = require(86    /* ./customjs_filter */);
    exports.CustomJSFilter = customjs_filter_1.CustomJSFilter;
    var filter_1 = require(87    /* ./filter */);
    exports.Filter = filter_1.Filter;
    var group_filter_1 = require(88    /* ./group_filter */);
    exports.GroupFilter = group_filter_1.GroupFilter;
    var index_filter_1 = require(90    /* ./index_filter */);
    exports.IndexFilter = index_filter_1.IndexFilter;    
},
/*models/filters/index_filter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var filter_1 = require(87    /* ./filter */);
    var p = require(15    /* core/properties */);
    var logging_1 = require(14    /* core/logging */);
    var types_1 = require(42    /* core/util/types */);
    var array_1 = require(22    /* core/util/array */);
    var IndexFilter = function (_super) {
        tslib_1.__extends(IndexFilter, _super);
        function IndexFilter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IndexFilter.prototype.compute_indices = function (source) {
            var ref;
            if (((ref = this.indices) != null ? ref.length : void 0) >= 0) {
                if (array_1.all(this.indices, types_1.isInteger)) {
                    return this.indices;
                } else {
                    logging_1.logger.warn('IndexFilter ' + this.id + ': indices should be array of integers, defaulting to no filtering');
                    return null;
                }
            } else {
                logging_1.logger.warn('IndexFilter ' + this.id + ': indices was not set, defaulting to no filtering');
                return null;
            }
        };
        return IndexFilter;
    }(filter_1.Filter);
    exports.IndexFilter = IndexFilter;
    ;
    IndexFilter.prototype.type = 'IndexFilter';
    IndexFilter.define({
        indices: [
            p.Array,
            null
        ]
    });    
},
/*models/formatters/basic_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    var BasicTickFormatter = function (_super) {
        tslib_1.__extends(BasicTickFormatter, _super);
        function BasicTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BasicTickFormatter.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            return this.last_precision = 3;
        };
        BasicTickFormatter.prototype.doFormat = function (ticks, axis) {
            var i, is_ok, j, k, l, labels, len, m, n, need_sci, o, precision, ref, ref1, ref2, ref3, ref4, tick, tick_abs, x, zero_eps;
            if (ticks.length === 0) {
                return [];
            }
            zero_eps = 0;
            if (ticks.length >= 2) {
                zero_eps = Math.abs(ticks[1] - ticks[0]) / 10000;
            }
            need_sci = false;
            if (this.use_scientific) {
                for (j = 0, len = ticks.length; j < len; j++) {
                    tick = ticks[j];
                    tick_abs = Math.abs(tick);
                    if (tick_abs > zero_eps && (tick_abs >= this.scientific_limit_high || tick_abs <= this.scientific_limit_low)) {
                        need_sci = true;
                        break;
                    }
                }
            }
            precision = this.precision;
            if (precision == null || types_1.isNumber(precision)) {
                labels = new Array(ticks.length);
                if (need_sci) {
                    for (i = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                        labels[i] = ticks[i].toExponential(precision || void 0);
                    }
                } else {
                    for (i = l = 0, ref1 = ticks.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                        labels[i] = ticks[i].toFixed(precision || void 0).replace(/(\.[0-9]*?)0+$/, '$1').replace(/\.$/, '');
                    }
                }
                return labels;
            } else if (precision === 'auto') {
                labels = new Array(ticks.length);
                for (x = m = ref2 = this.last_precision; ref2 <= 15 ? m <= 15 : m >= 15; x = ref2 <= 15 ? ++m : --m) {
                    is_ok = true;
                    if (need_sci) {
                        for (i = n = 0, ref3 = ticks.length; 0 <= ref3 ? n < ref3 : n > ref3; i = 0 <= ref3 ? ++n : --n) {
                            labels[i] = ticks[i].toExponential(x);
                            if (i > 0) {
                                if (labels[i] === labels[i - 1]) {
                                    is_ok = false;
                                    break;
                                }
                            }
                        }
                        if (is_ok) {
                            break;
                        }
                    } else {
                        for (i = o = 0, ref4 = ticks.length; 0 <= ref4 ? o < ref4 : o > ref4; i = 0 <= ref4 ? ++o : --o) {
                            labels[i] = ticks[i].toFixed(x).replace(/(\.[0-9]*?)0+$/, '$1').replace(/\.$/, '');
                            if (i > 0) {
                                if (labels[i] === labels[i - 1]) {
                                    is_ok = false;
                                    break;
                                }
                            }
                        }
                        if (is_ok) {
                            break;
                        }
                    }
                    if (is_ok) {
                        this.last_precision = x;
                        return labels;
                    }
                }
            }
            return labels;
        };
        return BasicTickFormatter;
    }(tick_formatter_1.TickFormatter);
    exports.BasicTickFormatter = BasicTickFormatter;
    ;
    BasicTickFormatter.prototype.type = 'BasicTickFormatter';
    BasicTickFormatter.define({
        precision: [
            p.Any,
            'auto'    // TODO (bev) better
        ],
        use_scientific: [
            p.Bool,
            true
        ],
        power_limit_high: [
            p.Number,
            5
        ],
        power_limit_low: [
            p.Number,
            -3
        ]
    });
    BasicTickFormatter.getters({
        scientific_limit_low: function () {
            return Math.pow(10, this.power_limit_low);
        },
        scientific_limit_high: function () {
            return Math.pow(10, this.power_limit_high);
        }
    });    
},
/*models/formatters/categorical_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    var CategoricalTickFormatter = function (_super) {
        tslib_1.__extends(CategoricalTickFormatter, _super);
        function CategoricalTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CategoricalTickFormatter.prototype.doFormat = function (ticks, axis) {
            return ticks;
        };
        return CategoricalTickFormatter;
    }(tick_formatter_1.TickFormatter);
    exports.CategoricalTickFormatter = CategoricalTickFormatter;
    ;
    CategoricalTickFormatter.prototype.type = 'CategoricalTickFormatter';    
},
/*models/formatters/datetime_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var _array, _strftime, _us;
    var sprintf_js_1 = require(362    /* sprintf-js */);
    var tz = require(363    /* timezone */);
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    _us = function (t) {
        // From double-precision unix (millisecond) timestamp get
        // microsecond since last second. Precision seems to run
        // out around the hundreds of nanoseconds scale, so rounding
        // to the nearest microsecond should round to a nice
        // microsecond / millisecond tick.
        return Math.round(t / 1000 % 1 * 1000000);
    };
    _array = function (t) {
        return tz(t, '%Y %m %d %H %M %S').split(/\s+/).map(function (e) {
            return parseInt(e, 10);
        });
    };
    _strftime = function (t, format) {
        var microsecond_replacement_string;
        if (types_1.isFunction(format)) {
            return format(t);
        } else {
            // Python's datetime library augments the microsecond directive %f, which is not
            // supported by the javascript library timezone: http://bigeasy.github.io/timezone/.
            // Use a regular expression to replace %f directive with microseconds.
            // TODO: what should we do for negative microsecond strings?
            microsecond_replacement_string = sprintf_js_1.sprintf('$1%06d', _us(t));
            format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);
            if (format.indexOf('%') === -1) {
                // timezone seems to ignore any strings without any formatting directives,
                // and just return the time argument back instead of the string argument.
                // But we want the string argument, in case a user supplies a format string
                // which doesn't contain a formatting directive or is only using %f.
                return format;
            }
            return tz(t, format);
        }
    };
    var DatetimeTickFormatter = function (_super) {
        tslib_1.__extends(DatetimeTickFormatter, _super);
        function DatetimeTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DatetimeTickFormatter.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            // TODO (bev) trigger update on format change
            return this._update_width_formats();
        };
        DatetimeTickFormatter.prototype._update_width_formats = function () {
            var _widths, now;
            now = tz(new Date());
            _widths = function (fmt_strings) {
                var fmt_string, sizes, sorted;
                sizes = function () {
                    var j, len, results;
                    results = [];
                    for (j = 0, len = fmt_strings.length; j < len; j++) {
                        fmt_string = fmt_strings[j];
                        results.push(_strftime(now, fmt_string).length);
                    }
                    return results;
                }();
                sorted = array_1.sortBy(array_1.zip(sizes, fmt_strings), function (_a) {
                    var size = _a[0], fmt = _a[1];
                    return size;
                });
                return array_1.unzip(sorted);
            };
            return this._width_formats = {
                microseconds: _widths(this.microseconds),
                milliseconds: _widths(this.milliseconds),
                seconds: _widths(this.seconds),
                minsec: _widths(this.minsec),
                minutes: _widths(this.minutes),
                hourmin: _widths(this.hourmin),
                hours: _widths(this.hours),
                days: _widths(this.days),
                months: _widths(this.months),
                years: _widths(this.years)
            };
        };
        // FIXME There is some unfortunate flicker when panning/zooming near the
        // span boundaries.
        // FIXME Rounding is weird at the 20-us scale and below.
        DatetimeTickFormatter.prototype._get_resolution_str = function (resolution_secs, span_secs) {
            var adjusted_secs;
            // Our resolution boundaries should not be round numbers, because we want
            // them to fall between the possible tick intervals (which *are* round
            // numbers, as we've worked hard to ensure).  Consequently, we adjust the
            // resolution upwards a small amount (less than any possible step in
            // scales) to make the effective boundaries slightly lower.
            adjusted_secs = resolution_secs * 1.1;
            switch (false) {
            case !(adjusted_secs < 0.001):
                return 'microseconds';
            case !(adjusted_secs < 1):
                return 'milliseconds';
            case !(adjusted_secs < 60):
                if (span_secs >= 60) {
                    return 'minsec';
                } else {
                    return 'seconds';
                }
            case !(adjusted_secs < 3600):
                if (span_secs >= 3600) {
                    return 'hourmin';
                } else {
                    return 'minutes';
                }
            case !(adjusted_secs < 24 * 3600):
                return 'hours';
            case !(adjusted_secs < 31 * 24 * 3600):
                return 'days';
            case !(adjusted_secs < 365 * 24 * 3600):
                return 'months';
            default:
                return 'years';
            }
        };
        // TODO (bev) remove these unused "default" params and associated logic
        DatetimeTickFormatter.prototype.doFormat = function (ticks, axis, num_labels, char_width, fill_ratio, ticker) {
            if (num_labels === void 0) {
                num_labels = null;
            }
            if (char_width === void 0) {
                char_width = null;
            }
            if (fill_ratio === void 0) {
                fill_ratio = 0.3;
            }
            if (ticker === void 0) {
                ticker = null;
            }
            var error, fmt, format, formats, good_formats, hybrid_handled, i, j, k, l, labels, len, len1, next_format, next_ndx, r, ref, ref1, resol, resol_ndx, s, span, ss, t, time_tuple_ndx_for_resol, tm, widths;
            // In order to pick the right set of labels, we need to determine
            // the resolution of the ticks.  We can do this using a ticker if
            // it's provided, or by computing the resolution from the actual
            // ticks we've been given.
            if (ticks.length === 0) {
                return [];
            }
            span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000;
            if (ticker) {
                r = ticker.resolution;
            } else {
                r = span / (ticks.length - 1);
            }
            resol = this._get_resolution_str(r, span);
            _a = this._width_formats[resol], widths = _a[0], formats = _a[1];
            format = formats[0];
            // FIXME I'm pretty sure this code won't work; luckily it doesn't seem to
            // be used.
            if (char_width) {
                // If a width is provided, then we pick the most appropriate scale,
                // otherwise just use the widest format
                good_formats = [];
                for (i = j = 0, ref = widths.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    if (widths[i] * ticks.length < fill_ratio * char_width) {
                        good_formats.push(this._width_formats[i]);
                    }
                }
                if (good_formats.length > 0) {
                    format = good_formats[good_formats.length - 1];
                }
            }
            // Apply the format to the tick values
            labels = [];
            resol_ndx = this.format_order.indexOf(resol);
            // This dictionary maps the name of a time resolution (in @format_order)
            // to its index in a time.localtime() timetuple.  The default is to map
            // everything to index 0, which is year.  This is not ideal; it might cause
            // a problem with the tick at midnight, january 1st, 0 a.d. being incorrectly
            // promoted at certain tick resolutions.
            time_tuple_ndx_for_resol = {};
            ref1 = this.format_order;
            for (k = 0, len = ref1.length; k < len; k++) {
                fmt = ref1[k];
                time_tuple_ndx_for_resol[fmt] = 0;
            }
            time_tuple_ndx_for_resol['seconds'] = 5;
            time_tuple_ndx_for_resol['minsec'] = 4;
            time_tuple_ndx_for_resol['minutes'] = 4;
            time_tuple_ndx_for_resol['hourmin'] = 3;
            time_tuple_ndx_for_resol['hours'] = 3;
            // As we format each tick, check to see if we are at a boundary of the
            // next higher unit of time.  If so, replace the current format with one
            // from that resolution.  This is not the best heuristic in the world,
            // but it works!  There is some trickiness here due to having to deal
            // with hybrid formats in a reasonable manner.
            for (l = 0, len1 = ticks.length; l < len1; l++) {
                t = ticks[l];
                try {
                    tm = _array(t);
                    s = _strftime(t, format);
                } catch (error1) {
                    error = error1;
                    logging_1.logger.warn('unable to format tick for timestamp value ' + t);
                    logging_1.logger.warn(' - ' + error);
                    labels.push('ERR');
                    continue;
                }
                hybrid_handled = false;
                next_ndx = resol_ndx;
                // The way to check that we are at the boundary of the next unit of
                // time is by checking that we have 0 units of the resolution, i.e.
                // we are at zero minutes, so display hours, or we are at zero seconds,
                // so display minutes (and if that is zero as well, then display hours).
                while (tm[time_tuple_ndx_for_resol[this.format_order[next_ndx]]] === 0) {
                    next_ndx += 1;
                    if (next_ndx === this.format_order.length) {
                        break;
                    }
                    if ((resol === 'minsec' || resol === 'hourmin') && !hybrid_handled) {
                        if (resol === 'minsec' && tm[4] === 0 && tm[5] !== 0 || resol === 'hourmin' && tm[3] === 0 && tm[4] !== 0) {
                            next_format = this._width_formats[this.format_order[resol_ndx - 1]][1][0];
                            s = _strftime(t, next_format);
                            break;
                        } else {
                            hybrid_handled = true;
                        }
                    }
                    next_format = this._width_formats[this.format_order[next_ndx]][1][0];
                    s = _strftime(t, next_format);
                }
                // TODO: should expose this in api. %H, %d, etc use leading zeros and
                // users might prefer to see them lined up correctly.
                if (this.strip_leading_zeros) {
                    ss = s.replace(/^0+/g, '');
                    if (ss !== s && isNaN(parseInt(ss))) {
                        // If the string can now be parsed as starting with an integer, then
                        // leave all zeros stripped, otherwise start with a zero. Hence:
                        // A label such as '000ms' should leave one zero.
                        // A label such as '001ms' or '0-1ms' should not leave a leading zero.
                        ss = '0' + ss;
                    }
                    labels.push(ss);
                } else {
                    labels.push(s);
                }
            }
            return labels;
            var _a;
        };
        return DatetimeTickFormatter;
    }(tick_formatter_1.TickFormatter);
    exports.DatetimeTickFormatter = DatetimeTickFormatter;
    ;
    DatetimeTickFormatter.prototype.type = 'DatetimeTickFormatter';
    DatetimeTickFormatter.define({
        microseconds: [
            p.Array,
            ['%fus']
        ],
        milliseconds: [
            p.Array,
            [
                '%3Nms',
                '%S.%3Ns'
            ]
        ],
        seconds: [
            p.Array,
            ['%Ss']
        ],
        minsec: [
            p.Array,
            [':%M:%S']
        ],
        minutes: [
            p.Array,
            [
                ':%M',
                '%Mm'
            ]
        ],
        hourmin: [
            p.Array,
            ['%H:%M']
        ],
        hours: [
            p.Array,
            [
                '%Hh',
                '%H:%M'
            ]
        ],
        days: [
            p.Array,
            [
                '%m/%d',
                '%a%d'
            ]
        ],
        months: [
            p.Array,
            [
                '%m/%Y',
                '%b%y'
            ]
        ],
        years: [
            p.Array,
            ['%Y']
        ]
    });
    // Labels of time units, from finest to coarsest.
    DatetimeTickFormatter.prototype.format_order = [
        'microseconds',
        'milliseconds',
        'seconds',
        'minsec',
        'minutes',
        'hourmin',
        'hours',
        'days',
        'months',
        'years'
    ];
    // Whether or not to strip the leading zeros on tick labels.
    DatetimeTickFormatter.prototype.strip_leading_zeros = true;    
},
/*models/formatters/func_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    var p = require(15    /* core/properties */);
    var object_1 = require(30    /* core/util/object */);
    var FuncTickFormatter = function (_super) {
        tslib_1.__extends(FuncTickFormatter, _super);
        function FuncTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FuncTickFormatter.prototype._make_func = function () {
            return new (Function.bind.apply(Function, [
                void 0,
                'tick'
            ].concat(Object.keys(this.args), [
                'require',
                this.code
            ])))();
        };
        FuncTickFormatter.prototype.doFormat = function (ticks, axis) {
            var func, tick;
            func = this._make_func();
            return function () {
                var i, len, results;
                results = [];
                for (i = 0, len = ticks.length; i < len; i++) {
                    tick = ticks[i];
                    results.push(func.apply(void 0, [tick].concat(object_1.values(this.args), [require])));
                }
                return results;
            }.call(this);
        };
        return FuncTickFormatter;
    }(tick_formatter_1.TickFormatter);
    exports.FuncTickFormatter = FuncTickFormatter;
    ;
    FuncTickFormatter.prototype.type = 'FuncTickFormatter';
    FuncTickFormatter.define({
        args: [
            p.Any,
            {}
        ],
        code: [
            p.String,
            ''
        ]
    });    
},
/*models/formatters/index*/
function _(require, module, exports) {
    var basic_tick_formatter_1 = require(91    /* ./basic_tick_formatter */);
    exports.BasicTickFormatter = basic_tick_formatter_1.BasicTickFormatter;
    var categorical_tick_formatter_1 = require(92    /* ./categorical_tick_formatter */);
    exports.CategoricalTickFormatter = categorical_tick_formatter_1.CategoricalTickFormatter;
    var datetime_tick_formatter_1 = require(93    /* ./datetime_tick_formatter */);
    exports.DatetimeTickFormatter = datetime_tick_formatter_1.DatetimeTickFormatter;
    var func_tick_formatter_1 = require(94    /* ./func_tick_formatter */);
    exports.FuncTickFormatter = func_tick_formatter_1.FuncTickFormatter;
    var log_tick_formatter_1 = require(96    /* ./log_tick_formatter */);
    exports.LogTickFormatter = log_tick_formatter_1.LogTickFormatter;
    var mercator_tick_formatter_1 = require(97    /* ./mercator_tick_formatter */);
    exports.MercatorTickFormatter = mercator_tick_formatter_1.MercatorTickFormatter;
    var numeral_tick_formatter_1 = require(98    /* ./numeral_tick_formatter */);
    exports.NumeralTickFormatter = numeral_tick_formatter_1.NumeralTickFormatter;
    var printf_tick_formatter_1 = require(99    /* ./printf_tick_formatter */);
    exports.PrintfTickFormatter = printf_tick_formatter_1.PrintfTickFormatter;
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    exports.TickFormatter = tick_formatter_1.TickFormatter;    
},
/*models/formatters/log_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var basic_tick_formatter_1 = require(91    /* ./basic_tick_formatter */);
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var LogTickFormatter = function (_super) {
        tslib_1.__extends(LogTickFormatter, _super);
        function LogTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LogTickFormatter.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this.basic_formatter = new basic_tick_formatter_1.BasicTickFormatter();
            if (this.ticker == null) {
                return logging_1.logger.warn('LogTickFormatter not configured with a ticker, using default base of 10 (labels will be incorrect if ticker base is not 10)');
            }
        };
        LogTickFormatter.prototype.doFormat = function (ticks, axis) {
            var base, i, j, labels, ref, small_interval;
            if (ticks.length === 0) {
                return [];
            }
            if (this.ticker != null) {
                base = this.ticker.base;
            } else {
                base = 10;
            }
            small_interval = false;
            labels = new Array(ticks.length);
            for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                labels[i] = base + '^' + Math.round(Math.log(ticks[i]) / Math.log(base));
                if (i > 0 && labels[i] === labels[i - 1]) {
                    small_interval = true;
                    break;
                }
            }
            if (small_interval) {
                labels = this.basic_formatter.doFormat(ticks);
            }
            return labels;
        };
        return LogTickFormatter;
    }(tick_formatter_1.TickFormatter);
    exports.LogTickFormatter = LogTickFormatter;
    ;
    LogTickFormatter.prototype.type = 'LogTickFormatter';
    LogTickFormatter.define({
        ticker: [
            p.Instance,
            null
        ]
    });    
},
/*models/formatters/mercator_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var basic_tick_formatter_1 = require(91    /* ./basic_tick_formatter */);
    var p = require(15    /* core/properties */);
    var proj4_1 = require(31    /* core/util/proj4 */);
    var MercatorTickFormatter = function (_super) {
        tslib_1.__extends(MercatorTickFormatter, _super);
        function MercatorTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MercatorTickFormatter.prototype.doFormat = function (ticks, axis) {
            var i, j, k, lat, lon, proj_ticks, ref, ref1;
            if (this.dimension == null) {
                throw new Error('MercatorTickFormatter.dimension not configured');
            }
            if (ticks.length === 0) {
                return [];
            }
            proj_ticks = new Array(ticks.length);
            if (this.dimension === 'lon') {
                for (i = j = 0, ref = ticks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    _a = proj4_1.proj4(proj4_1.mercator).inverse([
                        ticks[i],
                        axis.loc
                    ]), lon = _a[0], lat = _a[1];
                    proj_ticks[i] = lon;
                }
            } else {
                for (i = k = 0, ref1 = ticks.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                    _b = proj4_1.proj4(proj4_1.mercator).inverse([
                        axis.loc,
                        ticks[i]
                    ]), lon = _b[0], lat = _b[1];
                    proj_ticks[i] = lat;
                }
            }
            return _super.prototype.doFormat.call(this, proj_ticks, axis);
            var _a, _b;
        };
        return MercatorTickFormatter;
    }(basic_tick_formatter_1.BasicTickFormatter);
    exports.MercatorTickFormatter = MercatorTickFormatter;
    ;
    MercatorTickFormatter.prototype.type = 'MercatorTickFormatter';
    MercatorTickFormatter.define({ dimension: [p.LatLon] });    
},
/*models/formatters/numeral_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var Numbro = require(332    /* numbro */);
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    var p = require(15    /* core/properties */);
    var NumeralTickFormatter = function (_super) {
        tslib_1.__extends(NumeralTickFormatter, _super);
        function NumeralTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NumeralTickFormatter.prototype.doFormat = function (ticks, axis) {
            var format, labels, language, rounding, tick;
            format = this.format;
            language = this.language;
            rounding = function () {
                switch (this.rounding) {
                case 'round':
                case 'nearest':
                    return Math.round;
                case 'floor':
                case 'rounddown':
                    return Math.floor;
                case 'ceil':
                case 'roundup':
                    return Math.ceil;
                }
            }.call(this);
            labels = function () {
                var i, len, results;
                results = [];
                for (i = 0, len = ticks.length; i < len; i++) {
                    tick = ticks[i];
                    results.push(Numbro.format(tick, format, language, rounding));
                }
                return results;
            }();
            return labels;
        };
        return NumeralTickFormatter;
    }(tick_formatter_1.TickFormatter);
    exports.NumeralTickFormatter = NumeralTickFormatter;
    ;
    NumeralTickFormatter.prototype.type = 'NumeralTickFormatter';
    NumeralTickFormatter.define({
        // TODO (bev) all of these could be tightened up
        format: [
            p.String,
            '0,0'
        ],
        language: [
            p.String,
            'en'
        ],
        rounding: [
            p.String,
            'round'
        ]
    });    
},
/*models/formatters/printf_tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var sprintf_js_1 = require(362    /* sprintf-js */);
    var tick_formatter_1 = require(100    /* ./tick_formatter */);
    var p = require(15    /* core/properties */);
    var PrintfTickFormatter = function (_super) {
        tslib_1.__extends(PrintfTickFormatter, _super);
        function PrintfTickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PrintfTickFormatter.prototype.doFormat = function (ticks, axis) {
            var format, labels, tick;
            format = this.format;
            labels = function () {
                var i, len, results;
                results = [];
                for (i = 0, len = ticks.length; i < len; i++) {
                    tick = ticks[i];
                    results.push(sprintf_js_1.sprintf(format, tick));
                }
                return results;
            }();
            return labels;
        };
        return PrintfTickFormatter;
    }(tick_formatter_1.TickFormatter);
    exports.PrintfTickFormatter = PrintfTickFormatter;
    ;
    PrintfTickFormatter.prototype.type = 'PrintfTickFormatter';
    PrintfTickFormatter.define({
        format: [
            p.String,
            '%s'
        ]
    });    
},
/*models/formatters/tick_formatter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var TickFormatter = function (_super) {
        tslib_1.__extends(TickFormatter, _super);
        function TickFormatter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TickFormatter.prototype.doFormat = function (ticks, axis) {
        };
        return TickFormatter;
    }(model_1.Model);
    exports.TickFormatter = TickFormatter;
    ;
    TickFormatter.prototype.type = 'TickFormatter';    
},
/*models/glyphs/annular_wedge*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    var math_1 = require(29    /* core/util/math */);
    exports.AnnularWedgeView = function (_super) {
        tslib_1.__extends(AnnularWedgeView, _super);
        function AnnularWedgeView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnnularWedgeView.prototype._map_data = function () {
            var i, j, ref, results;
            if (this.model.properties.inner_radius.units === 'data') {
                this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);
            } else {
                this.sinner_radius = this._inner_radius;
            }
            if (this.model.properties.outer_radius.units === 'data') {
                this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);
            } else {
                this.souter_radius = this._outer_radius;
            }
            this._angle = new Float32Array(this._start_angle.length);
            results = [];
            for (i = j = 0, ref = this._start_angle.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(this._angle[i] = this._end_angle[i] - this._start_angle[i]);
            }
            return results;
        };
        AnnularWedgeView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, _start_angle = _a._start_angle, _angle = _a._angle, sinner_radius = _a.sinner_radius, souter_radius = _a.souter_radius;
            var direction, i, j, len, results;
            direction = this.model.properties.direction.value();
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i])) {
                    continue;
                }
                ctx.translate(sx[i], sy[i]);
                ctx.rotate(_start_angle[i]);
                ctx.moveTo(souter_radius[i], 0);
                ctx.beginPath();
                ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);
                ctx.rotate(_angle[i]);
                ctx.lineTo(sinner_radius[i], 0);
                ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);
                ctx.closePath();
                ctx.rotate(-_angle[i] - _start_angle[i]);
                ctx.translate(-sx[i], -sy[i]);
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    ctx.fill();
                }
                if (this.visuals.line.doit) {
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        AnnularWedgeView.prototype._hit_point = function (geometry) {
            var angle, bbox, candidates, direction, dist, hits, i, ir2, j, k, len, len1, or2, ref, sx, sx0, sx1, sy, sy0, sy1, x, x0, x1, y, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            y = this.renderer.yscale.invert(sy);
            // check radius first
            if (this.model.properties.outer_radius.units === 'data') {
                x0 = x - this.max_outer_radius;
                x1 = x + this.max_outer_radius;
                y0 = y - this.max_outer_radius;
                y1 = y + this.max_outer_radius;
            } else {
                sx0 = sx - this.max_outer_radius;
                sx1 = sx + this.max_outer_radius;
                _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
                sy0 = sy - this.max_outer_radius;
                sy1 = sy + this.max_outer_radius;
                _b = this.renderer.yscale.r_invert(sy0, sy1), y0 = _b[0], y1 = _b[1];
            }
            candidates = [];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            ref = this.index.indices(bbox);
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                or2 = Math.pow(this.souter_radius[i], 2);
                ir2 = Math.pow(this.sinner_radius[i], 2);
                _c = this.renderer.xscale.r_compute(x, this._x[i]), sx0 = _c[0], sx1 = _c[1];
                _d = this.renderer.yscale.r_compute(y, this._y[i]), sy0 = _d[0], sy1 = _d[1];
                dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                if (dist <= or2 && dist >= ir2) {
                    candidates.push([
                        i,
                        dist
                    ]);
                }
            }
            direction = this.model.properties.direction.value();
            hits = [];
            for (k = 0, len1 = candidates.length; k < len1; k++) {
                _e = candidates[k], i = _e[0], dist = _e[1];
                // NOTE: minus the angle because JS uses non-mathy convention for angles
                angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);
                if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {
                    hits.push([
                        i,
                        dist
                    ]);
                }
            }
            return hittest.create_1d_hit_test_result(hits);
            var _a, _b, _c, _d, _e;
        };
        AnnularWedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
        };
        AnnularWedgeView.prototype._scxy = function (i) {
            var a, r;
            r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;
            a = (this._start_angle[i] + this._end_angle[i]) / 2;
            return {
                x: this.sx[i] + r * Math.cos(a),
                y: this.sy[i] + r * Math.sin(a)
            };
        };
        AnnularWedgeView.prototype.scx = function (i) {
            return this._scxy(i).x;
        };
        AnnularWedgeView.prototype.scy = function (i) {
            return this._scxy(i).y;
        };
        return AnnularWedgeView;
    }(xy_glyph_1.XYGlyphView);
    var AnnularWedge = function (_super) {
        tslib_1.__extends(AnnularWedge, _super);
        function AnnularWedge() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AnnularWedge;
    }(xy_glyph_1.XYGlyph);
    exports.AnnularWedge = AnnularWedge;
    ;
    AnnularWedge.prototype.default_view = exports.AnnularWedgeView;
    AnnularWedge.prototype.type = 'AnnularWedge';
    AnnularWedge.mixins([
        'line',
        'fill'
    ]);
    AnnularWedge.define({
        direction: [
            p.Direction,
            'anticlock'
        ],
        inner_radius: [p.DistanceSpec],
        outer_radius: [p.DistanceSpec],
        start_angle: [p.AngleSpec],
        end_angle: [p.AngleSpec]
    });    
},
/*models/glyphs/annulus*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    exports.AnnulusView = function (_super) {
        tslib_1.__extends(AnnulusView, _super);
        function AnnulusView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnnulusView.prototype._map_data = function () {
            if (this.model.properties.inner_radius.units === 'data') {
                this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);
            } else {
                this.sinner_radius = this._inner_radius;
            }
            if (this.model.properties.outer_radius.units === 'data') {
                return this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);
            } else {
                return this.souter_radius = this._outer_radius;
            }
        };
        AnnulusView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, sinner_radius = _a.sinner_radius, souter_radius = _a.souter_radius;
            var clockwise, i, isie, j, k, len, len1, ref, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i])) {
                    continue;
                }
                // Because this visual has a whole in it, it proved "challenging"
                // for some browsers to render if drawn in one go --- i.e. it did not
                // work on IE. If we render in two parts (upper and lower part),
                // it is unambiguous what part should be filled. The line is
                // better drawn in one go though, otherwise the part where the pieces
                // meet will not be fully closed due to aa.
                // Detect Microsoft browser. Might need change for newer versions.
                isie = navigator.userAgent.indexOf('MSIE') >= 0 || navigator.userAgent.indexOf('Trident') > 0 || navigator.userAgent.indexOf('Edge') > 0;
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    ctx.beginPath();
                    if (isie) {
                        ref = [
                            false,
                            true
                        ];
                        // Draw two halves of the donut. Works on IE, but causes an aa line on Safari.
                        for (k = 0, len1 = ref.length; k < len1; k++) {
                            clockwise = ref[k];
                            ctx.arc(sx[i], sy[i], sinner_radius[i], 0, Math.PI, clockwise);
                            ctx.arc(sx[i], sy[i], souter_radius[i], Math.PI, 0, !clockwise);
                        }
                    } else {
                        // Draw donut in one go. Does not work on iE.
                        ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI, true);
                        ctx.arc(sx[i], sy[i], souter_radius[i], 2 * Math.PI, 0, false);
                    }
                    ctx.fill();
                }
                if (this.visuals.line.doit) {
                    this.visuals.line.set_vectorize(ctx, i);
                    ctx.beginPath();
                    ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI);
                    ctx.moveTo(sx[i] + souter_radius[i], sy[i]);
                    ctx.arc(sx[i], sy[i], souter_radius[i], 0, 2 * Math.PI);
                    results.push(ctx.stroke());
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        AnnulusView.prototype._hit_point = function (geometry) {
            var bbox, dist, hits, i, ir2, j, len, or2, ref, sx, sx0, sx1, sy, sy0, sy1, x, x0, x1, y, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            x0 = x - this.max_radius;
            x1 = x + this.max_radius;
            y = this.renderer.yscale.invert(sy);
            y0 = y - this.max_radius;
            y1 = y + this.max_radius;
            hits = [];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            ref = this.index.indices(bbox);
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                or2 = Math.pow(this.souter_radius[i], 2);
                ir2 = Math.pow(this.sinner_radius[i], 2);
                _a = this.renderer.xscale.r_compute(x, this._x[i]), sx0 = _a[0], sx1 = _a[1];
                _b = this.renderer.yscale.r_compute(y, this._y[i]), sy0 = _b[0], sy1 = _b[1];
                dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                if (dist <= or2 && dist >= ir2) {
                    hits.push([
                        i,
                        dist
                    ]);
                }
            }
            return hittest.create_1d_hit_test_result(hits);
            var _a, _b;
        };
        AnnulusView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            var data, indices, r, sinner_radius, souter_radius, sx, sy;
            indices = [index];
            sx = {};
            sx[index] = (x0 + x1) / 2;
            sy = {};
            sy[index] = (y0 + y1) / 2;
            r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;
            sinner_radius = {};
            sinner_radius[index] = r * 0.4;
            souter_radius = {};
            souter_radius[index] = r * 0.8;
            data = {
                sx: sx,
                sy: sy,
                sinner_radius: sinner_radius,
                souter_radius: souter_radius
            };
            return this._render(ctx, indices, data);
        };
        return AnnulusView;
    }(xy_glyph_1.XYGlyphView);
    var Annulus = function (_super) {
        tslib_1.__extends(Annulus, _super);
        function Annulus() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Annulus;
    }(xy_glyph_1.XYGlyph);
    exports.Annulus = Annulus;
    ;
    Annulus.prototype.default_view = exports.AnnulusView;
    Annulus.prototype.type = 'Annulus';
    Annulus.mixins([
        'line',
        'fill'
    ]);
    Annulus.define({
        inner_radius: [p.DistanceSpec],
        outer_radius: [p.DistanceSpec]
    });    
},
/*models/glyphs/arc*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var p = require(15    /* core/properties */);
    exports.ArcView = function (_super) {
        tslib_1.__extends(ArcView, _super);
        function ArcView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ArcView.prototype._map_data = function () {
            if (this.model.properties.radius.units === 'data') {
                return this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);
            } else {
                return this.sradius = this._radius;
            }
        };
        ArcView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, sradius = _a.sradius, _start_angle = _a._start_angle, _end_angle = _a._end_angle;
            var direction, i, j, len, results;
            if (this.visuals.line.doit) {
                direction = this.model.properties.direction.value();
                results = [];
                for (j = 0, len = indices.length; j < len; j++) {
                    i = indices[j];
                    if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {
                        continue;
                    }
                    ctx.beginPath();
                    ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                }
                return results;
            }
        };
        ArcView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return ArcView;
    }(xy_glyph_1.XYGlyphView);
    var Arc = function (_super) {
        tslib_1.__extends(Arc, _super);
        function Arc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Arc;
    }(xy_glyph_1.XYGlyph);
    exports.Arc = Arc;
    ;
    Arc.prototype.default_view = exports.ArcView;
    Arc.prototype.type = 'Arc';
    Arc.mixins(['line']);
    Arc.define({
        direction: [
            p.Direction,
            'anticlock'
        ],
        radius: [p.DistanceSpec],
        start_angle: [p.AngleSpec],
        end_angle: [p.AngleSpec]
    });    
},
/*models/glyphs/bezier*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var _cbb;
    var spatial_1 = require(36    /* core/util/spatial */);
    var glyph_1 = require(108    /* ./glyph */);
    // algorithm adapted from http://stackoverflow.com/a/14429749/3406693
    _cbb = function (x0, y0, x1, y1, x2, y2, x3, y3) {
        var a, b, b2ac, bounds, c, i, j, jlen, k, mt, sqrtb2ac, t, t1, t2, tvalues, x, y;
        tvalues = [];
        bounds = [
            [],
            []
        ];
        for (i = k = 0; k <= 2; i = ++k) {
            if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                    tvalues.push(t);
                }
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = Math.sqrt(b2ac);
            if (b2ac < 0) {
                continue;
            }
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
            }
        }
        j = tvalues.length;
        jlen = j;
        while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[0][j] = x;
            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
            bounds[1][j] = y;
        }
        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        return [
            Math.min.apply(null, bounds[0]),
            Math.max.apply(null, bounds[1]),
            Math.max.apply(null, bounds[0]),
            Math.min.apply(null, bounds[1])
        ];
    };
    exports.BezierView = function (_super) {
        tslib_1.__extends(BezierView, _super);
        function BezierView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BezierView.prototype._index_data = function () {
            var i, k, points, ref, x0, x1, y0, y1;
            points = [];
            for (i = k = 0, ref = this._x0.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx0[i] + this._cy0[i] + this._cx1[i] + this._cy1[i])) {
                    continue;
                }
                _a = _cbb(this._x0[i], this._y0[i], this._x1[i], this._y1[i], this._cx0[i], this._cy0[i], this._cx1[i], this._cy1[i]), x0 = _a[0], y0 = _a[1], x1 = _a[2], y1 = _a[3];
                points.push({
                    minX: x0,
                    minY: y0,
                    maxX: x1,
                    maxY: y1,
                    i: i
                });
            }
            return new spatial_1.RBush(points);
            var _a;
        };
        BezierView.prototype._render = function (ctx, indices, _a) {
            var sx0 = _a.sx0, sy0 = _a.sy0, sx1 = _a.sx1, sy1 = _a.sy1, scx = _a.scx, scx0 = _a.scx0, scy0 = _a.scy0, scx1 = _a.scx1, scy1 = _a.scy1;
            var i, k, len, results;
            if (this.visuals.line.doit) {
                results = [];
                for (k = 0, len = indices.length; k < len; k++) {
                    i = indices[k];
                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx0[i] + scy0[i] + scx1[i] + scy1[i])) {
                        continue;
                    }
                    ctx.beginPath();
                    ctx.moveTo(sx0[i], sy0[i]);
                    ctx.bezierCurveTo(scx0[i], scy0[i], scx1[i], scy1[i], sx1[i], sy1[i]);
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                }
                return results;
            }
        };
        BezierView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return BezierView;
    }(glyph_1.GlyphView);
    var Bezier = function (_super) {
        tslib_1.__extends(Bezier, _super);
        function Bezier() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Bezier;
    }(glyph_1.Glyph);
    exports.Bezier = Bezier;
    ;
    Bezier.prototype.default_view = exports.BezierView;
    Bezier.prototype.type = 'Bezier';
    Bezier.coords([
        [
            'x0',
            'y0'
        ],
        [
            'x1',
            'y1'
        ],
        [
            'cx0',
            'cy0'
        ],
        [
            'cx1',
            'cy1'
        ]
    ]);
    Bezier.mixins(['line']);    
},
/*models/glyphs/box*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var spatial_1 = require(36    /* core/util/spatial */);
    var glyph_1 = require(108    /* ./glyph */);
    var hittest = require(9    /* core/hittest */);
    // Not a publicly exposed Glyph, exists to factor code for bars and quads
    exports.BoxView = function (_super) {
        tslib_1.__extends(BoxView, _super);
        function BoxView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoxView.prototype._index_box = function (len) {
            var b, i, j, l, points, r, ref, t;
            points = [];
            for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                _a = this._lrtb(i), l = _a[0], r = _a[1], t = _a[2], b = _a[3];
                if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {
                    continue;
                }
                points.push({
                    minX: l,
                    minY: b,
                    maxX: r,
                    maxY: t,
                    i: i
                });
            }
            return new spatial_1.RBush(points);
            var _a;
        };
        BoxView.prototype._render = function (ctx, indices, _a) {
            var sleft = _a.sleft, sright = _a.sright, stop = _a.stop, sbottom = _a.sbottom;
            var i, j, len1, results;
            results = [];
            for (j = 0, len1 = indices.length; j < len1; j++) {
                i = indices[j];
                if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i])) {
                    continue;
                }
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    ctx.fillRect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
                }
                if (this.visuals.line.doit) {
                    ctx.beginPath();
                    ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        BoxView.prototype._hit_rect = function (geometry) {
            return this._hit_rect_against_index(geometry);
        };
        BoxView.prototype._hit_point = function (geometry) {
            var hits, result, sx, sy, x, y;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            y = this.renderer.yscale.invert(sy);
            hits = this.index.indices({
                minX: x,
                minY: y,
                maxX: x,
                maxY: y
            });
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
        };
        BoxView.prototype._hit_span = function (geometry) {
            var hits, hr, maxX, maxY, minX, minY, result, sx, sy, vr, x, y;
            sx = geometry.sx, sy = geometry.sy;
            if (geometry.direction === 'v') {
                y = this.renderer.yscale.invert(sy);
                hr = this.renderer.plot_view.frame.bbox.h_range;
                _a = this.renderer.xscale.r_invert(hr.start, hr.end), minX = _a[0], maxX = _a[1];
                hits = this.index.indices({
                    minX: minX,
                    minY: y,
                    maxX: maxX,
                    maxY: y
                });
            } else {
                x = this.renderer.xscale.invert(sx);
                vr = this.renderer.plot_view.frame.bbox.v_range;
                _b = this.renderer.yscale.r_invert(vr.start, vr.end), minY = _b[0], maxY = _b[1];
                hits = this.index.indices({
                    minX: x,
                    minY: minY,
                    maxX: x,
                    maxY: maxY
                });
            }
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
            var _a, _b;
        };
        BoxView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
        };
        return BoxView;
    }(glyph_1.GlyphView);
    var Box = function (_super) {
        tslib_1.__extends(Box, _super);
        function Box() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Box;
    }(glyph_1.Glyph);
    exports.Box = Box;
    ;
    Box.mixins([
        'line',
        'fill'
    ]);    
},
/*models/glyphs/circle*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    exports.CircleView = function (_super) {
        tslib_1.__extends(CircleView, _super);
        function CircleView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CircleView.prototype._map_data = function () {
            var rd, s;
            // NOTE: Order is important here: size is always present (at least
            // a default), but radius is only present if a user specifies it
            if (this._radius != null) {
                if (this.model.properties.radius.spec.units === 'data') {
                    rd = this.model.properties.radius_dimension.spec.value;
                    return this.sradius = this.sdist(this.renderer[rd + 'scale'], this['_' + rd], this._radius);
                } else {
                    this.sradius = this._radius;
                    return this.max_size = 2 * this.max_radius;
                }
            } else {
                return this.sradius = function () {
                    var j, len, ref, results;
                    ref = this._size;
                    results = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                        s = ref[j];
                        results.push(s / 2);
                    }
                    return results;
                }.call(this);
            }
        };
        CircleView.prototype._mask_data = function (all_indices) {
            var bbox, hr, sx0, sx1, sy0, sy1, vr, x0, x1, y0, y1;
            _a = this.renderer.plot_view.frame.bbox.ranges, hr = _a[0], vr = _a[1];
            // check for radius first
            if (this._radius != null && this.model.properties.radius.units === 'data') {
                sx0 = hr.start;
                sx1 = hr.end;
                _b = this.renderer.xscale.r_invert(sx0, sx1), x0 = _b[0], x1 = _b[1];
                x0 -= this.max_radius;
                x1 += this.max_radius;
                sy0 = vr.start;
                sy1 = vr.end;
                _c = this.renderer.yscale.r_invert(sy0, sy1), y0 = _c[0], y1 = _c[1];
                y0 -= this.max_radius;
                y1 += this.max_radius;
            } else {
                sx0 = hr.start - this.max_size;
                sx1 = hr.end + this.max_size;
                _d = this.renderer.xscale.r_invert(sx0, sx1), x0 = _d[0], x1 = _d[1];
                sy0 = vr.start - this.max_size;
                sy1 = vr.end + this.max_size;
                _e = this.renderer.yscale.r_invert(sy0, sy1), y0 = _e[0], y1 = _e[1];
            }
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            return this.index.indices(bbox);
            var _a, _b, _c, _d, _e;
        };
        CircleView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, sradius = _a.sradius;
            var i, j, len, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sradius[i])) {
                    continue;
                }
                ctx.beginPath();
                ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    ctx.fill();
                }
                if (this.visuals.line.doit) {
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        CircleView.prototype._hit_point = function (geometry) {
            var bbox, candidates, dist, hits, i, j, k, len, len1, r2, sx, sx0, sx1, sy, sy0, sy1, x, x0, x1, y, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            y = this.renderer.yscale.invert(sy);
            // check radius first
            if (this._radius != null && this.model.properties.radius.units === 'data') {
                x0 = x - this.max_radius;
                x1 = x + this.max_radius;
                y0 = y - this.max_radius;
                y1 = y + this.max_radius;
            } else {
                sx0 = sx - this.max_size;
                sx1 = sx + this.max_size;
                _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
                _b = [
                    Math.min(x0, x1),
                    Math.max(x0, x1)
                ], x0 = _b[0], x1 = _b[1];
                sy0 = sy - this.max_size;
                sy1 = sy + this.max_size;
                _c = this.renderer.yscale.r_invert(sy0, sy1), y0 = _c[0], y1 = _c[1];
                _d = [
                    Math.min(y0, y1),
                    Math.max(y0, y1)
                ], y0 = _d[0], y1 = _d[1];
            }
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            candidates = this.index.indices(bbox);
            hits = [];
            if (this._radius != null && this.model.properties.radius.units === 'data') {
                for (j = 0, len = candidates.length; j < len; j++) {
                    i = candidates[j];
                    r2 = Math.pow(this.sradius[i], 2);
                    _e = this.renderer.xscale.r_compute(x, this._x[i]), sx0 = _e[0], sx1 = _e[1];
                    _f = this.renderer.yscale.r_compute(y, this._y[i]), sy0 = _f[0], sy1 = _f[1];
                    dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                    if (dist <= r2) {
                        hits.push([
                            i,
                            dist
                        ]);
                    }
                }
            } else {
                for (k = 0, len1 = candidates.length; k < len1; k++) {
                    i = candidates[k];
                    r2 = Math.pow(this.sradius[i], 2);
                    dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);
                    if (dist <= r2) {
                        hits.push([
                            i,
                            dist
                        ]);
                    }
                }
            }
            return hittest.create_1d_hit_test_result(hits);
            var _a, _b, _c, _d, _e, _f;
        };
        CircleView.prototype._hit_span = function (geometry) {
            var bbox, hits, maxX, maxY, minX, minY, ms, result, sx, sx0, sx1, sy, sy0, sy1, x0, x1, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            _a = this.bounds(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
            result = hittest.create_hit_test_result();
            if (geometry.direction === 'h') {
                // use circle bounds instead of current pointer y coordinates
                y0 = minY;
                y1 = maxY;
                if (this._radius != null && this.model.properties.radius.units === 'data') {
                    sx0 = sx - this.max_radius;
                    sx1 = sx + this.max_radius;
                    _b = this.renderer.xscale.r_invert(sx0, sx1), x0 = _b[0], x1 = _b[1];
                } else {
                    ms = this.max_size / 2;
                    sx0 = sx - ms;
                    sx1 = sx + ms;
                    _c = this.renderer.xscale.r_invert(sx0, sx1), x0 = _c[0], x1 = _c[1];
                }
            } else {
                // use circle bounds instead of current pointer x coordinates
                x0 = minX;
                x1 = maxX;
                if (this._radius != null && this.model.properties.radius.units === 'data') {
                    sy0 = sy - this.max_radius;
                    sy1 = sy + this.max_radius;
                    _d = this.renderer.yscale.r_invert(sy0, sy1), y0 = _d[0], y1 = _d[1];
                } else {
                    ms = this.max_size / 2;
                    sy0 = sy - ms;
                    sy1 = sy + ms;
                    _e = this.renderer.yscale.r_invert(sy0, sy1), y0 = _e[0], y1 = _e[1];
                }
            }
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            hits = this.index.indices(bbox);
            result['1d'].indices = hits;
            return result;
            var _a, _b, _c, _d, _e;
        };
        CircleView.prototype._hit_rect = function (geometry) {
            var bbox, result, sx0, sx1, sy0, sy1, x0, x1, y0, y1;
            sx0 = geometry.sx0, sx1 = geometry.sx1, sy0 = geometry.sy0, sy1 = geometry.sy1;
            _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
            _b = this.renderer.yscale.r_invert(sy0, sy1), y0 = _b[0], y1 = _b[1];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            result = hittest.create_hit_test_result();
            result['1d'].indices = this.index.indices(bbox);
            return result;
            var _a, _b;
        };
        CircleView.prototype._hit_poly = function (geometry) {
            var candidates, hits, i, idx, j, k, ref, ref1, result, results, sx, sy;
            sx = geometry.sx, sy = geometry.sy;
            // TODO (bev) use spatial index to pare candidate list
            candidates = function () {
                results = [];
                for (var j = 0, ref = this.sx.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
                    results.push(j);
                }
                return results;
            }.apply(this);
            hits = [];
            for (i = k = 0, ref1 = candidates.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                idx = candidates[i];
                if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {
                    hits.push(idx);
                }
            }
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
        };
        // circle does not inherit from marker (since it also accepts radius) so we
        // must supply a draw_legend for it  here
        CircleView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            var data, indices, sradius, sx, sy;
            // using objects like this seems a little wonky, since the keys are coerced to
            // stings, but it works
            indices = [index];
            sx = {};
            sx[index] = (x0 + x1) / 2;
            sy = {};
            sy[index] = (y0 + y1) / 2;
            sradius = {};
            sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;
            data = {
                sx: sx,
                sy: sy,
                sradius: sradius
            };
            return this._render(ctx, indices, data);
        };
        return CircleView;
    }(xy_glyph_1.XYGlyphView);
    var Circle = function (_super) {
        tslib_1.__extends(Circle, _super);
        function Circle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Circle.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            return this.properties.radius.optional = true;
        };
        return Circle;
    }(xy_glyph_1.XYGlyph);
    exports.Circle = Circle;
    ;
    Circle.prototype.default_view = exports.CircleView;
    Circle.prototype.type = 'Circle';
    Circle.mixins([
        'line',
        'fill'
    ]);
    Circle.define({
        angle: [
            p.AngleSpec,
            0
        ],
        size: [
            p.DistanceSpec,
            {
                units: 'screen',
                value: 4
            }
        ],
        radius: [
            p.DistanceSpec,
            null
        ],
        radius_dimension: [
            p.String,
            'x'
        ]
    });    
},
/*models/glyphs/ellipse*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var p = require(15    /* core/properties */);
    exports.EllipseView = function (_super) {
        tslib_1.__extends(EllipseView, _super);
        function EllipseView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EllipseView.prototype._set_data = function () {
            this.max_w2 = 0;
            if (this.model.properties.width.units === 'data') {
                this.max_w2 = this.max_width / 2;
            }
            this.max_h2 = 0;
            if (this.model.properties.height.units === 'data') {
                return this.max_h2 = this.max_height / 2;
            }
        };
        EllipseView.prototype._map_data = function () {
            if (this.model.properties.width.units === 'data') {
                this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');
            } else {
                this.sw = this._width;
            }
            if (this.model.properties.height.units === 'data') {
                return this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');
            } else {
                return this.sh = this._height;
            }
        };
        EllipseView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, sw = _a.sw, sh = _a.sh;
            var i, j, len, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {
                    continue;
                }
                ctx.beginPath();
                ctx.ellipse(sx[i], sy[i], sw[i] / 2, sh[i] / 2, this._angle[i], 0, 2 * Math.PI);
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    ctx.fill();
                }
                if (this.visuals.line.doit) {
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        EllipseView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            var d, data, indices, scale, sh, sw, sx, sy;
            indices = [index];
            sx = {};
            sx[index] = (x0 + x1) / 2;
            sy = {};
            sy[index] = (y0 + y1) / 2;
            scale = this.sw[index] / this.sh[index];
            d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;
            sw = {};
            sh = {};
            if (scale > 1) {
                sw[index] = d;
                sh[index] = d / scale;
            } else {
                sw[index] = d * scale;
                sh[index] = d;
            }
            data = {
                sx: sx,
                sy: sy,
                sw: sw,
                sh: sh
            };
            return this._render(ctx, indices, data);
        };
        EllipseView.prototype._bounds = function (bds) {
            return this.max_wh2_bounds(bds);
        };
        return EllipseView;
    }(xy_glyph_1.XYGlyphView);
    var Ellipse = function (_super) {
        tslib_1.__extends(Ellipse, _super);
        function Ellipse() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Ellipse;
    }(xy_glyph_1.XYGlyph);
    exports.Ellipse = Ellipse;
    ;
    Ellipse.prototype.default_view = exports.EllipseView;
    Ellipse.prototype.type = 'Ellipse';
    Ellipse.mixins([
        'line',
        'fill'
    ]);
    Ellipse.define({
        angle: [
            p.AngleSpec,
            0
        ],
        width: [p.DistanceSpec],
        height: [p.DistanceSpec]
    });    
},
/*models/glyphs/glyph*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    var bbox = require(23    /* core/util/bbox */);
    var proj = require(32    /* core/util/projections */);
    var view_1 = require(45    /* core/view */);
    var model_1 = require(50    /* ../../model */);
    var visuals_1 = require(46    /* core/visuals */);
    var logging_1 = require(14    /* core/logging */);
    var object_1 = require(30    /* core/util/object */);
    var types_1 = require(42    /* core/util/types */);
    var line_1 = require(114    /* ./line */);
    exports.GlyphView = function (_super) {
        tslib_1.__extends(GlyphView, _super);
        function GlyphView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GlyphView.prototype.initialize = function (options) {
            var Cls, ctx, e, glglyphs;
            _super.prototype.initialize.call(this, options);
            this._nohit_warned = {};
            this.renderer = options.renderer;
            this.visuals = new visuals_1.Visuals(this.model);
            // Init gl (this should really be done anytime renderer is set,
            // and not done if it isn't ever set, but for now it only
            // matters in the unit tests because we build a view without a
            // renderer there)
            ctx = this.renderer.plot_view.canvas_view.ctx;
            if (ctx.glcanvas != null) {
                try {
                    glglyphs = require(425    /* ./webgl/index */);
                } catch (error) {
                    e = error;
                    if (e.code === 'MODULE_NOT_FOUND') {
                        logging_1.logger.warn('WebGL was requested and is supported, but bokeh-gl(.min).js is not available, falling back to 2D rendering.');
                        glglyphs = null;
                    } else {
                        throw e;
                    }
                }
                if (glglyphs != null) {
                    Cls = glglyphs[this.model.type + 'GLGlyph'];
                    if (Cls != null) {
                        return this.glglyph = new Cls(ctx.glcanvas.gl, this);
                    }
                }
            }
        };
        GlyphView.prototype.set_visuals = function (source) {
            this.visuals.warm_cache(source);
            if (this.glglyph != null) {
                return this.glglyph.set_visuals_changed();
            }
        };
        GlyphView.prototype.render = function (ctx, indices, data) {
            ctx.beginPath();
            if (this.glglyph != null) {
                if (this.glglyph.render(ctx, indices, data)) {
                    return;
                }
            }
            return this._render(ctx, indices, data);
        };
        GlyphView.prototype.has_finished = function () {
            return true;
        };
        GlyphView.prototype.notify_finished = function () {
            return this.renderer.notify_finished();
        };
        GlyphView.prototype.bounds = function () {
            if (this.index == null) {
                return bbox.empty();
            } else {
                return this._bounds(this.index.bbox);
            }
        };
        GlyphView.prototype.log_bounds = function () {
            var bb, j, l, len, len1, positive_x_bbs, positive_y_bbs, x, y;
            if (this.index == null) {
                return bbox.empty();
            }
            bb = bbox.empty();
            positive_x_bbs = this.index.search(bbox.positive_x());
            positive_y_bbs = this.index.search(bbox.positive_y());
            for (j = 0, len = positive_x_bbs.length; j < len; j++) {
                x = positive_x_bbs[j];
                if (x.minX < bb.minX) {
                    bb.minX = x.minX;
                }
                if (x.maxX > bb.maxX) {
                    bb.maxX = x.maxX;
                }
            }
            for (l = 0, len1 = positive_y_bbs.length; l < len1; l++) {
                y = positive_y_bbs[l];
                if (y.minY < bb.minY) {
                    bb.minY = y.minY;
                }
                if (y.maxY > bb.maxY) {
                    bb.maxY = y.maxY;
                }
            }
            return this._bounds(bb);
        };
        // this is available for subclasses to use, if appropriate.
        GlyphView.prototype.max_wh2_bounds = function (bds) {
            return {
                minX: bds.minX - this.max_w2,
                maxX: bds.maxX + this.max_w2,
                minY: bds.minY - this.max_h2,
                maxY: bds.maxY + this.max_h2
            };
        };
        GlyphView.prototype.get_anchor_point = function (anchor, i, _a) {
            var sx = _a[0], sy = _a[1];
            switch (anchor) {
            case 'center':
                return {
                    x: this.scx(i, sx, sy),
                    y: this.scy(i, sx, sy)
                };
            default:
                return null;
            }
        };
        // glyphs that need more sophisticated "snap to data" behaviour (like
        // snapping to a patch centroid, e.g, should override these
        GlyphView.prototype.scx = function (i) {
            return this.sx[i];
        };
        GlyphView.prototype.scy = function (i) {
            return this.sy[i];
        };
        GlyphView.prototype.sdist = function (scale, pts, spans, pts_location, dilate) {
            if (pts_location === void 0) {
                pts_location = 'edge';
            }
            if (dilate === void 0) {
                dilate = false;
            }
            var d, halfspan, i, pt0, pt1, spt0, spt1;
            if (scale.source_range.v_synthetic != null) {
                pts = scale.source_range.v_synthetic(pts);
            }
            if (pts_location === 'center') {
                halfspan = function () {
                    var j, len, results;
                    results = [];
                    for (j = 0, len = spans.length; j < len; j++) {
                        d = spans[j];
                        results.push(d / 2);
                    }
                    return results;
                }();
                pt0 = function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(pts[i] - halfspan[i]);
                    }
                    return results;
                }();
                pt1 = function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = pts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(pts[i] + halfspan[i]);
                    }
                    return results;
                }();
            } else {
                pt0 = pts;
                pt1 = function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(pt0[i] + spans[i]);
                    }
                    return results;
                }();
            }
            spt0 = scale.v_compute(pt0);
            spt1 = scale.v_compute(pt1);
            if (dilate) {
                return function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(Math.ceil(Math.abs(spt1[i] - spt0[i])));
                    }
                    return results;
                }();
            } else {
                return function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(Math.abs(spt1[i] - spt0[i]));
                    }
                    return results;
                }();
            }
        };
        GlyphView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return null;
        };
        GlyphView.prototype._generic_line_legend = function (ctx, x0, x1, y0, y1, index) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x0, (y0 + y1) / 2);
            ctx.lineTo(x1, (y0 + y1) / 2);
            if (this.visuals.line.doit) {
                this.visuals.line.set_vectorize(ctx, index);
                ctx.stroke();
            }
            return ctx.restore();
        };
        GlyphView.prototype._generic_area_legend = function (ctx, x0, x1, y0, y1, index) {
            var dh, dw, h, indices, sx0, sx1, sy0, sy1, w;
            indices = [index];
            w = Math.abs(x1 - x0);
            dw = w * 0.1;
            h = Math.abs(y1 - y0);
            dh = h * 0.1;
            sx0 = x0 + dw;
            sx1 = x1 - dw;
            sy0 = y0 + dh;
            sy1 = y1 - dh;
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_vectorize(ctx, index);
                ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);
            }
            if (this.visuals.line.doit) {
                ctx.beginPath();
                ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);
                this.visuals.line.set_vectorize(ctx, index);
                return ctx.stroke();
            }
        };
        GlyphView.prototype.hit_test = function (geometry) {
            var func, result;
            result = null;
            func = '_hit_' + geometry.type;
            if (this[func] != null) {
                result = this[func](geometry);
            } else if (this._nohit_warned[geometry.type] == null) {
                logging_1.logger.debug('\'' + geometry.type + '\' selection not available for ' + this.model.type);
                this._nohit_warned[geometry.type] = true;
            }
            return result;
        };
        GlyphView.prototype._hit_rect_against_index = function (geometry) {
            var bb, result, sx0, sx1, sy0, sy1, x0, x1, y0, y1;
            sx0 = geometry.sx0, sx1 = geometry.sx1, sy0 = geometry.sy0, sy1 = geometry.sy1;
            _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
            _b = this.renderer.yscale.r_invert(sy0, sy1), y0 = _b[0], y1 = _b[1];
            bb = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            result = hittest.create_hit_test_result();
            result['1d'].indices = this.index.indices(bb);
            return result;
            var _a, _b;
        };
        GlyphView.prototype.set_data = function (source, indices, indices_to_update) {
            var data, data_subset, i, j, k, len, ref, v, xname, xr, yname, yr;
            data = this.model.materialize_dataspecs(source);
            this.visuals.set_all_indices(indices);
            if (indices && !(this instanceof line_1.LineView)) {
                data_subset = {};
                for (k in data) {
                    v = data[k];
                    if (k.charAt(0) === '_') {
                        data_subset[k] = function () {
                            var j, len, results;
                            results = [];
                            for (j = 0, len = indices.length; j < len; j++) {
                                i = indices[j];
                                results.push(v[i]);
                            }
                            return results;
                        }();
                    } else {
                        data_subset[k] = v;
                    }
                }
                data = data_subset;
            }
            object_1.extend(this, data);
            if (this.renderer.plot_view.model.use_map) {
                if (this._x != null) {
                    _a = proj.project_xy(this._x, this._y), this._x = _a[0], this._y = _a[1];
                }
                if (this._xs != null) {
                    _b = proj.project_xsys(this._xs, this._ys), this._xs = _b[0], this._ys = _b[1];
                }
            }
            // if we have any coordinates that are categorical, convert them to
            // synthetic coords here
            if (this.renderer.plot_view.frame.x_ranges != null) {
                xr = this.renderer.plot_view.frame.x_ranges[this.model.x_range_name];
                yr = this.renderer.plot_view.frame.y_ranges[this.model.y_range_name];
                ref = this.model._coords;
                for (j = 0, len = ref.length; j < len; j++) {
                    _c = ref[j], xname = _c[0], yname = _c[1];
                    xname = '_' + xname;
                    yname = '_' + yname;
                    if (xr.v_synthetic != null) {
                        this[xname] = xr.v_synthetic(this[xname]);
                    }
                    if (yr.v_synthetic != null) {
                        this[yname] = yr.v_synthetic(this[yname]);
                    }
                }    // XXXX JUST TEMP FOR TESTS TO PASS
            }
            if (this.glglyph != null) {
                this.glglyph.set_data_changed(this._x.length);
            }
            this._set_data(source, indices_to_update);
            //TODO doesn't take subset indices into account
            return this.index = this._index_data();
            var _a, _b, _c;
        };
        GlyphView.prototype._set_data = function () {
        };
        GlyphView.prototype._index_data = function () {
        };
        GlyphView.prototype.mask_data = function (indices) {
            // WebGL can do the clipping much more efficiently
            if (this.glglyph != null) {
                return indices;
            } else {
                return this._mask_data(indices);
            }
        };
        GlyphView.prototype._mask_data = function (indices) {
            return indices;
        };
        GlyphView.prototype._bounds = function (bounds) {
            return bounds;
        };
        GlyphView.prototype.map_data = function () {
            var i, j, l, len, ref, ref1, ref2, ref3, ref4, sx, sxname, sy, syname, xname, yname;
            ref = this.model._coords;
            // todo: if using gl, skip this (when is this called?)
            // map all the coordinate fields
            for (j = 0, len = ref.length; j < len; j++) {
                _a = ref[j], xname = _a[0], yname = _a[1];
                sxname = 's' + xname;
                syname = 's' + yname;
                xname = '_' + xname;
                yname = '_' + yname;
                if (types_1.isArray((ref1 = this[xname]) != null ? ref1[0] : void 0) || ((ref2 = this[xname]) != null ? (ref3 = ref2[0]) != null ? ref3.buffer : void 0 : void 0) instanceof ArrayBuffer) {
                    _b = [
                        [],
                        []
                    ], this[sxname] = _b[0], this[syname] = _b[1];
                    for (i = l = 0, ref4 = this[xname].length; 0 <= ref4 ? l < ref4 : l > ref4; i = 0 <= ref4 ? ++l : --l) {
                        _c = this.map_to_screen(this[xname][i], this[yname][i]), sx = _c[0], sy = _c[1];
                        this[sxname].push(sx);
                        this[syname].push(sy);
                    }
                } else {
                    _d = this.map_to_screen(this[xname], this[yname]), this[sxname] = _d[0], this[syname] = _d[1];
                }
            }
            return this._map_data();
            var _a, _b, _c, _d;
        };
        // This is where specs not included in coords are computed, e.g. radius.
        GlyphView.prototype._map_data = function () {
        };
        GlyphView.prototype.map_to_screen = function (x, y) {
            return this.renderer.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);
        };
        return GlyphView;
    }(view_1.View);
    var Glyph = function (_super) {
        tslib_1.__extends(Glyph, _super);
        function Glyph() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Glyph.coords = function (coords) {
            var _coords, j, len, result, x, y;
            _coords = this.prototype._coords.concat(coords);
            this.prototype._coords = _coords;
            result = {};
            for (j = 0, len = coords.length; j < len; j++) {
                _a = coords[j], x = _a[0], y = _a[1];
                result[x] = [p.NumberSpec];
                result[y] = [p.NumberSpec];
            }
            return this.define(result);
            var _a;
        };
        return Glyph;
    }(model_1.Model);
    exports.Glyph = Glyph;
    ;
    Glyph.prototype._coords = [];
    Glyph.internal({
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });    
},
/*models/glyphs/hbar*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var box_1 = require(105    /* ./box */);
    var p = require(15    /* core/properties */);
    exports.HBarView = function (_super) {
        tslib_1.__extends(HBarView, _super);
        function HBarView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HBarView.prototype.scx = function (i) {
            return (this.sleft[i] + this.sright[i]) / 2;
        };
        HBarView.prototype._index_data = function () {
            return this._index_box(this._y.length);
        };
        HBarView.prototype._lrtb = function (i) {
            var b, l, r, t;
            l = Math.min(this._left[i], this._right[i]);
            r = Math.max(this._left[i], this._right[i]);
            t = this._y[i] + 0.5 * this._height[i];
            b = this._y[i] - 0.5 * this._height[i];
            return [
                l,
                r,
                t,
                b
            ];
        };
        HBarView.prototype._map_data = function () {
            var i, j, ref;
            this.sy = this.renderer.yscale.v_compute(this._y);
            this.sright = this.renderer.xscale.v_compute(this._right);
            this.sleft = this.renderer.xscale.v_compute(this._left);
            this.stop = [];
            this.sbottom = [];
            this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');
            for (i = j = 0, ref = this.sy.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                this.stop.push(this.sy[i] - this.sh[i] / 2);
                this.sbottom.push(this.sy[i] + this.sh[i] / 2);
            }
            return null;
        };
        return HBarView;
    }(box_1.BoxView);
    var HBar = function (_super) {
        tslib_1.__extends(HBar, _super);
        function HBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return HBar;
    }(box_1.Box);
    exports.HBar = HBar;
    ;
    HBar.prototype.default_view = exports.HBarView;
    HBar.prototype.type = 'HBar';
    HBar.coords([[
            'left',
            'y'
        ]]);
    HBar.define({
        height: [p.DistanceSpec],
        right: [p.NumberSpec]
    });
    HBar.override({ left: 0 });    
},
/*models/glyphs/image*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var Greys9;
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var linear_color_mapper_1 = require(146    /* ../mappers/linear_color_mapper */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    exports.ImageView = function (_super) {
        tslib_1.__extends(ImageView, _super);
        function ImageView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ImageView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.connect(this.model.color_mapper.change, function () {
                return this._update_image();
            });
        };
        ImageView.prototype._update_image = function () {
            // Only reset image_data if already initialized
            if (this.image_data != null) {
                this._set_data();
                return this.renderer.plot_view.request_render();
            }
        };
        ImageView.prototype._set_data = function () {
            var buf, buf8, canvas, cmap, ctx, i, image_data, img, j, ref, results, shape;
            if (this.image_data == null || this.image_data.length !== this._image.length) {
                this.image_data = new Array(this._image.length);
            }
            if (this._width == null || this._width.length !== this._image.length) {
                this._width = new Array(this._image.length);
            }
            if (this._height == null || this._height.length !== this._image.length) {
                this._height = new Array(this._image.length);
            }
            results = [];
            for (i = j = 0, ref = this._image.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                shape = [];
                if (this._image_shape != null) {
                    shape = this._image_shape[i];
                }
                if (shape.length > 0) {
                    img = this._image[i];
                    this._height[i] = shape[0];
                    this._width[i] = shape[1];
                } else {
                    img = array_1.concat(this._image[i]);
                    this._height[i] = this._image[i].length;
                    this._width[i] = this._image[i][0].length;
                }
                if (this.image_data[i] != null && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {
                    canvas = this.image_data[i];
                } else {
                    canvas = document.createElement('canvas');
                    canvas.width = this._width[i];
                    canvas.height = this._height[i];
                }
                ctx = canvas.getContext('2d');
                image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);
                cmap = this.model.color_mapper;
                buf = cmap.v_map_screen(img, true);
                buf8 = new Uint8Array(buf);
                image_data.data.set(buf8);
                ctx.putImageData(image_data, 0, 0);
                this.image_data[i] = canvas;
                this.max_dw = 0;
                if (this._dw.units === 'data') {
                    this.max_dw = array_1.max(this._dw);
                }
                this.max_dh = 0;
                if (this._dh.units === 'data') {
                    results.push(this.max_dh = array_1.max(this._dh));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        ImageView.prototype._map_data = function () {
            switch (this.model.properties.dw.units) {
            case 'data':
                this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);
                break;
            case 'screen':
                this.sw = this._dw;
            }
            switch (this.model.properties.dh.units) {
            case 'data':
                return this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);
            case 'screen':
                return this.sh = this._dh;
            }
        };
        ImageView.prototype._render = function (ctx, indices, _a) {
            var image_data = _a.image_data, sx = _a.sx, sy = _a.sy, sw = _a.sw, sh = _a.sh;
            var i, j, len, old_smoothing, y_offset;
            old_smoothing = ctx.getImageSmoothingEnabled();
            ctx.setImageSmoothingEnabled(false);
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (image_data[i] == null) {
                    continue;
                }
                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {
                    continue;
                }
                y_offset = sy[i];
                ctx.translate(0, y_offset);
                ctx.scale(1, -1);
                ctx.translate(0, -y_offset);
                ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);
                ctx.translate(0, y_offset);
                ctx.scale(1, -1);
                ctx.translate(0, -y_offset);
            }
            return ctx.setImageSmoothingEnabled(old_smoothing);
        };
        ImageView.prototype.bounds = function () {
            var bbox;
            bbox = this.index.bbox;
            bbox.maxX += this.max_dw;
            bbox.maxY += this.max_dh;
            return bbox;
        };
        return ImageView;
    }(xy_glyph_1.XYGlyphView);
    // NOTE: this needs to be redefined here, because palettes are located in bokeh-api.js bundle
    Greys9 = function () {
        return [
            0,
            2434341,
            5395026,
            7566195,
            9868950,
            12434877,
            14277081,
            15790320,
            16777215
        ];
    };
    var Image = function (_super) {
        tslib_1.__extends(Image, _super);
        function Image() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Image;
    }(xy_glyph_1.XYGlyph);
    exports.Image = Image;
    ;
    Image.prototype.default_view = exports.ImageView;
    Image.prototype.type = 'Image';
    Image.define({
        image: [p.NumberSpec],
        dw: [p.DistanceSpec],
        dh: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ],
        color_mapper: [
            p.Instance,
            function () {
                return new linear_color_mapper_1.LinearColorMapper({ palette: Greys9() });
            }
        ]
    });    
},
/*models/glyphs/image_rgba*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    exports.ImageRGBAView = function (_super) {
        tslib_1.__extends(ImageRGBAView, _super);
        function ImageRGBAView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ImageRGBAView.prototype._set_data = function (source, indices) {
            var buf, buf8, canvas, color, ctx, flat, i, image_data, j, k, l, ref, ref1, results, shape;
            if (this.image_data == null || this.image_data.length !== this._image.length) {
                this.image_data = new Array(this._image.length);
            }
            if (this._width == null || this._width.length !== this._image.length) {
                this._width = new Array(this._image.length);
            }
            if (this._height == null || this._height.length !== this._image.length) {
                this._height = new Array(this._image.length);
            }
            results = [];
            for (i = k = 0, ref = this._image.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                if (indices != null && indices.indexOf(i) < 0) {
                    continue;
                }
                shape = [];
                if (this._image_shape != null) {
                    shape = this._image_shape[i];
                }
                if (shape.length > 0) {
                    buf = this._image[i].buffer;
                    this._height[i] = shape[0];
                    this._width[i] = shape[1];
                } else {
                    flat = array_1.concat(this._image[i]);
                    buf = new ArrayBuffer(flat.length * 4);
                    color = new Uint32Array(buf);
                    for (j = l = 0, ref1 = flat.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                        color[j] = flat[j];
                    }
                    this._height[i] = this._image[i].length;
                    this._width[i] = this._image[i][0].length;
                }
                if (this.image_data[i] != null && this.image_data[i].width === this._width[i] && this.image_data[i].height === this._height[i]) {
                    canvas = this.image_data[i];
                } else {
                    canvas = document.createElement('canvas');
                    canvas.width = this._width[i];
                    canvas.height = this._height[i];
                }
                ctx = canvas.getContext('2d');
                image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);
                buf8 = new Uint8Array(buf);
                image_data.data.set(buf8);
                ctx.putImageData(image_data, 0, 0);
                this.image_data[i] = canvas;
                this.max_dw = 0;
                if (this._dw.units === 'data') {
                    this.max_dw = array_1.max(this._dw);
                }
                this.max_dh = 0;
                if (this._dh.units === 'data') {
                    results.push(this.max_dh = array_1.max(this._dh));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        ImageRGBAView.prototype._map_data = function () {
            switch (this.model.properties.dw.units) {
            case 'data':
                this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);
                break;
            case 'screen':
                this.sw = this._dw;
            }
            switch (this.model.properties.dh.units) {
            case 'data':
                return this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);
            case 'screen':
                return this.sh = this._dh;
            }
        };
        ImageRGBAView.prototype._render = function (ctx, indices, _a) {
            var image_data = _a.image_data, sx = _a.sx, sy = _a.sy, sw = _a.sw, sh = _a.sh;
            var i, k, len, old_smoothing, y_offset;
            old_smoothing = ctx.getImageSmoothingEnabled();
            ctx.setImageSmoothingEnabled(false);
            for (k = 0, len = indices.length; k < len; k++) {
                i = indices[k];
                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i])) {
                    continue;
                }
                y_offset = sy[i];
                ctx.translate(0, y_offset);
                ctx.scale(1, -1);
                ctx.translate(0, -y_offset);
                ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);
                ctx.translate(0, y_offset);
                ctx.scale(1, -1);
                ctx.translate(0, -y_offset);
            }
            return ctx.setImageSmoothingEnabled(old_smoothing);
        };
        ImageRGBAView.prototype.bounds = function () {
            var bbox;
            bbox = this.index.bbox;
            bbox.maxX += this.max_dw;
            bbox.maxY += this.max_dh;
            return bbox;
        };
        return ImageRGBAView;
    }(xy_glyph_1.XYGlyphView);
    var ImageRGBA = function (_super) {
        tslib_1.__extends(ImageRGBA, _super);
        function ImageRGBA() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ImageRGBA;
    }(xy_glyph_1.XYGlyph);
    exports.ImageRGBA = ImageRGBA;
    ;
    ImageRGBA.prototype.default_view = exports.ImageRGBAView;
    ImageRGBA.prototype.type = 'ImageRGBA';
    ImageRGBA.define({
        image: [p.NumberSpec],
        dw: [p.DistanceSpec],
        dh: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ]
    });    
},
/*models/glyphs/image_url*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var glyph_1 = require(108    /* ./glyph */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    exports.ImageURLView = function (_super) {
        tslib_1.__extends(ImageURLView, _super);
        function ImageURLView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ImageURLView.prototype.initialize = function (options) {
            var _this = this;
            _super.prototype.initialize.call(this, options);
            return this.connect(this.model.properties.global_alpha.change, function () {
                return _this.renderer.request_render();
            });
        };
        ImageURLView.prototype._index_data = function () {
        };
        ImageURLView.prototype._set_data = function () {
            var _this = this;
            var i, img, j, ref, results, retry_attempts, retry_timeout;
            if (this.image == null || this.image.length !== this._url.length) {
                this.image = function () {
                    var j, len, ref, results;
                    ref = this._url;
                    results = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                        img = ref[j];
                        results.push(null);
                    }
                    return results;
                }.call(this);
            }
            retry_attempts = this.model.retry_attempts;
            retry_timeout = this.model.retry_timeout;
            this.retries = function () {
                var j, len, ref, results;
                ref = this._url;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    img = ref[j];
                    results.push(retry_attempts);
                }
                return results;
            }.call(this);
            results = [];
            for (i = j = 0, ref = this._url.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (this._url[i] == null) {
                    continue;
                }
                img = new Image();
                img.onerror = function (i, img) {
                    return function () {
                        if (_this.retries[i] > 0) {
                            logging_1.logger.trace('ImageURL failed to load ' + _this._url[i] + ' image, retrying in ' + retry_timeout + ' ms');
                            setTimeout(function () {
                                return img.src = _this._url[i];
                            }, retry_timeout);
                        } else {
                            logging_1.logger.warn('ImageURL unable to load ' + _this._url[i] + ' image after ' + retry_attempts + ' retries');
                        }
                        return _this.retries[i] -= 1;
                    };
                }(i, img);
                img.onload = function (img, i) {
                    return function () {
                        _this.image[i] = img;
                        return _this.renderer.request_render();
                    };
                }(img, i);
                results.push(img.src = this._url[i]);
            }
            return results;
        };
        ImageURLView.prototype.has_finished = function () {
            return _super.prototype.has_finished.call(this) && this._images_rendered === true;
        };
        ImageURLView.prototype._map_data = function () {
            var hs, ws, x;
            // Better to check @model.w and @model.h for null since the set_data
            // machinery will have converted @_w and @_w to lists of null
            ws = function () {
                var j, len, ref, results;
                if (this.model.w != null) {
                    return this._w;
                } else {
                    ref = this._x;
                    results = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                        x = ref[j];
                        results.push(0 / 0);
                    }
                    return results;
                }
            }.call(this);
            hs = function () {
                var j, len, ref, results;
                if (this.model.h != null) {
                    return this._h;
                } else {
                    ref = this._x;
                    results = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                        x = ref[j];
                        results.push(0 / 0);
                    }
                    return results;
                }
            }.call(this);
            switch (this.model.properties.w.units) {
            case 'data':
                this.sw = this.sdist(this.renderer.xscale, this._x, ws, 'edge', this.model.dilate);
                break;
            case 'screen':
                this.sw = ws;
            }
            switch (this.model.properties.h.units) {
            case 'data':
                return this.sh = this.sdist(this.renderer.yscale, this._y, hs, 'edge', this.model.dilate);
            case 'screen':
                return this.sh = hs;
            }
        };
        ImageURLView.prototype._render = function (ctx, indices, _a) {
            var _url = _a._url, image = _a.image, sx = _a.sx, sy = _a.sy, sw = _a.sw, sh = _a.sh, _angle = _a._angle;
            var finished, frame, i, j, len;
            // TODO (bev): take actual border width into account when clipping
            frame = this.renderer.plot_view.frame;
            ctx.rect(frame._left.value + 1, frame._top.value + 1, frame._width.value - 2, frame._height.value - 2);
            ctx.clip();
            finished = true;
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + _angle[i])) {
                    continue;
                }
                if (this.retries[i] === -1) {
                    continue;
                }
                if (image[i] == null) {
                    finished = false;
                    continue;
                }
                this._render_image(ctx, i, image[i], sx, sy, sw, sh, _angle);
            }
            if (finished && !this._images_rendered) {
                this._images_rendered = true;
                return this.notify_finished();
            }
        };
        ImageURLView.prototype._final_sx_sy = function (anchor, sx, sy, sw, sh) {
            switch (anchor) {
            case 'top_left':
                return [
                    sx,
                    sy
                ];
            case 'top_center':
                return [
                    sx - sw / 2,
                    sy
                ];
            case 'top_right':
                return [
                    sx - sw,
                    sy
                ];
            case 'center_right':
                return [
                    sx - sw,
                    sy - sh / 2
                ];
            case 'bottom_right':
                return [
                    sx - sw,
                    sy - sh
                ];
            case 'bottom_center':
                return [
                    sx - sw / 2,
                    sy - sh
                ];
            case 'bottom_left':
                return [
                    sx,
                    sy - sh
                ];
            case 'center_left':
                return [
                    sx,
                    sy - sh / 2
                ];
            case 'center':
                return [
                    sx - sw / 2,
                    sy - sh / 2
                ];
            }
        };
        ImageURLView.prototype._render_image = function (ctx, i, image, sx, sy, sw, sh, angle) {
            var anchor;
            if (isNaN(sw[i])) {
                sw[i] = image.width;
            }
            if (isNaN(sh[i])) {
                sh[i] = image.height;
            }
            anchor = this.model.anchor;
            _a = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]), sx = _a[0], sy = _a[1];
            ctx.save();
            ctx.globalAlpha = this.model.global_alpha;
            if (angle[i]) {
                ctx.translate(sx, sy);
                ctx.rotate(angle[i]);
                ctx.drawImage(image, 0, 0, sw[i], sh[i]);
                ctx.rotate(-angle[i]);
                ctx.translate(-sx, -sy);
            } else {
                ctx.drawImage(image, sx, sy, sw[i], sh[i]);
            }
            return ctx.restore();
            var _a;
        };
        return ImageURLView;
    }(glyph_1.GlyphView);
    var ImageURL = function (_super) {
        tslib_1.__extends(ImageURL, _super);
        function ImageURL() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ImageURL;
    }(glyph_1.Glyph);
    exports.ImageURL = ImageURL;
    ;
    ImageURL.prototype.default_view = exports.ImageURLView;
    ImageURL.prototype.type = 'ImageURL';
    ImageURL.coords([[
            'x',
            'y'
        ]]);
    ImageURL.mixins([]);
    ImageURL.define({
        url: [p.StringSpec],
        anchor: [
            p.Anchor,
            'top_left'
        ],
        global_alpha: [
            p.Number,
            1
        ],
        angle: [
            p.AngleSpec,
            0
        ],
        w: [p.DistanceSpec],
        h: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ],
        retry_attempts: [
            p.Number,
            0
        ],
        retry_timeout: [
            p.Number,
            0
        ]
    });    
},
/*models/glyphs/index*/
function _(require, module, exports) {
    var annular_wedge_1 = require(101    /* ./annular_wedge */);
    exports.AnnularWedge = annular_wedge_1.AnnularWedge;
    var annulus_1 = require(102    /* ./annulus */);
    exports.Annulus = annulus_1.Annulus;
    var arc_1 = require(103    /* ./arc */);
    exports.Arc = arc_1.Arc;
    var bezier_1 = require(104    /* ./bezier */);
    exports.Bezier = bezier_1.Bezier;
    var circle_1 = require(106    /* ./circle */);
    exports.Circle = circle_1.Circle;
    var ellipse_1 = require(107    /* ./ellipse */);
    exports.Ellipse = ellipse_1.Ellipse;
    var glyph_1 = require(108    /* ./glyph */);
    exports.Glyph = glyph_1.Glyph;
    var hbar_1 = require(109    /* ./hbar */);
    exports.HBar = hbar_1.HBar;
    var image_1 = require(110    /* ./image */);
    exports.Image = image_1.Image;
    var image_rgba_1 = require(111    /* ./image_rgba */);
    exports.ImageRGBA = image_rgba_1.ImageRGBA;
    var image_url_1 = require(112    /* ./image_url */);
    exports.ImageURL = image_url_1.ImageURL;
    var line_1 = require(114    /* ./line */);
    exports.Line = line_1.Line;
    var multi_line_1 = require(115    /* ./multi_line */);
    exports.MultiLine = multi_line_1.MultiLine;
    var oval_1 = require(116    /* ./oval */);
    exports.Oval = oval_1.Oval;
    var patch_1 = require(117    /* ./patch */);
    exports.Patch = patch_1.Patch;
    var patches_1 = require(118    /* ./patches */);
    exports.Patches = patches_1.Patches;
    var quad_1 = require(119    /* ./quad */);
    exports.Quad = quad_1.Quad;
    var quadratic_1 = require(120    /* ./quadratic */);
    exports.Quadratic = quadratic_1.Quadratic;
    var ray_1 = require(121    /* ./ray */);
    exports.Ray = ray_1.Ray;
    var rect_1 = require(122    /* ./rect */);
    exports.Rect = rect_1.Rect;
    var segment_1 = require(123    /* ./segment */);
    exports.Segment = segment_1.Segment;
    var step_1 = require(124    /* ./step */);
    exports.Step = step_1.Step;
    var text_1 = require(125    /* ./text */);
    exports.Text = text_1.Text;
    var vbar_1 = require(126    /* ./vbar */);
    exports.VBar = vbar_1.VBar;
    var wedge_1 = require(127    /* ./wedge */);
    exports.Wedge = wedge_1.Wedge;
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    exports.XYGlyph = xy_glyph_1.XYGlyph;    
},
/*models/glyphs/line*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var hittest = require(9    /* core/hittest */);
    exports.LineView = function (_super) {
        tslib_1.__extends(LineView, _super);
        function LineView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LineView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy;
            var drawing, i, j, last_index, len;
            drawing = false;
            this.visuals.line.set_value(ctx);
            last_index = null;
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (drawing) {
                    if (!isFinite(sx[i] + sy[i])) {
                        ctx.stroke();
                        ctx.beginPath();
                        drawing = false;
                        last_index = i;
                        continue;
                    }
                    if (last_index !== null && i - last_index > 1) {
                        ctx.stroke();
                        drawing = false;
                    }
                }
                if (drawing) {
                    ctx.lineTo(sx[i], sy[i]);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(sx[i], sy[i]);
                    drawing = true;
                }
                last_index = i;
            }
            if (drawing) {
                return ctx.stroke();
            }
        };
        LineView.prototype._hit_point = function (geometry) {
            /* Check if the point geometry hits this line glyph and return an object
        that describes the hit result:
          Args:
            * geometry (object): object with the following keys
              * sx (float): screen x coordinate of the point
              * sy (float): screen y coordinate of the point
              * type (str): type of geometry (in this case it's a point)
          Output:
            Object with the following keys:
              * 0d (bool): whether the point hits the glyph or not
              * 1d (array(int)): array with the indices hit by the point
         */
            var dist, i, j, p0, p1, point, ref, result, shortest, threshold;
            result = hittest.create_hit_test_result();
            point = {
                x: geometry.sx,
                y: geometry.sy
            };
            shortest = 9999;
            threshold = Math.max(2, this.visuals.line.line_width.value() / 2);
            for (i = j = 0, ref = this.sx.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                _a = [
                    {
                        x: this.sx[i],
                        y: this.sy[i]
                    },
                    {
                        x: this.sx[i + 1],
                        y: this.sy[i + 1]
                    }
                ], p0 = _a[0], p1 = _a[1];
                dist = hittest.dist_to_segment(point, p0, p1);
                if (dist < threshold && dist < shortest) {
                    shortest = dist;
                    result['0d'].glyph = this.model;
                    result['0d'].get_view = function () {
                        return this;
                    }.bind(this);
                    result['0d'].flag = true;
                    // backward compat
                    result['0d'].indices = [i];
                }
            }
            return result;
            var _a;
        };
        LineView.prototype._hit_span = function (geometry) {
            var i, j, ref, result, sx, sy, val, values;
            sx = geometry.sx, sy = geometry.sy;
            result = hittest.create_hit_test_result();
            if (geometry.direction === 'v') {
                val = this.renderer.yscale.invert(sy);
                values = this._y;
            } else {
                val = this.renderer.xscale.invert(sx);
                values = this._x;
            }
            for (i = j = 0, ref = values.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (values[i] <= val && val <= values[i + 1] || values[i + 1] <= val && val <= values[i]) {
                    result['0d'].glyph = this.model;
                    result['0d'].get_view = function () {
                        return this;
                    }.bind(this);
                    result['0d'].flag = true;
                    // backward compat
                    result['0d'].indices.push(i);
                }
            }
            return result;
        };
        LineView.prototype.get_interpolation_hit = function (i, geometry) {
            var res, sx, sy, x0, x1, x2, x3, y0, y1, y2, y3;
            sx = geometry.sx, sy = geometry.sy;
            _a = [
                this._x[i],
                this._y[i],
                this._x[i + 1],
                this._y[i + 1]
            ], x2 = _a[0], y2 = _a[1], x3 = _a[2], y3 = _a[3];
            if (geometry.type === 'point') {
                _b = this.renderer.yscale.r_invert(sy - 1, sy + 1), y0 = _b[0], y1 = _b[1];
                _c = this.renderer.xscale.r_invert(sx - 1, sx + 1), x0 = _c[0], x1 = _c[1];
            } else {
                if (geometry.direction === 'v') {
                    _d = this.renderer.yscale.r_invert(sy, sy), y0 = _d[0], y1 = _d[1];
                    _e = [
                        x2,
                        x3
                    ], x0 = _e[0], x1 = _e[1];
                } else {
                    _f = this.renderer.xscale.r_invert(sx, sx), x0 = _f[0], x1 = _f[1];
                    _g = [
                        y2,
                        y3
                    ], y0 = _g[0], y1 = _g[1];
                }
            }
            res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);
            return [
                res.x,
                res.y
            ];
            var _a, _b, _c, _d, _e, _f, _g;
        };
        LineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return LineView;
    }(xy_glyph_1.XYGlyphView);
    var Line = function (_super) {
        tslib_1.__extends(Line, _super);
        function Line() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Line;
    }(xy_glyph_1.XYGlyph);
    exports.Line = Line;
    ;
    Line.prototype.default_view = exports.LineView;
    Line.prototype.type = 'Line';
    Line.mixins(['line']);    
},
/*models/glyphs/multi_line*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var spatial_1 = require(36    /* core/util/spatial */);
    var hittest = require(9    /* core/hittest */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    var glyph_1 = require(108    /* ./glyph */);
    exports.MultiLineView = function (_super) {
        tslib_1.__extends(MultiLineView, _super);
        function MultiLineView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MultiLineView.prototype._index_data = function () {
            var i, k, points, ref, x, xs, y, ys;
            points = [];
            for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                if (this._xs[i] === null || this._xs[i].length === 0) {
                    continue;
                }
                xs = function () {
                    var l, len, ref1, results;
                    ref1 = this._xs[i];
                    results = [];
                    for (l = 0, len = ref1.length; l < len; l++) {
                        x = ref1[l];
                        if (!types_1.isStrictNaN(x)) {
                            results.push(x);
                        }
                    }
                    return results;
                }.call(this);
                ys = function () {
                    var l, len, ref1, results;
                    ref1 = this._ys[i];
                    results = [];
                    for (l = 0, len = ref1.length; l < len; l++) {
                        y = ref1[l];
                        if (!types_1.isStrictNaN(y)) {
                            results.push(y);
                        }
                    }
                    return results;
                }.call(this);
                points.push({
                    minX: array_1.min(xs),
                    minY: array_1.min(ys),
                    maxX: array_1.max(xs),
                    maxY: array_1.max(ys),
                    i: i
                });
            }
            return new spatial_1.RBush(points);
        };
        MultiLineView.prototype._render = function (ctx, indices, _a) {
            var sxs = _a.sxs, sys = _a.sys;
            var i, j, k, l, len, ref, results, sx, sy;
            results = [];
            for (k = 0, len = indices.length; k < len; k++) {
                i = indices[k];
                _b = [
                    sxs[i],
                    sys[i]
                ], sx = _b[0], sy = _b[1];
                this.visuals.line.set_vectorize(ctx, i);
                for (j = l = 0, ref = sx.length; 0 <= ref ? l < ref : l > ref; j = 0 <= ref ? ++l : --l) {
                    if (j === 0) {
                        ctx.beginPath();
                        ctx.moveTo(sx[j], sy[j]);
                        continue;
                    } else if (isNaN(sx[j]) || isNaN(sy[j])) {
                        ctx.stroke();
                        ctx.beginPath();
                        continue;
                    } else {
                        ctx.lineTo(sx[j], sy[j]);
                    }
                }
                results.push(ctx.stroke());
            }
            return results;
            var _b;
        };
        MultiLineView.prototype._hit_point = function (geometry) {
            var dist, hits, i, j, k, l, p0, p1, point, points, ref, ref1, result, shortest, threshold;
            result = hittest.create_hit_test_result();
            point = {
                x: geometry.sx,
                y: geometry.sy
            };
            shortest = 9999;
            hits = {};
            for (i = k = 0, ref = this.sxs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);
                points = null;
                for (j = l = 0, ref1 = this.sxs[i].length - 1; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                    _a = [
                        {
                            x: this.sxs[i][j],
                            y: this.sys[i][j]
                        },
                        {
                            x: this.sxs[i][j + 1],
                            y: this.sys[i][j + 1]
                        }
                    ], p0 = _a[0], p1 = _a[1];
                    dist = hittest.dist_to_segment(point, p0, p1);
                    if (dist < threshold && dist < shortest) {
                        shortest = dist;
                        points = [j];
                    }
                }
                if (points) {
                    hits[i] = points;
                }
            }
            result['1d'].indices = function () {
                var len, m, ref2, results;
                ref2 = Object.keys(hits);
                results = [];
                for (m = 0, len = ref2.length; m < len; m++) {
                    i = ref2[m];
                    results.push(parseInt(i));
                }
                return results;
            }();
            result['2d'].indices = hits;
            return result;
            var _a;
        };
        MultiLineView.prototype._hit_span = function (geometry) {
            var hits, i, j, k, l, points, ref, ref1, result, sx, sy, val, values;
            sx = geometry.sx, sy = geometry.sy;
            result = hittest.create_hit_test_result();
            if (geometry.direction === 'v') {
                val = this.renderer.yscale.invert(sy);
                values = this._ys;
            } else {
                val = this.renderer.xscale.invert(sx);
                values = this._xs;
            }
            hits = {};
            for (i = k = 0, ref = values.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                points = [];
                for (j = l = 0, ref1 = values[i].length - 1; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                    if (values[i][j] <= val && val <= values[i][j + 1]) {
                        points.push(j);
                    }
                }
                if (points.length > 0) {
                    hits[i] = points;
                }
            }
            result['1d'].indices = function () {
                var len, m, ref2, results;
                ref2 = Object.keys(hits);
                results = [];
                for (m = 0, len = ref2.length; m < len; m++) {
                    i = ref2[m];
                    results.push(parseInt(i));
                }
                return results;
            }();
            result['2d'].indices = hits;
            return result;
        };
        MultiLineView.prototype.get_interpolation_hit = function (i, point_i, geometry) {
            var res, sx, sy, x0, x1, x2, x3, y0, y1, y2, y3;
            sx = geometry.sx, sy = geometry.sy;
            _a = [
                this._xs[i][point_i],
                this._ys[i][point_i],
                this._xs[i][point_i + 1],
                this._ys[i][point_i + 1]
            ], x2 = _a[0], y2 = _a[1], x3 = _a[2], y3 = _a[3];
            if (geometry.type === 'point') {
                _b = this.renderer.yscale.r_invert(sy - 1, sy + 1), y0 = _b[0], y1 = _b[1];
                _c = this.renderer.xscale.r_invert(sx - 1, sx + 1), x0 = _c[0], x1 = _c[1];
            } else {
                if (geometry.direction === 'v') {
                    _d = this.renderer.yscale.r_invert(sy, sy), y0 = _d[0], y1 = _d[1];
                    _e = [
                        x2,
                        x3
                    ], x0 = _e[0], x1 = _e[1];
                } else {
                    _f = this.renderer.xscale.r_invert(sx, sx), x0 = _f[0], x1 = _f[1];
                    _g = [
                        y2,
                        y3
                    ], y0 = _g[0], y1 = _g[1];
                }
            }
            res = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);
            return [
                res.x,
                res.y
            ];
            var _a, _b, _c, _d, _e, _f, _g;
        };
        MultiLineView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return MultiLineView;
    }(glyph_1.GlyphView);
    var MultiLine = function (_super) {
        tslib_1.__extends(MultiLine, _super);
        function MultiLine() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return MultiLine;
    }(glyph_1.Glyph);
    exports.MultiLine = MultiLine;
    ;
    MultiLine.prototype.default_view = exports.MultiLineView;
    MultiLine.prototype.type = 'MultiLine';
    MultiLine.coords([[
            'xs',
            'ys'
        ]]);
    MultiLine.mixins(['line']);    
},
/*models/glyphs/oval*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var p = require(15    /* core/properties */);
    exports.OvalView = function (_super) {
        tslib_1.__extends(OvalView, _super);
        function OvalView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OvalView.prototype._set_data = function () {
            this.max_w2 = 0;
            if (this.model.properties.width.units === 'data') {
                this.max_w2 = this.max_width / 2;
            }
            this.max_h2 = 0;
            if (this.model.properties.height.units === 'data') {
                return this.max_h2 = this.max_height / 2;
            }
        };
        OvalView.prototype._map_data = function () {
            if (this.model.properties.width.units === 'data') {
                this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');
            } else {
                this.sw = this._width;
            }
            if (this.model.properties.height.units === 'data') {
                return this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');
            } else {
                return this.sh = this._height;
            }
        };
        OvalView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, sw = _a.sw, sh = _a.sh;
            var i, j, len, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this._angle[i])) {
                    continue;
                }
                ctx.translate(sx[i], sy[i]);
                ctx.rotate(this._angle[i]);
                ctx.beginPath();
                ctx.moveTo(0, -sh[i] / 2);
                ctx.bezierCurveTo(sw[i] / 2, -sh[i] / 2, sw[i] / 2, sh[i] / 2, 0, sh[i] / 2);
                ctx.bezierCurveTo(-sw[i] / 2, sh[i] / 2, -sw[i] / 2, -sh[i] / 2, 0, -sh[i] / 2);
                ctx.closePath();
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    ctx.fill();
                }
                if (this.visuals.line.doit) {
                    this.visuals.line.set_vectorize(ctx, i);
                    ctx.stroke();
                }
                ctx.rotate(-this._angle[i]);
                results.push(ctx.translate(-sx[i], -sy[i]));
            }
            return results;
        };
        OvalView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            var d, data, indices, scale, sh, sw, sx, sy;
            indices = [index];
            sx = {};
            sx[index] = (x0 + x1) / 2;
            sy = {};
            sy[index] = (y0 + y1) / 2;
            scale = this.sw[index] / this.sh[index];
            d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;
            sw = {};
            sh = {};
            if (scale > 1) {
                sw[index] = d;
                sh[index] = d / scale;
            } else {
                sw[index] = d * scale;
                sh[index] = d;
            }
            data = {
                sx: sx,
                sy: sy,
                sw: sw,
                sh: sh
            };
            return this._render(ctx, indices, data);
        };
        OvalView.prototype._bounds = function (bds) {
            return this.max_wh2_bounds(bds);
        };
        return OvalView;
    }(xy_glyph_1.XYGlyphView);
    var Oval = function (_super) {
        tslib_1.__extends(Oval, _super);
        function Oval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Oval;
    }(xy_glyph_1.XYGlyph);
    exports.Oval = Oval;
    ;
    Oval.prototype.default_view = exports.OvalView;
    Oval.prototype.type = 'Oval';
    Oval.mixins([
        'line',
        'fill'
    ]);
    Oval.define({
        angle: [
            p.AngleSpec,
            0
        ],
        width: [p.DistanceSpec],
        height: [p.DistanceSpec]
    });    
},
/*models/glyphs/patch*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    exports.PatchView = function (_super) {
        tslib_1.__extends(PatchView, _super);
        function PatchView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PatchView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy;
            var i, j, k, len, len1;
            if (this.visuals.fill.doit) {
                this.visuals.fill.set_value(ctx);
                for (j = 0, len = indices.length; j < len; j++) {
                    i = indices[j];
                    if (i === 0) {
                        ctx.beginPath();
                        ctx.moveTo(sx[i], sy[i]);
                        continue;
                    } else if (isNaN(sx[i] + sy[i])) {
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        continue;
                    } else {
                        ctx.lineTo(sx[i], sy[i]);
                    }
                }
                ctx.closePath();
                ctx.fill();
            }
            if (this.visuals.line.doit) {
                this.visuals.line.set_value(ctx);
                for (k = 0, len1 = indices.length; k < len1; k++) {
                    i = indices[k];
                    if (i === 0) {
                        ctx.beginPath();
                        ctx.moveTo(sx[i], sy[i]);
                        continue;
                    } else if (isNaN(sx[i] + sy[i])) {
                        ctx.closePath();
                        ctx.stroke();
                        ctx.beginPath();
                        continue;
                    } else {
                        ctx.lineTo(sx[i], sy[i]);
                    }
                }
                ctx.closePath();
                return ctx.stroke();
            }
        };
        PatchView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
        };
        return PatchView;
    }(xy_glyph_1.XYGlyphView);
    var Patch = function (_super) {
        tslib_1.__extends(Patch, _super);
        function Patch() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Patch;
    }(xy_glyph_1.XYGlyph);
    exports.Patch = Patch;
    ;
    Patch.prototype.default_view = exports.PatchView;
    Patch.prototype.type = 'Patch';
    Patch.mixins([
        'line',
        'fill'
    ]);    
},
/*models/glyphs/patches*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var spatial_1 = require(36    /* core/util/spatial */);
    var glyph_1 = require(108    /* ./glyph */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    var hittest = require(9    /* core/hittest */);
    exports.PatchesView = function (_super) {
        tslib_1.__extends(PatchesView, _super);
        function PatchesView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PatchesView.prototype._build_discontinuous_object = function (nanned_qs) {
            var denanned, ds, i, k, nan_index, q, qs, qs_part, ref;
            // _s is @xs, @ys, @sxs, @sys
            // an object of n 1-d arrays in either data or screen units
            // Each 1-d array gets broken to an array of arrays split
            // on any NaNs
            // So:
            // { 0: [x11, x12],
            //   1: [x21, x22, x23],
            //   2: [x31, NaN, x32]
            // }
            // becomes
            // { 0: [[x11, x12]],
            //   1: [[x21, x22, x23]],
            //   2: [[x31],[x32]]
            // }
            ds = {};
            for (i = k = 0, ref = nanned_qs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                ds[i] = [];
                qs = array_1.copy(nanned_qs[i]);
                while (qs.length > 0) {
                    nan_index = array_1.findLastIndex(qs, function (q) {
                        return types_1.isStrictNaN(q);
                    });
                    if (nan_index >= 0) {
                        qs_part = qs.splice(nan_index);
                    } else {
                        qs_part = qs;
                        qs = [];
                    }
                    denanned = function () {
                        var l, len, results;
                        results = [];
                        for (l = 0, len = qs_part.length; l < len; l++) {
                            q = qs_part[l];
                            if (!types_1.isStrictNaN(q)) {
                                results.push(q);
                            }
                        }
                        return results;
                    }();
                    ds[i].push(denanned);
                }
            }
            return ds;
        };
        PatchesView.prototype._index_data = function () {
            var i, j, k, l, points, ref, ref1, xs, xss, ys, yss;
            xss = this._build_discontinuous_object(this._xs);
            yss = this._build_discontinuous_object(this._ys);
            points = [];
            for (i = k = 0, ref = this._xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                for (j = l = 0, ref1 = xss[i].length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                    xs = xss[i][j];
                    ys = yss[i][j];
                    if (xs.length === 0) {
                        continue;
                    }
                    points.push({
                        minX: array_1.min(xs),
                        minY: array_1.min(ys),
                        maxX: array_1.max(xs),
                        maxY: array_1.max(ys),
                        i: i
                    });
                }
            }
            return new spatial_1.RBush(points);
        };
        PatchesView.prototype._mask_data = function (all_indices) {
            var bbox, indices, x0, x1, xr, y0, y1, yr;
            xr = this.renderer.plot_view.frame.x_ranges.default;
            _a = [
                xr.min,
                xr.max
            ], x0 = _a[0], x1 = _a[1];
            yr = this.renderer.plot_view.frame.y_ranges.default;
            _b = [
                yr.min,
                yr.max
            ], y0 = _b[0], y1 = _b[1];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            indices = this.index.indices(bbox);
            // TODO (bev) this should be under test
            return indices.sort(function (a, b) {
                return a - b;
            });
            var _a, _b;
        };
        PatchesView.prototype._render = function (ctx, indices, _a) {
            var sxs = _a.sxs, sys = _a.sys;
            var i, j, k, l, len, m, ref, ref1, results, sx, sy;
            // @sxss and @syss are used by _hit_point and sxc, syc
            // This is the earliest we can build them, and only build them once
            this.renderer.sxss = this._build_discontinuous_object(sxs);
            this.renderer.syss = this._build_discontinuous_object(sys);
            results = [];
            for (k = 0, len = indices.length; k < len; k++) {
                i = indices[k];
                _b = [
                    sxs[i],
                    sys[i]
                ], sx = _b[0], sy = _b[1];
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    for (j = l = 0, ref = sx.length; 0 <= ref ? l < ref : l > ref; j = 0 <= ref ? ++l : --l) {
                        if (j === 0) {
                            ctx.beginPath();
                            ctx.moveTo(sx[j], sy[j]);
                            continue;
                        } else if (isNaN(sx[j] + sy[j])) {
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            continue;
                        } else {
                            ctx.lineTo(sx[j], sy[j]);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                if (this.visuals.line.doit) {
                    this.visuals.line.set_vectorize(ctx, i);
                    for (j = m = 0, ref1 = sx.length; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
                        if (j === 0) {
                            ctx.beginPath();
                            ctx.moveTo(sx[j], sy[j]);
                            continue;
                        } else if (isNaN(sx[j] + sy[j])) {
                            ctx.closePath();
                            ctx.stroke();
                            ctx.beginPath();
                            continue;
                        } else {
                            ctx.lineTo(sx[j], sy[j]);
                        }
                    }
                    ctx.closePath();
                    results.push(ctx.stroke());
                } else {
                    results.push(void 0);
                }
            }
            return results;
            var _b;
        };
        PatchesView.prototype._hit_point = function (geometry) {
            var candidates, hits, i, idx, j, k, l, ref, ref1, result, sx, sxs, sy, sys, x, y;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            y = this.renderer.yscale.invert(sy);
            candidates = this.index.indices({
                minX: x,
                minY: y,
                maxX: x,
                maxY: y
            });
            hits = [];
            for (i = k = 0, ref = candidates.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                idx = candidates[i];
                sxs = this.renderer.sxss[idx];
                sys = this.renderer.syss[idx];
                for (j = l = 0, ref1 = sxs.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
                    if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {
                        hits.push(idx);
                    }
                }
            }
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
        };
        PatchesView.prototype._get_snap_coord = function (array) {
            var k, len, s, sum;
            sum = 0;
            for (k = 0, len = array.length; k < len; k++) {
                s = array[k];
                sum += s;
            }
            return sum / array.length;
        };
        PatchesView.prototype.scx = function (i, sx, sy) {
            var j, k, ref, sxs, sys;
            if (this.renderer.sxss[i].length === 1) {
                // We don't have discontinuous objects so we're ok
                return this._get_snap_coord(this.sxs[i]);
            } else {
                // We have discontinuous objects, so we need to find which
                // one we're in, we can use point_in_poly again
                sxs = this.renderer.sxss[i];
                sys = this.renderer.syss[i];
                for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
                    if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {
                        return this._get_snap_coord(sxs[j]);
                    }
                }
            }
            return null;
        };
        PatchesView.prototype.scy = function (i, sx, sy) {
            var j, k, ref, sxs, sys;
            if (this.renderer.syss[i].length === 1) {
                // We don't have discontinuous objects so we're ok
                return this._get_snap_coord(this.sys[i]);
            } else {
                // We have discontinuous objects, so we need to find which
                // one we're in, we can use point_in_poly again
                sxs = this.renderer.sxss[i];
                sys = this.renderer.syss[i];
                for (j = k = 0, ref = sxs.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
                    if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {
                        return this._get_snap_coord(sys[j]);
                    }
                }
            }
        };
        PatchesView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
        };
        return PatchesView;
    }(glyph_1.GlyphView);
    var Patches = function (_super) {
        tslib_1.__extends(Patches, _super);
        function Patches() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Patches;
    }(glyph_1.Glyph);
    exports.Patches = Patches;
    ;
    Patches.prototype.default_view = exports.PatchesView;
    Patches.prototype.type = 'Patches';
    Patches.coords([[
            'xs',
            'ys'
        ]]);
    Patches.mixins([
        'line',
        'fill'
    ]);    
},
/*models/glyphs/quad*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var box_1 = require(105    /* ./box */);
    exports.QuadView = function (_super) {
        tslib_1.__extends(QuadView, _super);
        function QuadView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        QuadView.prototype.get_anchor_point = function (anchor, i, spt) {
            var bottom, left, right, top;
            left = Math.min(this.sleft[i], this.sright[i]);
            right = Math.max(this.sright[i], this.sleft[i]);
            top = Math.min(this.stop[i], this.sbottom[i]);
            bottom = Math.max(this.sbottom[i], this.stop[i]);
            switch (anchor) {
            case 'top_left':
                return {
                    x: left,
                    y: top
                };
            case 'top_center':
                return {
                    x: (left + right) / 2,
                    y: top
                };
            case 'top_right':
                return {
                    x: right,
                    y: top
                };
            case 'center_right':
                return {
                    x: right,
                    y: (top + bottom) / 2
                };
            case 'bottom_right':
                return {
                    x: right,
                    y: bottom
                };
            case 'bottom_center':
                return {
                    x: (left + right) / 2,
                    y: bottom
                };
            case 'bottom_left':
                return {
                    x: left,
                    y: bottom
                };
            case 'center_left':
                return {
                    x: left,
                    y: (top + bottom) / 2
                };
            case 'center':
                return {
                    x: (left + right) / 2,
                    y: (top + bottom) / 2
                };
            }
        };
        QuadView.prototype.scx = function (i) {
            return (this.sleft[i] + this.sright[i]) / 2;
        };
        QuadView.prototype.scy = function (i) {
            return (this.stop[i] + this.sbottom[i]) / 2;
        };
        QuadView.prototype._index_data = function () {
            return this._index_box(this._right.length);
        };
        QuadView.prototype._lrtb = function (i) {
            var b, l, r, t;
            l = this._left[i];
            r = this._right[i];
            t = this._top[i];
            b = this._bottom[i];
            return [
                l,
                r,
                t,
                b
            ];
        };
        return QuadView;
    }(box_1.BoxView);
    var Quad = function (_super) {
        tslib_1.__extends(Quad, _super);
        function Quad() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Quad;
    }(box_1.Box);
    exports.Quad = Quad;
    ;
    Quad.prototype.default_view = exports.QuadView;
    Quad.prototype.type = 'Quad';
    Quad.coords([
        [
            'right',
            'bottom'
        ],
        [
            'left',
            'top'
        ]
    ]);    
},
/*models/glyphs/quadratic*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var _qbb;
    var spatial_1 = require(36    /* core/util/spatial */);
    var glyph_1 = require(108    /* ./glyph */);
    // Formula from: http://pomax.nihongoresources.com/pages/bezier/
    // if segment is quadratic bezier do:
    //   for both directions do:
    //     if control between start and end, compute linear bounding box
    //     otherwise, compute
    //       bound = u(1-t)^2 + 2v(1-t)t + wt^2
    //         (with t = ((u-v) / (u-2v+w)), with {u = start, v = control, w = end})
    //       if control precedes start, min = bound, otherwise max = bound
    _qbb = function (u, v, w) {
        var bd, t;
        if (v === (u + w) / 2) {
            return [
                u,
                w
            ];
        } else {
            t = (u - v) / (u - 2 * v + w);
            bd = u * Math.pow(1 - t, 2) + 2 * v * (1 - t) * t + w * Math.pow(t, 2);
            return [
                Math.min(u, w, bd),
                Math.max(u, w, bd)
            ];
        }
    };
    exports.QuadraticView = function (_super) {
        tslib_1.__extends(QuadraticView, _super);
        function QuadraticView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        QuadraticView.prototype._index_data = function () {
            var i, j, points, ref, x0, x1, y0, y1;
            points = [];
            for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx[i] + this._cy[i])) {
                    continue;
                }
                _a = _qbb(this._x0[i], this._cx[i], this._x1[i]), x0 = _a[0], x1 = _a[1];
                _b = _qbb(this._y0[i], this._cy[i], this._y1[i]), y0 = _b[0], y1 = _b[1];
                points.push({
                    minX: x0,
                    minY: y0,
                    maxX: x1,
                    maxY: y1,
                    i: i
                });
            }
            return new spatial_1.RBush(points);
            var _a, _b;
        };
        QuadraticView.prototype._render = function (ctx, indices, _a) {
            var sx0 = _a.sx0, sy0 = _a.sy0, sx1 = _a.sx1, sy1 = _a.sy1, scx = _a.scx, scy = _a.scy;
            var i, j, len, results;
            if (this.visuals.line.doit) {
                results = [];
                for (j = 0, len = indices.length; j < len; j++) {
                    i = indices[j];
                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx[i] + scy[i])) {
                        continue;
                    }
                    ctx.beginPath();
                    ctx.moveTo(sx0[i], sy0[i]);
                    ctx.quadraticCurveTo(scx[i], scy[i], sx1[i], sy1[i]);
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                }
                return results;
            }
        };
        QuadraticView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return QuadraticView;
    }(glyph_1.GlyphView);
    var Quadratic = function (_super) {
        tslib_1.__extends(Quadratic, _super);
        function Quadratic() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Quadratic;
    }(glyph_1.Glyph);
    exports.Quadratic = Quadratic;
    ;
    Quadratic.prototype.default_view = exports.QuadraticView;
    Quadratic.prototype.type = 'Quadratic';
    Quadratic.coords([
        [
            'x0',
            'y0'
        ],
        [
            'x1',
            'y1'
        ],
        [
            'cx',
            'cy'
        ]
    ]);
    Quadratic.mixins(['line']);    
},
/*models/glyphs/ray*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var p = require(15    /* core/properties */);
    exports.RayView = function (_super) {
        tslib_1.__extends(RayView, _super);
        function RayView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RayView.prototype._map_data = function () {
            if (this.model.properties.length.units === 'data') {
                return this.slength = this.sdist(this.renderer.xscale, this._x, this._length);
            } else {
                return this.slength = this._length;
            }
        };
        RayView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, slength = _a.slength, _angle = _a._angle;
            var height, i, inf_len, j, k, len, ref, results, width;
            if (this.visuals.line.doit) {
                width = this.renderer.plot_view.frame._width.value;
                height = this.renderer.plot_view.frame._height.value;
                inf_len = 2 * (width + height);
                for (i = j = 0, ref = slength.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    if (slength[i] === 0) {
                        slength[i] = inf_len;
                    }
                }
                results = [];
                for (k = 0, len = indices.length; k < len; k++) {
                    i = indices[k];
                    if (isNaN(sx[i] + sy[i] + _angle[i] + slength[i])) {
                        continue;
                    }
                    ctx.translate(sx[i], sy[i]);
                    ctx.rotate(_angle[i]);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(slength[i], 0);
                    this.visuals.line.set_vectorize(ctx, i);
                    ctx.stroke();
                    ctx.rotate(-_angle[i]);
                    results.push(ctx.translate(-sx[i], -sy[i]));
                }
                return results;
            }
        };
        RayView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return RayView;
    }(xy_glyph_1.XYGlyphView);
    var Ray = function (_super) {
        tslib_1.__extends(Ray, _super);
        function Ray() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Ray;
    }(xy_glyph_1.XYGlyph);
    exports.Ray = Ray;
    ;
    Ray.prototype.default_view = exports.RayView;
    Ray.prototype.type = 'Ray';
    Ray.mixins(['line']);
    Ray.define({
        length: [p.DistanceSpec],
        angle: [p.AngleSpec]
    });    
},
/*models/glyphs/rect*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    exports.RectView = function (_super) {
        tslib_1.__extends(RectView, _super);
        function RectView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RectView.prototype._set_data = function () {
            this.max_w2 = 0;
            if (this.model.properties.width.units === 'data') {
                this.max_w2 = this.max_width / 2;
            }
            this.max_h2 = 0;
            if (this.model.properties.height.units === 'data') {
                return this.max_h2 = this.max_height / 2;
            }
        };
        RectView.prototype._map_data = function () {
            var i;
            if (this.model.properties.width.units === 'data') {
                _a = this._map_dist_corner_for_data_side_length(this._x, this._width, this.renderer.xscale, 0), this.sw = _a[0], this.sx0 = _a[1];
            } else {
                this.sw = this._width;
                this.sx0 = function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = this.sx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(this.sx[i] - this.sw[i] / 2);
                    }
                    return results;
                }.call(this);
            }
            if (this.model.properties.height.units === 'data') {
                _b = this._map_dist_corner_for_data_side_length(this._y, this._height, this.renderer.yscale, 1), this.sh = _b[0], this.sy1 = _b[1];
            } else {
                this.sh = this._height;
                this.sy1 = function () {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = this.sy.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                        results.push(this.sy[i] - this.sh[i] / 2);
                    }
                    return results;
                }.call(this);
            }
            return this.ssemi_diag = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = this.sw.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(Math.sqrt(this.sw[i] / 2 * this.sw[i] / 2 + this.sh[i] / 2 * this.sh[i] / 2));
                }
                return results;
            }.call(this);
            var _a, _b;
        };
        RectView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, sx0 = _a.sx0, sy1 = _a.sy1, sw = _a.sw, sh = _a.sh, _angle = _a._angle;
            var i, j, k, len, len1;
            if (this.visuals.fill.doit) {
                for (j = 0, len = indices.length; j < len; j++) {
                    i = indices[j];
                    if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {
                        continue;
                    }
                    //no need to test the return value, we call fillRect for every glyph anyway
                    this.visuals.fill.set_vectorize(ctx, i);
                    if (_angle[i]) {
                        ctx.translate(sx[i], sy[i]);
                        ctx.rotate(_angle[i]);
                        ctx.fillRect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);
                        ctx.rotate(-_angle[i]);
                        ctx.translate(-sx[i], -sy[i]);
                    } else {
                        ctx.fillRect(sx0[i], sy1[i], sw[i], sh[i]);
                    }
                }
            }
            if (this.visuals.line.doit) {
                ctx.beginPath();
                for (k = 0, len1 = indices.length; k < len1; k++) {
                    i = indices[k];
                    if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i])) {
                        continue;
                    }
                    // fillRect does not fill zero-height or -width rects, but rect(...)
                    // does seem to stroke them (1px wide or tall). Explicitly ignore rects
                    // with zero width or height to be consistent
                    if (sw[i] === 0 || sh[i] === 0) {
                        continue;
                    }
                    if (_angle[i]) {
                        ctx.translate(sx[i], sy[i]);
                        ctx.rotate(_angle[i]);
                        ctx.rect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);
                        ctx.rotate(-_angle[i]);
                        ctx.translate(-sx[i], -sy[i]);
                    } else {
                        ctx.rect(sx0[i], sy1[i], sw[i], sh[i]);
                    }
                    this.visuals.line.set_vectorize(ctx, i);
                    ctx.stroke();
                    ctx.beginPath();
                }
                return ctx.stroke();
            }
        };
        RectView.prototype._hit_rect = function (geometry) {
            return this._hit_rect_against_index(geometry);
        };
        RectView.prototype._hit_point = function (geometry) {
            var bbox, c, d, height_in, hits, i, j, len, max_x2_ddist, max_y2_ddist, px, py, ref, result, s, scenter_x, scenter_y, sx, sy, width_in, x, x0, x1, y, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            y = this.renderer.yscale.invert(sy);
            scenter_x = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = this.sx0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(this.sx0[i] + this.sw[i] / 2);
                }
                return results;
            }.call(this);
            scenter_y = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = this.sy1.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(this.sy1[i] + this.sh[i] / 2);
                }
                return results;
            }.call(this);
            max_x2_ddist = array_1.max(this._ddist(0, scenter_x, this.ssemi_diag));
            max_y2_ddist = array_1.max(this._ddist(1, scenter_y, this.ssemi_diag));
            x0 = x - max_x2_ddist;
            x1 = x + max_x2_ddist;
            y0 = y - max_y2_ddist;
            y1 = y + max_y2_ddist;
            hits = [];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            ref = this.index.indices(bbox);
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                if (this._angle[i]) {
                    d = Math.sqrt(Math.pow(sx - this.sx[i], 2) + Math.pow(sy - this.sy[i], 2));
                    s = Math.sin(-this._angle[i]);
                    c = Math.cos(-this._angle[i]);
                    px = c * (sx - this.sx[i]) - s * (sy - this.sy[i]) + this.sx[i];
                    py = s * (sx - this.sx[i]) + c * (sy - this.sy[i]) + this.sy[i];
                    sx = px;
                    sy = py;
                    width_in = Math.abs(this.sx[i] - sx) <= this.sw[i] / 2;
                    height_in = Math.abs(this.sy[i] - sy) <= this.sh[i] / 2;
                } else {
                    width_in = sx - this.sx0[i] <= this.sw[i] && sx - this.sx0[i] >= 0;
                    height_in = sy - this.sy1[i] <= this.sh[i] && sy - this.sy1[i] >= 0;
                }
                if (height_in && width_in) {
                    hits.push(i);
                }
            }
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
        };
        RectView.prototype._map_dist_corner_for_data_side_length = function (coord, side_length, scale, dim) {
            var frame, i, j, k, pt0, pt1, ref, ref1, spt0, spt1, spt_corner, sside_length, x;
            frame = this.renderer.plot_view.frame;
            if (scale.source_range.synthetic != null) {
                coord = function () {
                    var j, len, results;
                    results = [];
                    for (j = 0, len = coord.length; j < len; j++) {
                        x = coord[j];
                        results.push(scale.source_range.synthetic(x));
                    }
                    return results;
                }();
            }
            pt0 = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(Number(coord[i]) - side_length[i] / 2);
                }
                return results;
            }();
            pt1 = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = coord.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(Number(coord[i]) + side_length[i] / 2);
                }
                return results;
            }();
            spt0 = scale.v_compute(pt0);
            spt1 = scale.v_compute(pt1);
            sside_length = this.sdist(scale, pt0, side_length, 'edge', this.model.dilate);
            if (dim === 0) {
                spt_corner = spt0;
                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    if (spt0[i] !== spt1[i]) {
                        spt_corner = spt0[i] < spt1[i] ? spt0 : spt1;
                        break;
                    }
                }
                return [
                    sside_length,
                    spt_corner
                ];
            } else if (dim === 1) {
                spt_corner = spt0;
                for (i = k = 0, ref1 = spt0.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                    if (spt0[i] !== spt1[i]) {
                        spt_corner = spt0[i] < spt1[i] ? spt0 : spt1;
                        break;
                    }
                }
                return [
                    sside_length,
                    spt_corner
                ];
            }
        };
        RectView.prototype._ddist = function (dim, spts, spans) {
            var i, pt0, pt1, scale, spt0, spt1;
            if (dim === 0) {
                scale = this.renderer.xscale;
            } else {
                scale = this.renderer.yscale;
            }
            spt0 = spts;
            spt1 = function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = spt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(spt0[i] + spans[i]);
                }
                return results;
            }();
            pt0 = scale.v_invert(spt0);
            pt1 = scale.v_invert(spt1);
            return function () {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = pt0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(Math.abs(pt1[i] - pt0[i]));
                }
                return results;
            }();
        };
        RectView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
        };
        RectView.prototype._bounds = function (bds) {
            return this.max_wh2_bounds(bds);
        };
        return RectView;
    }(xy_glyph_1.XYGlyphView);
    var Rect = function (_super) {
        tslib_1.__extends(Rect, _super);
        function Rect() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Rect;
    }(xy_glyph_1.XYGlyph);
    exports.Rect = Rect;
    ;
    Rect.prototype.default_view = exports.RectView;
    Rect.prototype.type = 'Rect';
    Rect.mixins([
        'line',
        'fill'
    ]);
    Rect.define({
        angle: [
            p.AngleSpec,
            0
        ],
        width: [p.DistanceSpec],
        height: [p.DistanceSpec],
        dilate: [
            p.Bool,
            false
        ]
    });    
},
/*models/glyphs/segment*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var hittest = require(9    /* core/hittest */);
    var spatial_1 = require(36    /* core/util/spatial */);
    var glyph_1 = require(108    /* ./glyph */);
    exports.SegmentView = function (_super) {
        tslib_1.__extends(SegmentView, _super);
        function SegmentView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SegmentView.prototype._index_data = function () {
            var i, j, points, ref;
            points = [];
            for (i = j = 0, ref = this._x0.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (!isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i])) {
                    points.push({
                        minX: Math.min(this._x0[i], this._x1[i]),
                        minY: Math.min(this._y0[i], this._y1[i]),
                        maxX: Math.max(this._x0[i], this._x1[i]),
                        maxY: Math.max(this._y0[i], this._y1[i]),
                        i: i
                    });
                }
            }
            return new spatial_1.RBush(points);
        };
        SegmentView.prototype._render = function (ctx, indices, _a) {
            var sx0 = _a.sx0, sy0 = _a.sy0, sx1 = _a.sx1, sy1 = _a.sy1;
            var i, j, len, results;
            if (this.visuals.line.doit) {
                results = [];
                for (j = 0, len = indices.length; j < len; j++) {
                    i = indices[j];
                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i])) {
                        continue;
                    }
                    ctx.beginPath();
                    ctx.moveTo(sx0[i], sy0[i]);
                    ctx.lineTo(sx1[i], sy1[i]);
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                }
                return results;
            }
        };
        SegmentView.prototype._hit_point = function (geometry) {
            var candidates, dist2, hits, i, j, len, lw_voffset, maxX, maxY, minX, minY, p0, p1, point, result, sx, sy, threshold2, x, y;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            y = this.renderer.yscale.invert(sy);
            point = {
                x: sx,
                y: sy
            };
            hits = [];
            lw_voffset = 2;
            // FIXME: Use maximum of segments line_width/2 instead of magic constant 2
            _a = this.renderer.xscale.r_invert(sx - lw_voffset, sx + lw_voffset), minX = _a[0], maxX = _a[1];
            _b = this.renderer.yscale.r_invert(sy - lw_voffset, sy + lw_voffset), minY = _b[0], maxY = _b[1];
            candidates = this.index.indices({
                minX: minX,
                minY: minY,
                maxX: maxX,
                maxY: maxY
            });
            for (j = 0, len = candidates.length; j < len; j++) {
                i = candidates[j];
                threshold2 = Math.pow(Math.max(2, this.visuals.line.cache_select('line_width', i) / 2), 2);
                _c = [
                    {
                        x: this.sx0[i],
                        y: this.sy0[i]
                    },
                    {
                        x: this.sx1[i],
                        y: this.sy1[i]
                    }
                ], p0 = _c[0], p1 = _c[1];
                dist2 = hittest.dist_to_segment_squared(point, p0, p1);
                if (dist2 < threshold2) {
                    hits.push(i);
                }
            }
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
            var _a, _b, _c;
        };
        SegmentView.prototype._hit_span = function (geometry) {
            var candidates, hits, hr, i, j, len, maxX, maxY, minX, minY, result, sx, sy, v0, v1, val, vr;
            _a = this.renderer.plot_view.frame.bbox.ranges, hr = _a[0], vr = _a[1];
            sx = geometry.sx, sy = geometry.sy;
            if (geometry.direction === 'v') {
                val = this.renderer.yscale.invert(sy);
                _b = [
                    this._y0,
                    this._y1
                ], v0 = _b[0], v1 = _b[1];
            } else {
                val = this.renderer.xscale.invert(sx);
                _c = [
                    this._x0,
                    this._x1
                ], v0 = _c[0], v1 = _c[1];
            }
            hits = [];
            _d = this.renderer.xscale.r_invert(hr.start, hr.end), minX = _d[0], maxX = _d[1];
            _e = this.renderer.yscale.r_invert(vr.start, vr.end), minY = _e[0], maxY = _e[1];
            candidates = this.index.indices({
                minX: minX,
                minY: minY,
                maxX: maxX,
                maxY: maxY
            });
            for (j = 0, len = candidates.length; j < len; j++) {
                i = candidates[j];
                if (v0[i] <= val && val <= v1[i] || v1[i] <= val && val <= v0[i]) {
                    hits.push(i);
                }
            }
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
            var _a, _b, _c, _d, _e;
        };
        SegmentView.prototype.scx = function (i) {
            return (this.sx0[i] + this.sx1[i]) / 2;
        };
        SegmentView.prototype.scy = function (i) {
            return (this.sy0[i] + this.sy1[i]) / 2;
        };
        SegmentView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return SegmentView;
    }(glyph_1.GlyphView);
    var Segment = function (_super) {
        tslib_1.__extends(Segment, _super);
        function Segment() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Segment;
    }(glyph_1.Glyph);
    exports.Segment = Segment;
    ;
    Segment.prototype.default_view = exports.SegmentView;
    Segment.prototype.type = 'Segment';
    Segment.coords([
        [
            'x0',
            'y0'
        ],
        [
            'x1',
            'y1'
        ]
    ]);
    Segment.mixins(['line']);    
},
/*models/glyphs/step*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var p = require(15    /* core/properties */);
    exports.StepView = function (_super) {
        tslib_1.__extends(StepView, _super);
        function StepView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StepView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy;
            var L, i, j, ref, x1, x2, xm, y1, y2;
            this.visuals.line.set_value(ctx);
            L = indices.length;
            if (L < 2) {
                return;
            }
            ctx.beginPath();
            ctx.moveTo(sx[0], sy[0]);
            for (i = j = 1, ref = L; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                switch (this.model.mode) {
                case 'before':
                    _b = [
                        sx[i - 1],
                        sy[i]
                    ], x1 = _b[0], y1 = _b[1];
                    _c = [
                        sx[i],
                        sy[i]
                    ], x2 = _c[0], y2 = _c[1];
                    break;
                case 'after':
                    _d = [
                        sx[i],
                        sy[i - 1]
                    ], x1 = _d[0], y1 = _d[1];
                    _e = [
                        sx[i],
                        sy[i]
                    ], x2 = _e[0], y2 = _e[1];
                    break;
                case 'center':
                    xm = (sx[i - 1] + sx[i]) / 2;
                    _f = [
                        xm,
                        sy[i - 1]
                    ], x1 = _f[0], y1 = _f[1];
                    _g = [
                        xm,
                        sy[i]
                    ], x2 = _g[0], y2 = _g[1];
                }
                ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.lineTo(sx[L - 1], sy[L - 1]);
            return ctx.stroke();
            var _b, _c, _d, _e, _f, _g;
        };
        StepView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_line_legend(ctx, x0, x1, y0, y1, index);
        };
        return StepView;
    }(xy_glyph_1.XYGlyphView);
    var Step = function (_super) {
        tslib_1.__extends(Step, _super);
        function Step() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Step;
    }(xy_glyph_1.XYGlyph);
    exports.Step = Step;
    ;
    Step.prototype.default_view = exports.StepView;
    Step.prototype.type = 'Step';
    Step.mixins(['line']);
    Step.define({
        mode: [
            p.StepMode,
            'before'
        ]
    });    
},
/*models/glyphs/text*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var p = require(15    /* core/properties */);
    var text_1 = require(40    /* core/util/text */);
    exports.TextView = function (_super) {
        tslib_1.__extends(TextView, _super);
        function TextView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, _x_offset = _a._x_offset, _y_offset = _a._y_offset, _angle = _a._angle, _text = _a._text;
            var baseline, block_height, font, height, i, j, k, len, len1, line, line_height, lines, results, text, y;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || _text[i] == null) {
                    continue;
                }
                if (this.visuals.text.doit) {
                    text = '' + _text[i];
                    ctx.save();
                    ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);
                    ctx.rotate(_angle[i]);
                    this.visuals.text.set_vectorize(ctx, i);
                    if (text.indexOf('\n') === -1) {
                        ctx.fillText(text, 0, 0);
                    } else {
                        lines = text.split('\n');
                        font = this.visuals.text.cache_select('font', i);
                        height = text_1.get_text_height(font).height;
                        line_height = this.visuals.text.text_line_height.value() * height;
                        block_height = line_height * lines.length;
                        baseline = this.visuals.text.cache_select('text_baseline', i);
                        switch (baseline) {
                        case 'top':
                            y = 0;
                            break;
                        case 'middle':
                            y = -block_height / 2 + line_height / 2;
                            break;
                        case 'bottom':
                            y = -block_height + line_height;
                            break;
                        default:
                            y = 0;
                            console.warn('\'' + baseline + '\' baseline not supported with multi line text');
                        }
                        for (k = 0, len1 = lines.length; k < len1; k++) {
                            line = lines[k];
                            ctx.fillText(line, 0, y);
                            y += line_height;
                        }
                    }
                    results.push(ctx.restore());
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        TextView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            ctx.save();
            this.text_props.set_value(ctx);
            // override some features so we fit inside the legend
            ctx.font = this.text_props.font_value();
            ctx.font = ctx.font.replace(/\b[\d\.]+[\w]+\b/, '10pt');
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText('text', x2, (y1 + y2) / 2);
            return ctx.restore();
        };
        return TextView;
    }(xy_glyph_1.XYGlyphView);
    var Text = function (_super) {
        tslib_1.__extends(Text, _super);
        function Text() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Text;
    }(xy_glyph_1.XYGlyph);
    exports.Text = Text;
    ;
    Text.prototype.default_view = exports.TextView;
    Text.prototype.type = 'Text';
    Text.mixins(['text']);
    Text.define({
        text: [
            p.StringSpec,
            { field: 'text' }
        ],
        angle: [
            p.AngleSpec,
            0
        ],
        x_offset: [
            p.NumberSpec,
            0
        ],
        y_offset: [
            p.NumberSpec,
            0
        ]
    });    
},
/*models/glyphs/vbar*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var box_1 = require(105    /* ./box */);
    var p = require(15    /* core/properties */);
    exports.VBarView = function (_super) {
        tslib_1.__extends(VBarView, _super);
        function VBarView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        VBarView.prototype.scy = function (i) {
            return (this.stop[i] + this.sbottom[i]) / 2;
        };
        VBarView.prototype._index_data = function () {
            return this._index_box(this._x.length);
        };
        VBarView.prototype._lrtb = function (i) {
            var b, l, r, t;
            l = this._x[i] - this._width[i] / 2;
            r = this._x[i] + this._width[i] / 2;
            t = Math.max(this._top[i], this._bottom[i]);
            b = Math.min(this._top[i], this._bottom[i]);
            return [
                l,
                r,
                t,
                b
            ];
        };
        VBarView.prototype._map_data = function () {
            var i, j, ref;
            this.sx = this.renderer.xscale.v_compute(this._x);
            this.stop = this.renderer.yscale.v_compute(this._top);
            this.sbottom = this.renderer.yscale.v_compute(this._bottom);
            this.sleft = [];
            this.sright = [];
            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');
            for (i = j = 0, ref = this.sx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                this.sleft.push(this.sx[i] - this.sw[i] / 2);
                this.sright.push(this.sx[i] + this.sw[i] / 2);
            }
            return null;
        };
        return VBarView;
    }(box_1.BoxView);
    var VBar = function (_super) {
        tslib_1.__extends(VBar, _super);
        function VBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return VBar;
    }(box_1.Box);
    exports.VBar = VBar;
    ;
    VBar.prototype.default_view = exports.VBarView;
    VBar.prototype.type = 'VBar';
    VBar.coords([[
            'x',
            'bottom'
        ]]);
    VBar.define({
        width: [p.DistanceSpec],
        top: [p.NumberSpec]
    });
    VBar.override({ bottom: 0 });    
},
/*models/glyphs/wedge*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ./xy_glyph */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    var math_1 = require(29    /* core/util/math */);
    exports.WedgeView = function (_super) {
        tslib_1.__extends(WedgeView, _super);
        function WedgeView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WedgeView.prototype._map_data = function () {
            if (this.model.properties.radius.units === 'data') {
                return this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);
            } else {
                return this.sradius = this._radius;
            }
        };
        WedgeView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, sradius = _a.sradius, _start_angle = _a._start_angle, _end_angle = _a._end_angle;
            var direction, i, j, len, results;
            direction = this.model.properties.direction.value();
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i])) {
                    continue;
                }
                ctx.beginPath();
                ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);
                ctx.lineTo(sx[i], sy[i]);
                ctx.closePath();
                if (this.visuals.fill.doit) {
                    this.visuals.fill.set_vectorize(ctx, i);
                    ctx.fill();
                }
                if (this.visuals.line.doit) {
                    this.visuals.line.set_vectorize(ctx, i);
                    results.push(ctx.stroke());
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        WedgeView.prototype._hit_point = function (geometry) {
            var angle, bbox, candidates, direction, dist, hits, i, j, k, len, len1, r2, ref, sx, sx0, sx1, sy, sy0, sy1, x, x0, x1, y, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            x = this.renderer.xscale.invert(sx);
            y = this.renderer.yscale.invert(sy);
            // check radius first
            if (this.model.properties.radius.units === 'data') {
                x0 = x - this.max_radius;
                x1 = x + this.max_radius;
                y0 = y - this.max_radius;
                y1 = y + this.max_radius;
            } else {
                sx0 = sx - this.max_radius;
                sx1 = sx + this.max_radius;
                _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
                sy0 = sy - this.max_radius;
                sy1 = sy + this.max_radius;
                _b = this.renderer.yscale.r_invert(sy0, sy1), y0 = _b[0], y1 = _b[1];
            }
            candidates = [];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            ref = this.index.indices(bbox);
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                r2 = Math.pow(this.sradius[i], 2);
                _c = this.renderer.xscale.r_compute(x, this._x[i]), sx0 = _c[0], sx1 = _c[1];
                _d = this.renderer.yscale.r_compute(y, this._y[i]), sy0 = _d[0], sy1 = _d[1];
                dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                if (dist <= r2) {
                    candidates.push([
                        i,
                        dist
                    ]);
                }
            }
            direction = this.model.properties.direction.value();
            hits = [];
            for (k = 0, len1 = candidates.length; k < len1; k++) {
                _e = candidates[k], i = _e[0], dist = _e[1];
                // NOTE: minus the angle because JS uses non-mathy convention for angles
                angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);
                if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {
                    hits.push([
                        i,
                        dist
                    ]);
                }
            }
            return hittest.create_1d_hit_test_result(hits);
            var _a, _b, _c, _d, _e;
        };
        WedgeView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            return this._generic_area_legend(ctx, x0, x1, y0, y1, index);
        };
        return WedgeView;
    }(xy_glyph_1.XYGlyphView);
    var Wedge = function (_super) {
        tslib_1.__extends(Wedge, _super);
        function Wedge() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Wedge;
    }(xy_glyph_1.XYGlyph);
    exports.Wedge = Wedge;
    ;
    Wedge.prototype.default_view = exports.WedgeView;
    Wedge.prototype.type = 'Wedge';
    Wedge.mixins([
        'line',
        'fill'
    ]);
    Wedge.define({
        direction: [
            p.Direction,
            'anticlock'
        ],
        radius: [p.DistanceSpec],
        start_angle: [p.AngleSpec],
        end_angle: [p.AngleSpec]
    });    
},
/*models/glyphs/xy_glyph*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var spatial_1 = require(36    /* core/util/spatial */);
    var glyph_1 = require(108    /* ./glyph */);
    exports.XYGlyphView = function (_super) {
        tslib_1.__extends(XYGlyphView, _super);
        function XYGlyphView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        XYGlyphView.prototype._index_data = function () {
            var i, j, points, ref, x, y;
            points = [];
            for (i = j = 0, ref = this._x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                x = this._x[i];
                y = this._y[i];
                if (isNaN(x + y) || !isFinite(x + y)) {
                    continue;
                }
                points.push({
                    minX: x,
                    minY: y,
                    maxX: x,
                    maxY: y,
                    i: i
                });
            }
            return new spatial_1.RBush(points);
        };
        return XYGlyphView;
    }(glyph_1.GlyphView);
    var XYGlyph = function (_super) {
        tslib_1.__extends(XYGlyph, _super);
        function XYGlyph() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return XYGlyph;
    }(glyph_1.Glyph);
    exports.XYGlyph = XYGlyph;
    ;
    XYGlyph.prototype.type = 'XYGlyph';
    XYGlyph.prototype.default_view = exports.XYGlyphView;
    XYGlyph.coords([[
            'x',
            'y'
        ]]);    
},
/*models/graphs/graph_hit_test_policy*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var array_1 = require(22    /* core/util/array */);
    var hittest_1 = require(9    /* core/hittest */);
    exports.GraphHitTestPolicy = function (_super) {
        tslib_1.__extends(GraphHitTestPolicy, _super);
        function GraphHitTestPolicy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GraphHitTestPolicy.prototype.do_selection = function (geometry, graph_view, final, append) {
            return false;
        };
        GraphHitTestPolicy.prototype.do_inspection = function (geometry, graph_view, final, append) {
            return false;
        };
        return GraphHitTestPolicy;
    }(model_1.Model);
    var NodesOnly = function (_super) {
        tslib_1.__extends(NodesOnly, _super);
        function NodesOnly() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NodesOnly.prototype._do = function (geometry, graph_view, final, append) {
            var hit_test_result, node_view;
            node_view = graph_view.node_view;
            hit_test_result = node_view.glyph.hit_test(geometry);
            // glyphs that don't have hit-testing implemented will return null
            if (hit_test_result === null) {
                return false;
            }
            this._node_selector.update(hit_test_result, final, append);
            return !this._node_selector.indices.is_empty();
        };
        NodesOnly.prototype.do_selection = function (geometry, graph_view, final, append) {
            var did_hit;
            this._node_selector = graph_view.node_view.model.data_source.selection_manager.selector;
            did_hit = this._do(geometry, graph_view, final, append);
            graph_view.node_view.model.data_source.selected = this._node_selector.indices;
            graph_view.node_view.model.data_source.select.emit();
            return did_hit;
        };
        NodesOnly.prototype.do_inspection = function (geometry, graph_view, final, append) {
            var did_hit;
            this._node_selector = graph_view.model.get_selection_manager().get_or_create_inspector(graph_view.node_view.model);
            did_hit = this._do(geometry, graph_view, final, append);
            // silently set inspected attr to avoid triggering data_source.change event and rerender
            graph_view.node_view.model.data_source.setv({ inspected: this._node_selector.indices }, { silent: true });
            graph_view.node_view.model.data_source.inspect.emit([
                graph_view.node_view,
                { geometry: geometry }
            ]);
            return did_hit;
        };
        return NodesOnly;
    }(exports.GraphHitTestPolicy);
    exports.NodesOnly = NodesOnly;
    ;
    NodesOnly.prototype.type = 'NodesOnly';
    var NodesAndLinkedEdges = function (_super) {
        tslib_1.__extends(NodesAndLinkedEdges, _super);
        function NodesAndLinkedEdges() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NodesAndLinkedEdges.prototype._do = function (geometry, graph_view, final, append) {
            var edge_indices, edge_source, edge_view, hit_test_result, i, j, k, len, linked_index, node_indices, node_view, ref;
            _a = [
                graph_view.node_view,
                graph_view.edge_view
            ], node_view = _a[0], edge_view = _a[1];
            hit_test_result = node_view.glyph.hit_test(geometry);
            // glyphs that don't have hit-testing implemented will return null
            if (hit_test_result === null) {
                return false;
            }
            this._node_selector.update(hit_test_result, final, append);
            node_indices = function () {
                var j, len, ref, results;
                ref = hit_test_result['1d'].indices;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    i = ref[j];
                    results.push(node_view.model.data_source.data.index[i]);
                }
                return results;
            }();
            edge_source = edge_view.model.data_source;
            edge_indices = [];
            for (i = j = 0, ref = edge_source.data.start.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                if (array_1.contains(node_indices, edge_source.data.start[i]) || array_1.contains(node_indices, edge_source.data.end[i])) {
                    edge_indices.push(i);
                }
            }
            linked_index = hittest_1.create_hit_test_result();
            for (k = 0, len = edge_indices.length; k < len; k++) {
                i = edge_indices[k];
                linked_index['2d'].indices[i] = [0];    //currently only supports 2-element multilines, so this is all of it
            }
            this._edge_selector.update(linked_index, final, append);
            return !this._node_selector.indices.is_empty();
            var _a;
        };
        NodesAndLinkedEdges.prototype.do_selection = function (geometry, graph_view, final, append) {
            var did_hit;
            this._node_selector = graph_view.node_view.model.data_source.selection_manager.selector;
            this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.selector;
            did_hit = this._do(geometry, graph_view, final, append);
            graph_view.node_view.model.data_source.selected = this._node_selector.indices;
            graph_view.edge_view.model.data_source.selected = this._edge_selector.indices;
            graph_view.node_view.model.data_source.select.emit();
            return did_hit;
        };
        NodesAndLinkedEdges.prototype.do_inspection = function (geometry, graph_view, final, append) {
            var did_hit;
            this._node_selector = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);
            this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);
            did_hit = this._do(geometry, graph_view, final, append);
            // silently set inspected attr to avoid triggering data_source.change event and rerender
            graph_view.node_view.model.data_source.setv({ inspected: this._node_selector.indices }, { silent: true });
            graph_view.edge_view.model.data_source.setv({ inspected: this._edge_selector.indices }, { silent: true });
            graph_view.node_view.model.data_source.inspect.emit([
                graph_view.node_view,
                { geometry: geometry }
            ]);
            return did_hit;
        };
        return NodesAndLinkedEdges;
    }(exports.GraphHitTestPolicy);
    exports.NodesAndLinkedEdges = NodesAndLinkedEdges;
    ;
    NodesAndLinkedEdges.prototype.type = 'NodesAndLinkedEdges';
    var EdgesAndLinkedNodes = function (_super) {
        tslib_1.__extends(EdgesAndLinkedNodes, _super);
        function EdgesAndLinkedNodes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EdgesAndLinkedNodes.prototype._do = function (geometry, graph_view, final, append) {
            var edge_indices, edge_view, hit_test_result, i, j, len, node_hit_test_result, node_indices, node_view, nodes;
            _a = [
                graph_view.node_view,
                graph_view.edge_view
            ], node_view = _a[0], edge_view = _a[1];
            hit_test_result = edge_view.glyph.hit_test(geometry);
            // glyphs that don't have hit-testing implemented will return null
            if (hit_test_result === null) {
                return false;
            }
            this._edge_selector.update(hit_test_result, final, append);
            edge_indices = function () {
                var j, len, ref, results;
                ref = Object.keys(hit_test_result['2d'].indices);
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    i = ref[j];
                    results.push(parseInt(i));
                }
                return results;
            }();
            nodes = [];
            for (j = 0, len = edge_indices.length; j < len; j++) {
                i = edge_indices[j];
                nodes.push(edge_view.model.data_source.data.start[i]);
                nodes.push(edge_view.model.data_source.data.end[i]);
            }
            node_indices = function () {
                var k, len1, ref, results;
                ref = array_1.uniq(nodes);
                results = [];
                for (k = 0, len1 = ref.length; k < len1; k++) {
                    i = ref[k];
                    results.push(node_view.model.data_source.data.index.indexOf(i));
                }
                return results;
            }();
            node_hit_test_result = hittest_1.create_hit_test_result();
            node_hit_test_result['1d'].indices = node_indices;
            this._node_selector.update(node_hit_test_result, final, append);
            return !this._edge_selector.indices.is_empty();
            var _a;
        };
        EdgesAndLinkedNodes.prototype.do_selection = function (geometry, graph_view, final, append) {
            var did_hit;
            this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.selector;
            this._node_selector = graph_view.node_view.model.data_source.selection_manager.selector;
            did_hit = this._do(geometry, graph_view, final, append);
            graph_view.edge_view.model.data_source.selected = this._edge_selector.indices;
            graph_view.node_view.model.data_source.selected = this._node_selector.indices;
            graph_view.edge_view.model.data_source.select.emit();
            return did_hit;
        };
        EdgesAndLinkedNodes.prototype.do_inspection = function (geometry, graph_view, final, append) {
            var did_hit;
            this._edge_selector = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);
            this._node_selector = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);
            did_hit = this._do(geometry, graph_view, final, append);
            // silently set inspected attr to avoid triggering data_source.change event and rerender
            graph_view.edge_view.model.data_source.setv({ inspected: this._edge_selector.indices }, { silent: true });
            graph_view.node_view.model.data_source.setv({ inspected: this._node_selector.indices }, { silent: true });
            graph_view.edge_view.model.data_source.inspect.emit([
                graph_view.edge_view,
                { geometry: geometry }
            ]);
            return did_hit;
        };
        return EdgesAndLinkedNodes;
    }(exports.GraphHitTestPolicy);
    exports.EdgesAndLinkedNodes = EdgesAndLinkedNodes;
    ;
    EdgesAndLinkedNodes.prototype.type = 'EdgesAndLinkedNodes';    
},
/*models/graphs/index*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    tslib_1.__exportStar(require(129    /* ./graph_hit_test_policy */), exports);
    tslib_1.__exportStar(require(131    /* ./layout_provider */), exports);
    tslib_1.__exportStar(require(132    /* ./static_layout_provider */), exports);    
},
/*models/graphs/layout_provider*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    exports.LayoutProvider = function (_super) {
        tslib_1.__extends(LayoutProvider, _super);
        function LayoutProvider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LayoutProvider.prototype.get_node_coordinates = function (graph_source) {
            return [
                [],
                []
            ];
        };
        // this is implemented by base classes
        LayoutProvider.prototype.get_edge_coordinates = function (graph_source) {
            return [
                [],
                []
            ];
        };
        return LayoutProvider;
    }(model_1.Model);    // this is implemented by base classes
                         
},
/*models/graphs/static_layout_provider*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var layout_provider_1 = require(131    /* ./layout_provider */);
    var p = require(15    /* ../../core/properties */);
    var StaticLayoutProvider = function (_super) {
        tslib_1.__extends(StaticLayoutProvider, _super);
        function StaticLayoutProvider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StaticLayoutProvider.prototype.get_node_coordinates = function (node_source) {
            var i, j, len, ref, x, xs, y, ys;
            _a = [
                [],
                []
            ], xs = _a[0], ys = _a[1];
            ref = node_source.data.index;
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                x = this.graph_layout[i] != null ? this.graph_layout[i][0] : 0 / 0;
                y = this.graph_layout[i] != null ? this.graph_layout[i][1] : 0 / 0;
                xs.push(x);
                ys.push(y);
            }
            return [
                xs,
                ys
            ];
            var _a;
        };
        StaticLayoutProvider.prototype.get_edge_coordinates = function (edge_source) {
            var end, ends, has_paths, i, in_layout, j, ref, start, starts, xs, ys;
            _a = [
                [],
                []
            ], xs = _a[0], ys = _a[1];
            starts = edge_source.data.start;
            ends = edge_source.data.end;
            has_paths = edge_source.data.xs != null && edge_source.data.ys != null;
            for (i = j = 0, ref = starts.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                in_layout = this.graph_layout[starts[i]] != null && this.graph_layout[ends[i]] != null;
                if (has_paths && in_layout) {
                    xs.push(edge_source.data.xs[i]);
                    ys.push(edge_source.data.ys[i]);
                } else {
                    if (in_layout) {
                        _b = [
                            this.graph_layout[starts[i]],
                            this.graph_layout[ends[i]]
                        ], start = _b[0], end = _b[1];
                    } else {
                        _c = [
                            [
                                0 / 0,
                                0 / 0
                            ],
                            [
                                0 / 0,
                                0 / 0
                            ]
                        ], start = _c[0], end = _c[1];
                    }
                    xs.push([
                        start[0],
                        end[0]
                    ]);
                    ys.push([
                        start[1],
                        end[1]
                    ]);
                }
            }
            return [
                xs,
                ys
            ];
            var _a, _b, _c;
        };
        return StaticLayoutProvider;
    }(layout_provider_1.LayoutProvider);
    exports.StaticLayoutProvider = StaticLayoutProvider;
    ;
    StaticLayoutProvider.prototype.type = 'StaticLayoutProvider';
    StaticLayoutProvider.define({
        graph_layout: [
            p.Any,
            {}
        ]
    });    
},
/*models/grids/grid*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var guide_renderer_1 = require(163    /* ../renderers/guide_renderer */);
    var renderer_1 = require(165    /* ../renderers/renderer */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    exports.GridView = function (_super) {
        tslib_1.__extends(GridView, _super);
        function GridView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GridView.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._x_range_name = this.model.x_range_name;
            return this._y_range_name = this.model.y_range_name;
        };
        GridView.prototype.render = function () {
            var ctx;
            if (this.model.visible === false) {
                return;
            }
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            this._draw_regions(ctx);
            this._draw_minor_grids(ctx);
            this._draw_grids(ctx);
            return ctx.restore();
        };
        GridView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.change, function () {
                return this.request_render();
            });
        };
        GridView.prototype._draw_regions = function (ctx) {
            var i, k, ref, sx0, sx1, sy0, sy1, xs, ys;
            if (!this.visuals.band_fill.doit) {
                return;
            }
            _a = this.model.grid_coords('major', false), xs = _a[0], ys = _a[1];
            this.visuals.band_fill.set_value(ctx);
            for (i = k = 0, ref = xs.length - 1; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                if (i % 2 === 1) {
                    _b = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx0 = _b[0], sy0 = _b[1];
                    _c = this.plot_view.map_to_screen(xs[i + 1], ys[i + 1], this._x_range_name, this._y_range_name), sx1 = _c[0], sy1 = _c[1];
                    ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);
                    ctx.fill();
                }
            }
            var _a, _b, _c;
        };
        GridView.prototype._draw_grids = function (ctx) {
            var xs, ys;
            if (!this.visuals.grid_line.doit) {
                return;
            }
            _a = this.model.grid_coords('major'), xs = _a[0], ys = _a[1];
            return this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);
            var _a;
        };
        GridView.prototype._draw_minor_grids = function (ctx) {
            var xs, ys;
            if (!this.visuals.minor_grid_line.doit) {
                return;
            }
            _a = this.model.grid_coords('minor'), xs = _a[0], ys = _a[1];
            return this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);
            var _a;
        };
        GridView.prototype._draw_grid_helper = function (ctx, props, xs, ys) {
            var i, k, l, ref, ref1, sx, sy;
            props.set_value(ctx);
            for (i = k = 0, ref = xs.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                _a = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name), sx = _a[0], sy = _a[1];
                ctx.beginPath();
                ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));
                for (i = l = 1, ref1 = sx.length; 1 <= ref1 ? l < ref1 : l > ref1; i = 1 <= ref1 ? ++l : --l) {
                    ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));
                }
                ctx.stroke();
            }
            var _a;
        };
        return GridView;
    }(renderer_1.RendererView);
    var Grid = function (_super) {
        tslib_1.__extends(Grid, _super);
        function Grid() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Grid.prototype.ranges = function () {
            var frame, i, j, ranges;
            i = this.dimension;
            j = (i + 1) % 2;
            frame = this.plot.plot_canvas.frame;
            ranges = [
                frame.x_ranges[this.x_range_name],
                frame.y_ranges[this.y_range_name]
            ];
            return [
                ranges[i],
                ranges[j]
            ];
        };
        Grid.prototype.computed_bounds = function () {
            var cross_range, end, range, range_bounds, start, user_bounds;
            _a = this.ranges(), range = _a[0], cross_range = _a[1];
            user_bounds = this.bounds;
            range_bounds = [
                range.min,
                range.max
            ];
            if (types_1.isArray(user_bounds)) {
                start = Math.min(user_bounds[0], user_bounds[1]);
                end = Math.max(user_bounds[0], user_bounds[1]);
                if (start < range_bounds[0]) {
                    start = range_bounds[0];
                } else if (start > range_bounds[1]) {
                    start = null;
                }
                if (end > range_bounds[1]) {
                    end = range_bounds[1];
                } else if (end < range_bounds[0]) {
                    end = null;
                }
            } else {
                start = range_bounds[0], end = range_bounds[1];
            }
            return [
                start,
                end
            ];
            var _a;
        };
        Grid.prototype.grid_coords = function (location, exclude_ends) {
            if (exclude_ends === void 0) {
                exclude_ends = true;
            }
            var N, cmax, cmin, coords, cross_range, dim_i, dim_j, end, i, ii, j, k, l, loc, max, min, n, range, ref, ref1, start, ticks, tmp;
            i = this.dimension;
            j = (i + 1) % 2;
            _a = this.ranges(), range = _a[0], cross_range = _a[1];
            _b = this.computed_bounds(), start = _b[0], end = _b[1];
            tmp = Math.min(start, end);
            end = Math.max(start, end);
            start = tmp;
            // TODO: (bev) using cross_range.min for cross_loc is a bit of a cheat. Since we
            // currently only support "straight line" grids, this should be OK for now. If
            // we ever want to support "curved" grids, e.g. for some projections, we may
            // have to communicate more than just a single cross location.
            ticks = this.ticker.get_ticks(start, end, range, cross_range.min, {})[location];
            min = range.min;
            max = range.max;
            cmin = cross_range.min;
            cmax = cross_range.max;
            coords = [
                [],
                []
            ];
            for (ii = k = 0, ref = ticks.length; 0 <= ref ? k < ref : k > ref; ii = 0 <= ref ? ++k : --k) {
                if ((ticks[ii] === min || ticks[ii] === max) && exclude_ends) {
                    continue;
                }
                dim_i = [];
                dim_j = [];
                N = 2;
                for (n = l = 0, ref1 = N; 0 <= ref1 ? l < ref1 : l > ref1; n = 0 <= ref1 ? ++l : --l) {
                    loc = cmin + (cmax - cmin) / (N - 1) * n;
                    dim_i.push(ticks[ii]);
                    dim_j.push(loc);
                }
                coords[i].push(dim_i);
                coords[j].push(dim_j);
            }
            return coords;
            var _a, _b;
        };
        return Grid;
    }(guide_renderer_1.GuideRenderer);
    exports.Grid = Grid;
    ;
    Grid.prototype.default_view = exports.GridView;
    Grid.prototype.type = 'Grid';
    Grid.mixins([
        'line:grid_',
        'line:minor_grid_',
        'fill:band_'
    ]);
    Grid.define({
        bounds: [
            p.Any,
            'auto'    // TODO (bev)
        ],
        dimension: [
            p.Number,
            0
        ],
        ticker: [p.Instance],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ]
    });
    Grid.override({
        level: 'underlay',
        band_fill_color: null,
        band_fill_alpha: 0,
        grid_line_color: '#e5e5e5',
        minor_grid_line_color: null
    });    
},
/*models/grids/index*/
function _(require, module, exports) {
    var grid_1 = require(133    /* ./grid */);
    exports.Grid = grid_1.Grid;    
},
/*models/index*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    tslib_1.__exportStar(require(57    /* ./annotations */), exports);
    tslib_1.__exportStar(require(73    /* ./axes */), exports);
    tslib_1.__exportStar(require(77    /* ./callbacks */), exports);
    tslib_1.__exportStar(require(81    /* ./canvas */), exports);
    tslib_1.__exportStar(require(83    /* ./expressions */), exports);
    tslib_1.__exportStar(require(89    /* ./filters */), exports);
    tslib_1.__exportStar(require(95    /* ./formatters */), exports);
    tslib_1.__exportStar(require(113    /* ./glyphs */), exports);
    tslib_1.__exportStar(require(130    /* ./graphs */), exports);
    tslib_1.__exportStar(require(134    /* ./grids */), exports);
    tslib_1.__exportStar(require(138    /* ./layouts */), exports);
    tslib_1.__exportStar(require(145    /* ./mappers */), exports);
    tslib_1.__exportStar(require(238    /* ./transforms */), exports);
    tslib_1.__exportStar(require(148    /* ./markers */), exports);
    tslib_1.__exportStar(require(152    /* ./plots */), exports);
    tslib_1.__exportStar(require(158    /* ./ranges */), exports);
    tslib_1.__exportStar(require(164    /* ./renderers */), exports);
    tslib_1.__exportStar(require(167    /* ./scales */), exports);
    tslib_1.__exportStar(require(177    /* ./sources */), exports);
    tslib_1.__exportStar(require(187    /* ./tickers */), exports);
    tslib_1.__exportStar(require(199    /* ./tiles */), exports);
    tslib_1.__exportStar(require(226    /* ./tools */), exports);    
},
/*models/layouts/box*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var indexOf = [].indexOf;
    var solver_1 = require(13    /* core/layout/solver */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var object_1 = require(30    /* core/util/object */);
    var layout_dom_1 = require(139    /* ./layout_dom */);
    var BoxView = function (_super) {
        tslib_1.__extends(BoxView, _super);
        function BoxView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoxView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.properties.children.change, function () {
                return _this.rebuild_child_views();
            });
        };
        BoxView.prototype.get_height = function () {
            var child_heights, children, height;
            children = this.model.get_layoutable_children();
            child_heights = children.map(function (child) {
                return child._height.value;
            });
            if (this.model._horizontal) {
                height = array_1.max(child_heights);
            } else {
                height = array_1.sum(child_heights);
            }
            return height;
        };
        BoxView.prototype.get_width = function () {
            var child_widths, children, width;
            children = this.model.get_layoutable_children();
            child_widths = children.map(function (child) {
                return child._width.value;
            });
            if (this.model._horizontal) {
                width = array_1.sum(child_widths);
            } else {
                width = array_1.max(child_widths);
            }
            return width;
        };
        return BoxView;
    }(layout_dom_1.LayoutDOMView);
    exports.BoxView = BoxView;
    ;
    BoxView.prototype.className = 'bk-grid';
    var Box = function (_super) {
        tslib_1.__extends(Box, _super);
        function Box(attrs, options) {
            var _this = _super.call(this, attrs, options) || this;
            // for children that want to be the same size
            // as other children, make them all equal to these
            _this._child_equal_size_width = new solver_1.Variable(_this.toString() + '.child_equal_size_width');
            _this._child_equal_size_height = new solver_1.Variable(_this.toString() + '.child_equal_size_height');
            // these are passed up to our parent after basing
            // them on the child box_equal_size vars
            _this._box_equal_size_top = new solver_1.Variable(_this.toString() + '.box_equal_size_top');
            _this._box_equal_size_bottom = new solver_1.Variable(_this.toString() + '.box_equal_size_bottom');
            _this._box_equal_size_left = new solver_1.Variable(_this.toString() + '.box_equal_size_left');
            _this._box_equal_size_right = new solver_1.Variable(_this.toString() + '.box_equal_size_right');
            // these are passed up to our parent after basing
            // them on the child box_cell_align vars
            _this._box_cell_align_top = new solver_1.Variable(_this.toString() + '.box_cell_align_top');
            _this._box_cell_align_bottom = new solver_1.Variable(_this.toString() + '.box_cell_align_bottom');
            _this._box_cell_align_left = new solver_1.Variable(_this.toString() + '.box_cell_align_left');
            _this._box_cell_align_right = new solver_1.Variable(_this.toString() + '.box_cell_align_right');
            return _this;
        }
        Box.prototype.get_layoutable_children = function () {
            return this.children;
        };
        Box.prototype.get_constrained_variables = function () {
            return object_1.extend({}, _super.prototype.get_constrained_variables.call(this), {
                box_equal_size_top: this._box_equal_size_top,
                box_equal_size_bottom: this._box_equal_size_bottom,
                box_equal_size_left: this._box_equal_size_left,
                box_equal_size_right: this._box_equal_size_right,
                box_cell_align_top: this._box_cell_align_top,
                box_cell_align_bottom: this._box_cell_align_bottom,
                box_cell_align_left: this._box_cell_align_left,
                box_cell_align_right: this._box_cell_align_right
            });
        };
        Box.prototype.get_constraints = function () {
            var add, child, children, constraints, i, j, k, last, len, next, rect, ref, vars;
            constraints = _super.prototype.get_constraints.call(this);
            add = function () {
                var new_constraints = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    new_constraints[_i] = arguments[_i];
                }
                return constraints.push.apply(constraints, new_constraints);
            };
            children = this.get_layoutable_children();
            if (children.length === 0) {
                // No need to continue further if there are no children. Children sure do
                // make life a lot more complicated.
                return constraints;
            }
            for (j = 0, len = children.length; j < len; j++) {
                child = children[j];
                vars = child.get_constrained_variables();
                // Make total widget sizes fill the orthogonal direction
                // TODO(bird) Can't we make this shorter by using span which has already picked a
                // dominant direction (we'd just also need to set a doc_span)
                rect = this._child_rect(vars);
                if (this._horizontal) {
                    if (vars.height != null) {
                        add(solver_1.EQ(rect.height, [
                            -1,
                            this._height
                        ]));
                    }
                } else {
                    if (vars.width != null) {
                        add(solver_1.EQ(rect.width, [
                            -1,
                            this._width
                        ]));
                    }
                }
                // Add equal_size constraint
                // - A child's "interesting area" (like the plot area) is the same size as the previous child
                //   (a child can opt out of this by not returning the box_equal_size variables)
                if (this._horizontal) {
                    if (vars.box_equal_size_left != null && vars.box_equal_size_right != null && vars.width != null) {
                        add(solver_1.EQ([
                            -1,
                            vars.box_equal_size_left
                        ], [
                            -1,
                            vars.box_equal_size_right
                        ], vars.width, this._child_equal_size_width));
                    }
                } else {
                    if (vars.box_equal_size_top != null && vars.box_equal_size_bottom != null && vars.height != null) {
                        add(solver_1.EQ([
                            -1,
                            vars.box_equal_size_top
                        ], [
                            -1,
                            vars.box_equal_size_bottom
                        ], vars.height, this._child_equal_size_height));
                    }
                }
            }
            // TODO(bird) - This is the second time we loop through children
            last = this._info(children[0].get_constrained_variables());
            add(solver_1.EQ(last.span.start, 0));
            for (i = k = 1, ref = children.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
                next = this._info(children[i].get_constrained_variables());
                // Each child's start equals the previous child's end (unless we have a fixed layout
                // in which case size may not be available)
                if (last.span.size) {
                    add(solver_1.EQ(last.span.start, last.span.size, [
                        -1,
                        next.span.start
                    ]));
                }
                // The whitespace at end of one child + start of next must equal the box spacing.
                // This must be a weak constraint because it can conflict with aligning the
                // alignable edges in each child. Alignment is generally more important visually than spacing.
                add(solver_1.WEAK_EQ(last.whitespace.after, next.whitespace.before, 0 - this.spacing));
                // If we can't satisfy the whitespace being equal to box spacing, we should fix
                // it (align things) by increasing rather than decreasing the whitespace.
                add(solver_1.GE(last.whitespace.after, next.whitespace.before, 0 - this.spacing));
                last = next;
            }
            // Child's side has to stick to the end of the box
            if (this._horizontal) {
                if (vars.width != null) {
                    add(solver_1.EQ(last.span.start, last.span.size, [
                        -1,
                        this._width
                    ]));
                }
            } else {
                if (vars.height != null) {
                    add(solver_1.EQ(last.span.start, last.span.size, [
                        -1,
                        this._height
                    ]));
                }
            }
            // align outermost edges in both dimensions
            // line up edges in same_arity boxes
            // build our equal_size bounds from the child ones
            // propagate cell alignment (between same_arity boxes) up the hierarchy
            // build our whitespace from the child ones
            constraints = constraints.concat(this._align_outer_edges_constraints(true), this._align_outer_edges_constraints(false), this._align_inner_cell_edges_constraints(), this._box_equal_size_bounds(true), this._box_equal_size_bounds(false), this._box_cell_align_bounds(true), this._box_cell_align_bounds(false), this._box_whitespace(true), this._box_whitespace(false));
            // horizontal=true // horizontal=true // horizontal=true // horizontal=true
            return constraints;
        };
        Box.prototype._child_rect = function (vars) {
            return {
                x: vars.origin_x,
                y: vars.origin_y,
                width: vars.width,
                height: vars.height
            };
        };
        Box.prototype._span = function (rect) {
            // return [coordinate, size] pair in box_aligned direction
            if (this._horizontal) {
                return {
                    start: rect.x,
                    size: rect.width
                };
            } else {
                return {
                    start: rect.y,
                    size: rect.height
                };
            }
        };
        Box.prototype._info = function (vars) {
            var span, whitespace;
            if (this._horizontal) {
                whitespace = {
                    before: vars.whitespace_left,
                    after: vars.whitespace_right
                };
            } else {
                whitespace = {
                    before: vars.whitespace_top,
                    after: vars.whitespace_bottom
                };
            }
            span = this._span(this._child_rect(vars));
            return {
                span: span,
                whitespace: whitespace
            };
        };
        Box.prototype._flatten_cell_edge_variables = function (horizontal) {
            var add_path, all_vars, arity, cell, cell_vars, child, children, direction, flattened, j, k, key, kind, len, len1, name, new_key, parsed, path, relevant_edges, variables;
            // All alignment happens in terms of the
            // box_cell_align_{left,right,top,bottom} variables. We add
            // "path" information to variables so we know which ones align,
            // where the "path" includes the box arity and box cell we went
            // through.
            // If we have a row of three plots, we should align the top and
            // bottom variables between the three plots.
            // The flattened dictionary in this case (for the top and left
            // only) should be:
            //   box_cell_align_top : [ 3 vars ]
            //   box_cell_align_bottom : [ 3 vars ]
            // We don't do left/right starting from a row, and left/right
            // edges have nothing to align with here.
            // Now say we have a row of three columns, each with three
            // plots (3x3 = 9). We should align the top/bottom variables
            // across the top three, middle three, and bottom three plots,
            // as if those groupings were rows. We do this by flattening
            // starting from the row first, which gets us a dictionary only
            // of top/bottom variables.
            //   box_cell_align_top col-3-0- : [ 3 plots from top of columns ]
            //   box_cell_align_top col-3-1- : [ 3 plots from middle of columns ]
            //   box_cell_align_top col-3-2- : [ 3 plots from bottom of columns ]
            // "col-3-1-" = 3-cell column, cell index 1.
            // In three later, separate calls to
            // _align_inner_cell_edges_constraints() on each column, we'll
            // get the left/right variables:
            //   box_cell_align_left : [ 3 left-column plots ]
            //   box_cell_align_left : [ 3 middle-column plots ]
            //   box_cell_align_left : [ 3 right-column plots ]
            // Now add another nesting - we have a row of three columns,
            // each with three rows, each with three plots. This is
            // arranged 3x9 = 27.
            //   box_cell_align_top col-3-0- : [ 9 plots from top rows of columns ]
            //   box_cell_align_top col-3-1- : [ 9 plots from middle rows of columns ]
            //   box_cell_align_top col-3-2- : [ 9 plots from bottom rows of columns ]
            // When we make the _align_inner_cell_edges_constraints() calls on each of the three
            // columns, each column will return row-pathed values
            //   box_cell_align_left row-3-0-: [  3 plots in left column of left column ]
            //   box_cell_align_left row-3-1-: [  3 plots in middle column of left column ]
            //   box_cell_align_left row-3-2-: [  3 plots in right column of left column ]
            //   ... same for the middle and right columns
            // Anyway in essence what we do is that we add only rows to the
            // path to left/right variables, and only columns to the path
            // to top/bottom variables.
            // If we nest yet another level we would finally get paths with
            // multiple rows or multiple columns in them.
            if (horizontal) {
                relevant_edges = Box._top_bottom_inner_cell_edge_variables;
            } else {
                relevant_edges = Box._left_right_inner_cell_edge_variables;
            }
            add_path = horizontal !== this._horizontal;
            children = this.get_layoutable_children();
            arity = children.length;
            flattened = {};
            cell = 0;
            for (j = 0, len = children.length; j < len; j++) {
                child = children[j];
                if (child instanceof Box) {
                    cell_vars = child._flatten_cell_edge_variables(horizontal);
                } else {
                    cell_vars = {};
                }
                all_vars = child.get_constrained_variables();
                for (k = 0, len1 = relevant_edges.length; k < len1; k++) {
                    name = relevant_edges[k];
                    if (name in all_vars) {
                        cell_vars[name] = [all_vars[name]];
                    }
                }
                for (key in cell_vars) {
                    variables = cell_vars[key];
                    if (add_path) {
                        parsed = key.split(' ');
                        kind = parsed[0];
                        if (parsed.length > 1) {
                            path = parsed[1];
                        } else {
                            path = '';
                        }
                        if (this._horizontal) {
                            direction = 'row';
                        } else {
                            direction = 'col';
                        }
                        // TODO should we "ignore" arity-1 boxes potentially by not adding a path suffix?
                        new_key = kind + ' ' + direction + '-' + arity + '-' + cell + '-' + path;
                    } else {
                        new_key = key;
                    }
                    if (new_key in flattened) {
                        flattened[new_key] = flattened[new_key].concat(variables);
                    } else {
                        flattened[new_key] = variables;
                    }
                }
                cell = cell + 1;
            }
            return flattened;
        };
        // This should only be called on the toplevel box (twice,
        // once with horizontal=true and once with horizontal=false)
        Box.prototype._align_inner_cell_edges_constraints = function () {
            var constraints, flattened, i, j, key, last, ref, variables;
            constraints = [];
            // XXX: checking for `@document?` is a temporary hack, because document isn't always
            // attached properly. However, if document is not attached then we know it can't be
            // a root, because otherwise add_root() would attach it. All this layout logic should
            // be part of views instead of models and use is_root, etc.
            if (this.document != null && indexOf.call(this.document.roots(), this) >= 0) {
                flattened = this._flatten_cell_edge_variables(this._horizontal);
                for (key in flattened) {
                    variables = flattened[key];
                    if (variables.length > 1) {
                        //console.log("constraining ", key, " ", variables)
                        last = variables[0];
                        for (i = j = 1, ref = variables.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                            constraints.push(solver_1.EQ(variables[i], [
                                -1,
                                last
                            ]));
                        }
                    }
                }
            }
            return constraints;
        };
        // returns a two-item array where each item is a list of edge
        // children from the start and end respectively
        Box.prototype._find_edge_leaves = function (horizontal) {
            var child, child_leaves, children, end, j, leaves, len, start;
            children = this.get_layoutable_children();
            // console.log("  finding edge leaves in #{children.length}-#{@type}, " +
            //  "our orientation #{@_horizontal} finding #{horizontal} children ", children)
            leaves = [
                [],
                []
            ];
            if (children.length > 0) {
                if (this._horizontal === horizontal) {
                    // note start and end may be the same
                    start = children[0];
                    end = children[children.length - 1];
                    if (start instanceof Box) {
                        leaves[0] = leaves[0].concat(start._find_edge_leaves(horizontal)[0]);
                    } else {
                        leaves[0].push(start);
                    }
                    if (end instanceof Box) {
                        leaves[1] = leaves[1].concat(end._find_edge_leaves(horizontal)[1]);
                    } else {
                        leaves[1].push(end);
                    }
                } else {
                    // if we are a column and someone wants the horizontal edges,
                    // we return the horizontal edges from all of our children
                    for (j = 0, len = children.length; j < len; j++) {
                        child = children[j];
                        if (child instanceof Box) {
                            child_leaves = child._find_edge_leaves(horizontal);
                            leaves[0] = leaves[0].concat(child_leaves[0]);
                            leaves[1] = leaves[1].concat(child_leaves[1]);
                        } else {
                            leaves[0].push(child);
                            leaves[1].push(child);
                        }
                    }
                }
            }
            // console.log("  start leaves ", leaves[0].map((leaf) -> leaf.id)
            // console.log("  end leaves ", leaves[1].map((leaf) -> leaf.id)
            return leaves;
        };
        Box.prototype._align_outer_edges_constraints = function (horizontal) {
            var add_all_equal, collect_vars, end_edges, end_leaves, end_variable, result, start_edges, start_leaves, start_variable;
            // console.log("#{if horizontal then 'horizontal' else 'vertical'} outer edge constraints in #{@get_layoutable_children().length}-#{@type}")
            _a = this._find_edge_leaves(horizontal), start_leaves = _a[0], end_leaves = _a[1];
            if (horizontal) {
                start_variable = 'on_edge_align_left';
                end_variable = 'on_edge_align_right';
            } else {
                start_variable = 'on_edge_align_top';
                end_variable = 'on_edge_align_bottom';
            }
            collect_vars = function (leaves, name) {
                var edges, j, leaf, len, vars;
                //console.log("collecting #{name} in ", leaves)
                edges = [];
                for (j = 0, len = leaves.length; j < len; j++) {
                    leaf = leaves[j];
                    vars = leaf.get_constrained_variables();
                    if (name in vars) {
                        edges.push(vars[name]);
                    }
                }
                //vars[name]['_debug'] = "#{name} from #{leaf.id}"
                return edges;
            };
            start_edges = collect_vars(start_leaves, start_variable);
            end_edges = collect_vars(end_leaves, end_variable);
            result = [];
            add_all_equal = function (edges) {
                var edge, first, i, j, ref;
                if (edges.length > 1) {
                    first = edges[0];
                    for (i = j = 1, ref = edges.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                        edge = edges[i];
                        //console.log("  constraining #{first._debug} == #{edge._debug}")
                        result.push(solver_1.EQ([
                            -1,
                            first
                        ], edge));
                    }
                    return null;    // prevent coffeescript from making a tmp array
                }
            };
            add_all_equal(start_edges);
            add_all_equal(end_edges);
            // console.log("computed constraints ", result)
            return result;
            var _a;
        };
        Box.prototype._box_insets_from_child_insets = function (horizontal, child_variable_prefix, our_variable_prefix, minimum) {
            var add_constraints, end_leaves, end_variable, our_end, our_start, result, start_leaves, start_variable;
            _a = this._find_edge_leaves(horizontal), start_leaves = _a[0], end_leaves = _a[1];
            if (horizontal) {
                start_variable = child_variable_prefix + '_left';
                end_variable = child_variable_prefix + '_right';
                our_start = this[our_variable_prefix + '_left'];
                our_end = this[our_variable_prefix + '_right'];
            } else {
                start_variable = child_variable_prefix + '_top';
                end_variable = child_variable_prefix + '_bottom';
                our_start = this[our_variable_prefix + '_top'];
                our_end = this[our_variable_prefix + '_bottom'];
            }
            result = [];
            add_constraints = function (ours, leaves, name) {
                var edges, j, leaf, len, vars;
                edges = [];
                for (j = 0, len = leaves.length; j < len; j++) {
                    leaf = leaves[j];
                    vars = leaf.get_constrained_variables();
                    if (name in vars) {
                        if (minimum) {
                            result.push(solver_1.GE([
                                -1,
                                ours
                            ], vars[name]));
                        } else {
                            result.push(solver_1.EQ([
                                -1,
                                ours
                            ], vars[name]));
                        }
                    }
                }
                return null;    // prevent coffeescript from making a tmp array
            };
            add_constraints(our_start, start_leaves, start_variable);
            add_constraints(our_end, end_leaves, end_variable);
            return result;
            var _a;
        };
        Box.prototype._box_equal_size_bounds = function (horizontal) {
            // false = box bounds equal all outer child bounds exactly
            return this._box_insets_from_child_insets(horizontal, 'box_equal_size', '_box_equal_size', false);
        };
        Box.prototype._box_cell_align_bounds = function (horizontal) {
            // false = box bounds equal all outer child bounds exactly
            return this._box_insets_from_child_insets(horizontal, 'box_cell_align', '_box_cell_align', false);
        };
        Box.prototype._box_whitespace = function (horizontal) {
            // true = box whitespace must be the minimum of child
            // whitespaces (i.e. distance from box edge to the outermost
            // child pixels)
            return this._box_insets_from_child_insets(horizontal, 'whitespace', '_whitespace', true);
        };
        return Box;
    }(layout_dom_1.LayoutDOM);
    exports.Box = Box;
    ;
    Box.prototype.default_view = BoxView;
    Box.define({
        children: [
            p.Array,
            []
        ]
    });
    Box.internal({
        spacing: [
            p.Number,
            6
        ]
    });
    Box._left_right_inner_cell_edge_variables = [
        'box_cell_align_left',
        'box_cell_align_right'
    ];
    Box._top_bottom_inner_cell_edge_variables = [
        'box_cell_align_top',
        'box_cell_align_bottom'
    ];    
},
/*models/layouts/column*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var box_1 = require(136    /* ./box */);
    var ColumnView = function (_super) {
        tslib_1.__extends(ColumnView, _super);
        function ColumnView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ColumnView;
    }(box_1.BoxView);
    exports.ColumnView = ColumnView;
    ;
    ColumnView.prototype.className = 'bk-grid-column';
    var Column = function (_super) {
        tslib_1.__extends(Column, _super);
        function Column(attrs, options) {
            var _this = _super.call(this, attrs, options) || this;
            _this._horizontal = false;
            return _this;
        }
        return Column;
    }(box_1.Box);
    exports.Column = Column;
    ;
    Column.prototype.type = 'Column';
    Column.prototype.default_view = ColumnView;    
},
/*models/layouts/index*/
function _(require, module, exports) {
    var box_1 = require(136    /* ./box */);
    exports.Box = box_1.Box;
    var column_1 = require(137    /* ./column */);
    exports.Column = column_1.Column;
    var layout_dom_1 = require(139    /* ./layout_dom */);
    exports.LayoutDOM = layout_dom_1.LayoutDOM;
    var row_1 = require(140    /* ./row */);
    exports.Row = row_1.Row;
    var spacer_1 = require(141    /* ./spacer */);
    exports.Spacer = spacer_1.Spacer;
    var widget_box_1 = require(142    /* ./widget_box */);
    exports.WidgetBox = widget_box_1.WidgetBox;    
},
/*models/layouts/layout_dom*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var layout_canvas_1 = require(11    /* core/layout/layout_canvas */);
    var solver_1 = require(13    /* core/layout/solver */);
    var build_views_1 = require(4    /* core/build_views */);
    var dom_view_1 = require(6    /* core/dom_view */);
    var logging_1 = require(14    /* core/logging */);
    exports.LayoutDOMView = function (_super) {
        tslib_1.__extends(LayoutDOMView, _super);
        function LayoutDOMView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LayoutDOMView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            // this is a root view
            if (this.is_root) {
                this._solver = new solver_1.Solver();
            }
            this.child_views = {};
            return this.build_child_views();
        };
        LayoutDOMView.prototype.remove = function () {
            var _, ref, view;
            ref = this.child_views;
            for (_ in ref) {
                view = ref[_];
                view.remove();
            }
            this.child_views = {};
            // remove on_resize
            return _super.prototype.remove.call(this);
        };
        LayoutDOMView.prototype.has_finished = function () {
            var _, child, ref;
            if (!_super.prototype.has_finished.call(this)) {
                return false;
            }
            ref = this.child_views;
            for (_ in ref) {
                child = ref[_];
                if (!child.has_finished()) {
                    return false;
                }
            }
            return true;
        };
        LayoutDOMView.prototype.notify_finished = function () {
            if (!this.is_root) {
                return _super.prototype.notify_finished.call(this);
            } else {
                if (!this._idle_notified && this.has_finished()) {
                    if (this.model.document != null) {
                        this._idle_notified = true;
                        return this.model.document.notify_idle(this.model);
                    }
                }
            }
        };
        LayoutDOMView.prototype._calc_width_height = function () {
            var height, measuring, width;
            measuring = this.el;
            while (true) {
                measuring = measuring.parentNode;
                if (measuring == null) {
                    logging_1.logger.warn('detached element');
                    width = height = null;
                    break;
                }
                _a = measuring.getBoundingClientRect(), width = _a.width, height = _a.height;
                if (height !== 0) {
                    break;
                }
            }
            return [
                width,
                height
            ];
            var _a;
        };
        LayoutDOMView.prototype._init_solver = function () {
            var constraint, constraints, edit_variable, editables, i, j, len, len1, variables;
            this._root_width = new solver_1.Variable(this.toString() + '.root_width');
            this._root_height = new solver_1.Variable(this.toString() + '.root_height');
            // XXX: this relies on the fact that missing `strength` argument results
            // in strength being NaN, which behaves like `Strength.required`. However,
            // this is banned by the API.
            this._solver.add_edit_variable(this._root_width);
            this._solver.add_edit_variable(this._root_height);
            editables = this.model.get_all_editables();
            for (i = 0, len = editables.length; i < len; i++) {
                edit_variable = editables[i];
                this._solver.add_edit_variable(edit_variable, solver_1.Strength.strong);
            }
            constraints = this.model.get_all_constraints();
            for (j = 0, len1 = constraints.length; j < len1; j++) {
                constraint = constraints[j];
                this._solver.add_constraint(constraint);
            }
            variables = this.model.get_constrained_variables();
            if (variables.width != null) {
                this._solver.add_constraint(solver_1.EQ(variables.width, this._root_width));
            }
            if (variables.height != null) {
                this._solver.add_constraint(solver_1.EQ(variables.height, this._root_height));
            }
            this._solver.update_variables();
            return this._solver_inited = true;
        };
        LayoutDOMView.prototype._suggest_dims = function (width, height) {
            var variables;
            variables = this.model.get_constrained_variables();
            if (variables.width != null || variables.height != null) {
                if (width === null || height === null) {
                    _a = this._calc_width_height(), width = _a[0], height = _a[1];
                }
                if (variables.width != null && width != null) {
                    this._solver.suggest_value(this._root_width, width);
                }
                if (variables.height != null && height != null) {
                    this._solver.suggest_value(this._root_height, height);
                }
                return this._solver.update_variables();
            }
            var _a;
        };
        LayoutDOMView.prototype.resize = function (width, height) {
            if (width === void 0) {
                width = null;
            }
            if (height === void 0) {
                height = null;
            }
            if (!this.is_root) {
                return this.root.resize(width, height);
            } else {
                return this._do_layout(false, width, height);
            }
        };
        LayoutDOMView.prototype.partial_layout = function () {
            if (!this.is_root) {
                return this.root.partial_layout();
            } else {
                return this._do_layout(false);
            }
        };
        LayoutDOMView.prototype.layout = function (full) {
            if (full === void 0) {
                full = true;
            }
            if (!this.is_root) {
                return this.root.layout();
            } else {
                return this._do_layout(true);
            }
        };
        LayoutDOMView.prototype._do_layout = function (full, width, height) {
            if (width === void 0) {
                width = null;
            }
            if (height === void 0) {
                height = null;
            }
            if (!this._solver_inited || full) {
                this._solver.clear();
                this._init_solver();
            }
            this._suggest_dims(width, height);
            // XXX: do layout twice, because there are interdependencies between views,
            // which currently cannot be resolved with one pass. The third one triggers
            // rendering and (expensive) painting.
            this._layout();
            // layout (1)
            this._layout();
            // layout (2)
            this._layout(true);
            // render & paint
            return this.notify_finished();
        };
        LayoutDOMView.prototype._layout = function (final) {
            if (final === void 0) {
                final = false;
            }
            var child, child_view, i, len, ref;
            ref = this.model.get_layoutable_children();
            for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                child_view = this.child_views[child.id];
                if (child_view._layout != null) {
                    child_view._layout(final);
                }
            }
            this.render();
            if (final) {
                return this._has_finished = true;
            }
        };
        LayoutDOMView.prototype.rebuild_child_views = function () {
            this.solver.clear();
            this.build_child_views();
            return this.layout();
        };
        LayoutDOMView.prototype.build_child_views = function () {
            var child, child_view, children, i, len, results;
            children = this.model.get_layoutable_children();
            build_views_1.build_views(this.child_views, children, { parent: this });
            dom_1.empty(this.el);
            results = [];
            for (i = 0, len = children.length; i < len; i++) {
                child = children[i];
                // Look-up the child_view in @child_views and then append We can't just
                // read from @child_views because then we don't get guaranteed ordering.
                // Which is a problem in non-box layouts.
                child_view = this.child_views[child.id];
                results.push(this.el.appendChild(child_view.el));
            }
            return results;
        };
        LayoutDOMView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            if (this.is_root) {
                window.addEventListener('resize', function () {
                    return _this.resize();
                });
            }
            // XXX: @connect(@model.change, () => @layout())
            return this.connect(this.model.properties.sizing_mode.change, function () {
                return _this.layout();
            });
        };
        LayoutDOMView.prototype._render_classes = function () {
            var cls, i, len, ref, results;
            this.el.className = '';
            // removes all classes
            if (this.className != null) {
                this.el.classList.add(this.className);
            }
            this.el.classList.add('bk-layout-' + this.model.sizing_mode);
            if (this.model.css_classes != null) {
                ref = this.model.css_classes;
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                    cls = ref[i];
                    results.push(this.el.classList.add(cls));
                }
                return results;
            }
        };
        LayoutDOMView.prototype.render = function () {
            var height, width;
            this._render_classes();
            switch (this.model.sizing_mode) {
            case 'fixed':
                // If the width or height is unset:
                // - compute it from children
                // - but then save for future use
                // (for some reason widget boxes keep shrinking if you keep computing
                // but this is more efficient and appropriate for fixed anyway).
                if (this.model.width != null) {
                    width = this.model.width;
                } else {
                    width = this.get_width();
                    this.model.setv({ width: width }, { silent: true });
                }
                if (this.model.height != null) {
                    height = this.model.height;
                } else {
                    height = this.get_height();
                    this.model.setv({ height: height }, { silent: true });
                }
                this.solver.suggest_value(this.model._width, width);
                this.solver.suggest_value(this.model._height, height);
                break;
            case 'scale_width':
                height = this.get_height();
                this.solver.suggest_value(this.model._height, height);
                break;
            case 'scale_height':
                width = this.get_width();
                this.solver.suggest_value(this.model._width, width);
                break;
            case 'scale_both':
                _a = this.get_width_height(), width = _a[0], height = _a[1];
                this.solver.suggest_value(this.model._width, width);
                this.solver.suggest_value(this.model._height, height);
            }
            this.solver.update_variables();
            return this.position();
            var _a;
        };
        LayoutDOMView.prototype.position = function () {
            switch (this.model.sizing_mode) {
            case 'fixed':
            case 'scale_width':
            case 'scale_height':
                this.el.style.position = 'relative';
                this.el.style.left = '';
                this.el.style.top = '';
                break;
            case 'scale_both':
            case 'stretch_both':
                this.el.style.position = 'absolute';
                this.el.style.left = this.model._dom_left.value + 'px';
                this.el.style.top = this.model._dom_top.value + 'px';
            }
            this.el.style.width = this.model._width.value + 'px';
            return this.el.style.height = this.model._height.value + 'px';
        };
        LayoutDOMView.prototype.get_height = function () {
            // Subclasses should implement this to explain
            // what their height should be in sizing_mode mode.
            throw new Error('not implemented');
        };
        LayoutDOMView.prototype.get_width = function () {
            // Subclasses should implement this to explain
            // what their width should be in sizing_mode mode.
            throw new Error('not implemented');
        };
        LayoutDOMView.prototype.get_width_height = function () {
            var ar, height, new_height_1, new_height_2, new_width_1, new_width_2, parent_height, parent_width, width;
            parent_height = this.el.parentNode.clientHeight;
            parent_width = this.el.parentNode.clientWidth;
            ar = this.model.get_aspect_ratio();
            new_width_1 = parent_width;
            new_height_1 = parent_width / ar;
            new_width_2 = parent_height * ar;
            new_height_2 = parent_height;
            if (new_width_1 < new_width_2) {
                width = new_width_1;
                height = new_height_1;
            } else {
                width = new_width_2;
                height = new_height_2;
            }
            return [
                width,
                height
            ];
        };
        return LayoutDOMView;
    }(dom_view_1.DOMView);
    var LayoutDOM = function (_super) {
        tslib_1.__extends(LayoutDOM, _super);
        function LayoutDOM() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LayoutDOM.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._width = new solver_1.Variable(this.toString() + '.width');
            this._height = new solver_1.Variable(this.toString() + '.height');
            // These are the COORDINATES of the four plot sides
            this._left = new solver_1.Variable(this.toString() + '.left');
            this._right = new solver_1.Variable(this.toString() + '.right');
            this._top = new solver_1.Variable(this.toString() + '.top');
            this._bottom = new solver_1.Variable(this.toString() + '.bottom');
            // This is the dom position
            this._dom_top = new solver_1.Variable(this.toString() + '.dom_top');
            this._dom_left = new solver_1.Variable(this.toString() + '.dom_left');
            // This is the distance from the side of the right and bottom,
            this._width_minus_right = new solver_1.Variable(this.toString() + '.width_minus_right');
            this._height_minus_bottom = new solver_1.Variable(this.toString() + '.height_minus_bottom');
            // Whitespace variables
            this._whitespace_top = new solver_1.Variable(this.toString() + '.whitespace_top');
            this._whitespace_bottom = new solver_1.Variable(this.toString() + '.whitespace_bottom');
            this._whitespace_left = new solver_1.Variable(this.toString() + '.whitespace_left');
            return this._whitespace_right = new solver_1.Variable(this.toString() + '.whitespace_right');
        };
        LayoutDOM.prototype.dump_layout = function () {
            var layoutables, obj, pending;
            layoutables = {};
            pending = [this];
            while (pending.length > 0) {
                obj = pending.shift();
                if (obj instanceof LayoutDOM) {
                    pending.push.apply(pending, obj.get_layoutable_children());
                }
                layoutables[obj.toString()] = obj.layout_bbox;
            }
            return console.table(layoutables);
        };
        LayoutDOM.prototype.get_all_constraints = function () {
            var child, constraints, i, len, ref;
            constraints = this.get_constraints();
            ref = this.get_layoutable_children();
            for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child instanceof layout_canvas_1.LayoutCanvas) {
                    constraints = constraints.concat(child.get_constraints());
                } else {
                    constraints = constraints.concat(child.get_all_constraints());
                }
            }
            return constraints;
        };
        LayoutDOM.prototype.get_all_editables = function () {
            var child, editables, i, len, ref;
            editables = this.get_editables();
            ref = this.get_layoutable_children();
            for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child instanceof layout_canvas_1.LayoutCanvas) {
                    editables = editables.concat(child.get_editables());
                } else {
                    editables = editables.concat(child.get_all_editables());
                }
            }
            return editables;
        };
        LayoutDOM.prototype.get_constraints = function () {
            return [
                // Make sure things dont squeeze out of their bounding box
                solver_1.GE(this._dom_left),
                solver_1.GE(this._dom_top),
                // Plot has to be inside the width/height
                solver_1.GE(this._left),
                solver_1.GE(this._width, [
                    -1,
                    this._right
                ]),
                solver_1.GE(this._top),
                solver_1.GE(this._height, [
                    -1,
                    this._bottom
                ]),
                //# Declare computed constraints
                solver_1.EQ(this._width_minus_right, [
                    -1,
                    this._width
                ], this._right),
                solver_1.EQ(this._height_minus_bottom, [
                    -1,
                    this._height
                ], this._bottom)
            ];
        };
        LayoutDOM.prototype.get_layoutable_children = function () {
            return [];
        };
        LayoutDOM.prototype.get_editables = function () {
            switch (this.sizing_mode) {
            case 'fixed':
                return [
                    this._height,
                    this._width
                ];
            case 'scale_width':
                return [this._height];
            case 'scale_height':
                return [this._width];
            case 'scale_both':
                return [
                    this._width,
                    this._height
                ];
            default:
                return [];
            }
        };
        LayoutDOM.prototype.get_constrained_variables = function () {
            var vars;
            // THE FOLLOWING ARE OPTIONAL VARS THAT
            // YOU COULD ADD INTO SUBCLASSES
            //  # When this widget is on the edge of a box visually,
            //  # align these variables down that edge. Right/bottom
            //  # are an inset from the edge.
            //  on_edge_align_top    : @_top
            //  on_edge_align_bottom : @_height_minus_bottom
            //  on_edge_align_left   : @_left
            //  on_edge_align_right  : @_width_minus_right
            //  # When this widget is in a box cell with the same "arity
            //  # path" as a widget in another cell, align these variables
            //  # between the two box cells. Right/bottom are an inset from
            //  # the edge.
            //  box_cell_align_top   : @_top
            //  box_cell_align_bottom: @_height_minus_bottom
            //  box_cell_align_left  : @_left
            //  box_cell_align_right : @_width_minus_right
            //  # When this widget is in a box, make these the same distance
            //  # apart in every widget. Right/bottom are inset from the edge.
            //  box_equal_size_top   : @_top
            //  box_equal_size_bottom: @_height_minus_bottom
            //  box_equal_size_left  : @_left
            //  box_equal_size_right : @_width_minus_right
            vars = {
                origin_x: this._dom_left,
                origin_y: this._dom_top,
                whitespace_top: this._whitespace_top,
                whitespace_bottom: this._whitespace_bottom,
                whitespace_left: this._whitespace_left,
                whitespace_right: this._whitespace_right
            };
            switch (this.sizing_mode) {
            case 'stretch_both':
                vars.width = this._width;
                vars.height = this._height;
                break;
            case 'scale_width':
                vars.width = this._width;
                break;
            case 'scale_height':
                vars.height = this._height;
            }
            return vars;
        };
        LayoutDOM.prototype.get_aspect_ratio = function () {
            return this.width / this.height;
        };
        return LayoutDOM;
    }(model_1.Model);
    exports.LayoutDOM = LayoutDOM;
    ;
    LayoutDOM.prototype.type = 'LayoutDOM';
    LayoutDOM.getters({
        layout_bbox: function () {
            return {
                top: this._top.value,
                left: this._left.value,
                width: this._width.value,
                height: this._height.value,
                right: this._right.value,
                bottom: this._bottom.value,
                dom_top: this._dom_top.value,
                dom_left: this._dom_left.value
            };
        }
    });
    LayoutDOM.define({
        height: [p.Number],
        width: [p.Number],
        disabled: [
            p.Bool,
            false
        ],
        sizing_mode: [
            p.SizingMode,
            'fixed'
        ],
        css_classes: [
            p.Array,
            []
        ]
    });    
},
/*models/layouts/row*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var box_1 = require(136    /* ./box */);
    var RowView = function (_super) {
        tslib_1.__extends(RowView, _super);
        function RowView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RowView;
    }(box_1.BoxView);
    exports.RowView = RowView;
    ;
    RowView.prototype.className = 'bk-grid-row';
    var Row = function (_super) {
        tslib_1.__extends(Row, _super);
        function Row(attrs, options) {
            var _this = _super.call(this, attrs, options) || this;
            _this._horizontal = true;
            return _this;
        }
        return Row;
    }(box_1.Box);
    exports.Row = Row;
    ;
    Row.prototype.type = 'Row';
    Row.prototype.default_view = RowView;    
},
/*models/layouts/spacer*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var layout_dom_1 = require(139    /* ./layout_dom */);
    var object_1 = require(30    /* core/util/object */);
    var SpacerView = function (_super) {
        tslib_1.__extends(SpacerView, _super);
        function SpacerView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SpacerView.prototype.render = function () {
            _super.prototype.render.call(this);
            if (this.sizing_mode === 'fixed') {
                this.el.style.width = this.model.width + 'px';
                return this.el.style.height = this.model.height + 'px';
            }
        };
        SpacerView.prototype.get_height = function () {
            // spacer must always have some height
            return 1;
        };
        return SpacerView;
    }(layout_dom_1.LayoutDOMView);
    exports.SpacerView = SpacerView;
    ;
    SpacerView.prototype.className = 'bk-spacer-box';
    var Spacer = function (_super) {
        tslib_1.__extends(Spacer, _super);
        function Spacer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Spacer.prototype.get_constrained_variables = function () {
            return object_1.extend({}, _super.prototype.get_constrained_variables.call(this), {
                on_edge_align_top: this._top,
                on_edge_align_bottom: this._height_minus_bottom,
                on_edge_align_left: this._left,
                on_edge_align_right: this._width_minus_right,
                box_cell_align_top: this._top,
                box_cell_align_bottom: this._height_minus_bottom,
                box_cell_align_left: this._left,
                box_cell_align_right: this._width_minus_right,
                box_equal_size_top: this._top,
                box_equal_size_bottom: this._height_minus_bottom,
                box_equal_size_left: this._left,
                box_equal_size_right: this._width_minus_right
            });
        };
        return Spacer;
    }(layout_dom_1.LayoutDOM);
    exports.Spacer = Spacer;
    ;
    Spacer.prototype.type = 'Spacer';
    Spacer.prototype.default_view = SpacerView;    
},
/*models/layouts/widget_box*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var hasProp = {}.hasOwnProperty;
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var object_1 = require(30    /* core/util/object */);
    var layout_dom_1 = require(139    /* ../layouts/layout_dom */);
    var WidgetBoxView = function (_super) {
        tslib_1.__extends(WidgetBoxView, _super);
        function WidgetBoxView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WidgetBoxView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.properties.children.change, function () {
                return _this.rebuild_child_views();
            });
        };
        WidgetBoxView.prototype.render = function () {
            var css_width, height, width;
            this._render_classes();
            // XXX: because no super()
            if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_height') {
                width = this.get_width();
                if (this.model._width.value !== width) {
                    this.solver.suggest_value(this.model._width, width);
                }
            }
            if (this.model.sizing_mode === 'fixed' || this.model.sizing_mode === 'scale_width') {
                height = this.get_height();
                if (this.model._height.value !== height) {
                    this.solver.suggest_value(this.model._height, height);
                }
            }
            this.solver.update_variables();
            if (this.model.sizing_mode === 'stretch_both') {
                this.el.style.position = 'absolute';
                this.el.style.left = this.model._dom_left.value + 'px';
                this.el.style.top = this.model._dom_top.value + 'px';
                this.el.style.width = this.model._width.value + 'px';
                return this.el.style.height = this.model._height.value + 'px';
            } else {
                // Note we DO NOT want to set a height (except in stretch_both). Widgets
                // are happier sizing themselves. We've tried to tell the layout what
                // the height is with the suggest_value. But that doesn't mean we need
                // to put it in the dom.
                if (this.model._width.value - 20 > 0) {
                    css_width = this.model._width.value - 20 + 'px';
                } else {
                    css_width = '100%';
                }
                return this.el.style.width = css_width;
            }
        };
        WidgetBoxView.prototype.get_height = function () {
            var child_view, el, height, key, marginBottom, marginTop, ref, style;
            height = 0;
            ref = this.child_views;
            for (key in ref) {
                if (!hasProp.call(ref, key))
                    continue;
                child_view = ref[key];
                el = child_view.el;
                style = getComputedStyle(el);
                marginTop = parseInt(style.marginTop) || 0;
                marginBottom = parseInt(style.marginBottom) || 0;
                height += el.offsetHeight + marginTop + marginBottom;
            }
            return height + 20;
        };
        WidgetBoxView.prototype.get_width = function () {
            var child_view, child_width, key, ref, width;
            if (this.model.width != null) {
                return this.model.width;
            } else {
                width = this.el.scrollWidth + 20;
                ref = this.child_views;
                for (key in ref) {
                    if (!hasProp.call(ref, key))
                        continue;
                    child_view = ref[key];
                    // Take the max width of all the children as the constrainer.
                    child_width = child_view.el.scrollWidth;
                    if (child_width > width) {
                        width = child_width;
                    }
                }
                return width;
            }
        };
        return WidgetBoxView;
    }(layout_dom_1.LayoutDOMView);
    exports.WidgetBoxView = WidgetBoxView;
    ;
    WidgetBoxView.prototype.className = 'bk-widget-box';
    var WidgetBox = function (_super) {
        tslib_1.__extends(WidgetBox, _super);
        function WidgetBox() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WidgetBox.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            if (this.sizing_mode === 'fixed' && this.width === null) {
                // Set a default for fixed.
                this.width = 300;
                logging_1.logger.info('WidgetBox mode is fixed, but no width specified. Using default of 300.');
            }
            if (this.sizing_mode === 'scale_height') {
                return logging_1.logger.warn('sizing_mode `scale_height` is not experimental for WidgetBox. Please report your results to the bokeh dev team so we can improve.');
            }
        };
        WidgetBox.prototype.get_constrained_variables = function () {
            var vars;
            vars = object_1.extend({}, _super.prototype.get_constrained_variables.call(this), {
                on_edge_align_top: this._top,
                on_edge_align_bottom: this._height_minus_bottom,
                on_edge_align_left: this._left,
                on_edge_align_right: this._width_minus_right,
                box_cell_align_top: this._top,
                box_cell_align_bottom: this._height_minus_bottom,
                box_cell_align_left: this._left,
                box_cell_align_right: this._width_minus_right,
                box_equal_size_top: this._top,
                box_equal_size_bottom: this._height_minus_bottom
            });
            if (this.sizing_mode !== 'fixed') {
                vars.box_equal_size_left = this._left;
                vars.box_equal_size_right = this._width_minus_right;
            }
            return vars;
        };
        WidgetBox.prototype.get_layoutable_children = function () {
            return this.children;
        };
        return WidgetBox;
    }(layout_dom_1.LayoutDOM);
    exports.WidgetBox = WidgetBox;
    ;
    WidgetBox.prototype.type = 'WidgetBox';
    WidgetBox.prototype.default_view = WidgetBoxView;
    WidgetBox.define({
        children: [
            p.Array,
            []
        ]
    });    
},
/*models/mappers/categorical_color_mapper*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var _equals;
    var color_mapper_1 = require(144    /* ./color_mapper */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    _equals = function (a, b) {
        var i, j, ref;
        if (a.length !== b.length) {
            return false;
        }
        for (i = j = 0, ref = a.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    };
    var CategoricalColorMapper = function (_super) {
        tslib_1.__extends(CategoricalColorMapper, _super);
        function CategoricalColorMapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CategoricalColorMapper.prototype._get_values = function (data, palette) {
            var color, d, j, key, len, values;
            values = [];
            for (j = 0, len = data.length; j < len; j++) {
                d = data[j];
                if (types_1.isString(d)) {
                    key = this.factors.indexOf(d);
                } else {
                    if (this.start != null) {
                        if (this.end != null) {
                            d = d.slice(this.start, this.end);
                        } else {
                            d = d.slice(this.start);
                        }
                    } else if (this.end != null) {
                        d = d.slice(0, this.end);
                    }
                    if (d.length === 1) {
                        key = this.factors.indexOf(d[0]);
                    } else {
                        key = array_1.findIndex(this.factors, function (x) {
                            return _equals(x, d);
                        });
                    }
                }
                if (key < 0 || key >= palette.length) {
                    color = this.nan_color;
                } else {
                    color = palette[key];
                }
                values.push(color);
            }
            return values;
        };
        return CategoricalColorMapper;
    }(color_mapper_1.ColorMapper);
    exports.CategoricalColorMapper = CategoricalColorMapper;
    ;
    CategoricalColorMapper.prototype.type = 'CategoricalColorMapper';
    CategoricalColorMapper.define({
        factors: [p.Array],
        start: [
            p.Number,
            0
        ],
        end: [p.Number]
    });    
},
/*models/mappers/color_mapper*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var p = require(15    /* core/properties */);
    var transform_1 = require(243    /* ../transforms/transform */);
    var types_1 = require(42    /* core/util/types */);
    var ColorMapper = function (_super) {
        tslib_1.__extends(ColorMapper, _super);
        function ColorMapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColorMapper.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._little_endian = this._is_little_endian();
            this._palette = this._build_palette(this.palette);
            return this.connect(this.change, function () {
                return this._palette = this._build_palette(this.palette);
            });
        };
        // TODO (bev) This should not be needed, everything should use v_compute
        ColorMapper.prototype.v_map_screen = function (data, image_glyph) {
            if (image_glyph === void 0) {
                image_glyph = false;
            }
            var buf, color, i, ind, j, k, ref, ref1, value, values;
            values = this._get_values(data, this._palette, image_glyph);
            buf = new ArrayBuffer(data.length * 4);
            if (this._little_endian) {
                color = new Uint8Array(buf);
                for (i = j = 0, ref = data.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    value = values[i];
                    ind = i * 4;
                    // Bitwise math in JS is limited to 31-bits, to handle 32-bit value
                    // this uses regular math to compute alpha instead (see issue #6755)
                    color[ind] = Math.floor(value / 4278190080 * 255);
                    color[ind + 1] = (value & 16711680) >> 16;
                    color[ind + 2] = (value & 65280) >> 8;
                    color[ind + 3] = value & 255;
                }
            } else {
                color = new Uint32Array(buf);
                for (i = k = 0, ref1 = data.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                    value = values[i];
                    color[i] = value << 8 | 255;    // alpha
                }
            }
            return buf;
        };
        ColorMapper.prototype.compute = function (x) {
            // If it's just a single value, then a color mapper doesn't
            // really make sense, so return nothing
            return null;
        };
        ColorMapper.prototype.v_compute = function (xs) {
            var values;
            values = this._get_values(xs, this.palette);
            return values;
        };
        ColorMapper.prototype._get_values = function (data, palette, image_glyph) {
            if (image_glyph === void 0) {
                image_glyph = false;
            }
            return [];
        };
        // Should be defined by subclass
        ColorMapper.prototype._is_little_endian = function () {
            var buf, buf32, buf8, little_endian;
            buf = new ArrayBuffer(4);
            buf8 = new Uint8Array(buf);
            buf32 = new Uint32Array(buf);
            buf32[1] = 168496141;
            little_endian = true;
            if (buf8[4] === 10 && buf8[5] === 11 && buf8[6] === 12 && buf8[7] === 13) {
                little_endian = false;
            }
            return little_endian;
        };
        ColorMapper.prototype._build_palette = function (palette) {
            var _convert, i, j, new_palette, ref;
            new_palette = new Uint32Array(palette.length);
            _convert = function (value) {
                if (types_1.isNumber(value)) {
                    return value;
                } else {
                    if (value.length !== 9) {
                        value = value + 'ff';
                    }
                    return parseInt(value.slice(1), 16);
                }
            };
            for (i = j = 0, ref = palette.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                new_palette[i] = _convert(palette[i]);
            }
            return new_palette;
        };
        return ColorMapper;
    }(transform_1.Transform);
    exports.ColorMapper = ColorMapper;
    ;
    ColorMapper.prototype.type = 'ColorMapper';
    ColorMapper.define({
        palette: [p.Any],
        nan_color: [
            p.Color,
            'gray'
        ]
    });    
},
/*models/mappers/index*/
function _(require, module, exports) {
    var categorical_color_mapper_1 = require(143    /* ./categorical_color_mapper */);
    exports.CategoricalColorMapper = categorical_color_mapper_1.CategoricalColorMapper;
    var color_mapper_1 = require(144    /* ./color_mapper */);
    exports.ColorMapper = color_mapper_1.ColorMapper;
    var linear_color_mapper_1 = require(146    /* ./linear_color_mapper */);
    exports.LinearColorMapper = linear_color_mapper_1.LinearColorMapper;
    var log_color_mapper_1 = require(147    /* ./log_color_mapper */);
    exports.LogColorMapper = log_color_mapper_1.LogColorMapper;    
},
/*models/mappers/linear_color_mapper*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var p = require(15    /* core/properties */);
    var color_1 = require(26    /* core/util/color */);
    var array_1 = require(22    /* core/util/array */);
    var color_mapper_1 = require(144    /* ./color_mapper */);
    var LinearColorMapper = function (_super) {
        tslib_1.__extends(LinearColorMapper, _super);
        function LinearColorMapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LinearColorMapper.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];
            this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;
            return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;
        };
        LinearColorMapper.prototype._get_values = function (data, palette, image_glyph) {
            if (image_glyph === void 0) {
                image_glyph = false;
            }
            var d, high, high_color, i, key, len, low, low_color, max_key, nan_color, norm_factor, normed_d, normed_interval, ref, ref1, values;
            low = (ref = this.low) != null ? ref : array_1.min(data);
            high = (ref1 = this.high) != null ? ref1 : array_1.max(data);
            max_key = palette.length - 1;
            values = [];
            nan_color = image_glyph ? this._nan_color : this.nan_color;
            low_color = image_glyph ? this._low_color : this.low_color;
            high_color = image_glyph ? this._high_color : this.high_color;
            norm_factor = 1 / (high - low);
            normed_interval = 1 / palette.length;
            for (i = 0, len = data.length; i < len; i++) {
                d = data[i];
                if (isNaN(d)) {
                    values.push(nan_color);
                    continue;
                }
                // This handles the edge case where d == high, since the code below maps
                // values exactly equal to high to palette.length, which is greater than
                // max_key
                if (d === high) {
                    values.push(palette[max_key]);
                    continue;
                }
                normed_d = (d - low) * norm_factor;
                key = Math.floor(normed_d / normed_interval);
                if (key < 0) {
                    if (this.low_color != null) {
                        values.push(low_color);
                    } else {
                        values.push(palette[0]);
                    }
                } else if (key > max_key) {
                    if (this.high_color != null) {
                        values.push(high_color);
                    } else {
                        values.push(palette[max_key]);
                    }
                } else {
                    values.push(palette[key]);
                }
            }
            return values;
        };
        return LinearColorMapper;
    }(color_mapper_1.ColorMapper);
    exports.LinearColorMapper = LinearColorMapper;
    ;
    LinearColorMapper.prototype.type = 'LinearColorMapper';
    LinearColorMapper.define({
        high: [p.Number],
        low: [p.Number],
        high_color: [p.Color],
        low_color: [p.Color]
    });    
},
/*models/mappers/log_color_mapper*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var log1p, ref;
    var p = require(15    /* core/properties */);
    var color_1 = require(26    /* core/util/color */);
    var array_1 = require(22    /* core/util/array */);
    var color_mapper_1 = require(144    /* ./color_mapper */);
    // Math.log1p() is not supported by any version of IE, so let's use a polyfill based on
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p.
    log1p = (ref = Math.log1p) != null ? ref : function (x) {
        return Math.log(1 + x);
    };
    var LogColorMapper = function (_super) {
        tslib_1.__extends(LogColorMapper, _super);
        function LogColorMapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LogColorMapper.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._nan_color = this._build_palette([color_1.color2hex(this.nan_color)])[0];
            this._high_color = this.high_color != null ? this._build_palette([color_1.color2hex(this.high_color)])[0] : void 0;
            return this._low_color = this.low_color != null ? this._build_palette([color_1.color2hex(this.low_color)])[0] : void 0;
        };
        LogColorMapper.prototype._get_values = function (data, palette, image_glyph) {
            if (image_glyph === void 0) {
                image_glyph = false;
            }
            var d, high, high_color, i, key, len, log, low, low_color, max_key, n, nan_color, ref1, ref2, scale, values;
            n = palette.length;
            low = (ref1 = this.low) != null ? ref1 : array_1.min(data);
            high = (ref2 = this.high) != null ? ref2 : array_1.max(data);
            scale = n / (log1p(high) - log1p(low));
            // subtract the low offset
            max_key = palette.length - 1;
            values = [];
            nan_color = image_glyph ? this._nan_color : this.nan_color;
            high_color = image_glyph ? this._high_color : this.high_color;
            low_color = image_glyph ? this._low_color : this.low_color;
            for (i = 0, len = data.length; i < len; i++) {
                d = data[i];
                // Check NaN
                if (isNaN(d)) {
                    values.push(nan_color);
                    continue;
                }
                if (d > high) {
                    if (this.high_color != null) {
                        values.push(high_color);
                    } else {
                        values.push(palette[max_key]);
                    }
                    continue;
                }
                // This handles the edge case where d == high, since the code below maps
                // values exactly equal to high to palette.length, which is greater than
                // max_key
                if (d === high) {
                    values.push(palette[max_key]);
                    continue;
                }
                if (d < low) {
                    if (this.low_color != null) {
                        values.push(low_color);
                    } else {
                        values.push(palette[0]);
                    }
                    continue;
                }
                // Get the key
                log = log1p(d) - log1p(low);
                // subtract the low offset
                key = Math.floor(log * scale);
                // Deal with upper bound
                if (key > max_key) {
                    key = max_key;
                }
                values.push(palette[key]);
            }
            return values;
        };
        return LogColorMapper;
    }(color_mapper_1.ColorMapper);
    exports.LogColorMapper = LogColorMapper;
    ;
    LogColorMapper.prototype.type = 'LogColorMapper';
    LogColorMapper.define({
        high: [p.Number],
        low: [p.Number],
        high_color: [p.Color],
        low_color: [p.Color]
    });    
},
/*models/markers/index*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var SQ3, _mk_model, _one_cross, _one_diamond, _one_tri, _one_x, asterisk, circle_cross, circle_x, cross, diamond, diamond_cross, inverted_triangle, square, square_cross, square_x, triangle, x;
    var marker_1 = require(149    /* ./marker */);
    SQ3 = Math.sqrt(3);
    _one_x = function (ctx, r) {
        ctx.moveTo(-r, r);
        ctx.lineTo(r, -r);
        ctx.moveTo(-r, -r);
        return ctx.lineTo(r, r);
    };
    _one_cross = function (ctx, r) {
        ctx.moveTo(0, r);
        ctx.lineTo(0, -r);
        ctx.moveTo(-r, 0);
        return ctx.lineTo(r, 0);
    };
    _one_diamond = function (ctx, r) {
        ctx.moveTo(0, r);
        ctx.lineTo(r / 1.5, 0);
        ctx.lineTo(0, -r);
        ctx.lineTo(-r / 1.5, 0);
        return ctx.closePath();
    };
    _one_tri = function (ctx, r) {
        var a, h;
        h = r * SQ3;
        a = h / 3;
        // TODO (bev) use viewstate to take y-axis inversion into account
        ctx.moveTo(-r, a);
        ctx.lineTo(r, a);
        ctx.lineTo(0, a - h);
        return ctx.closePath();
    };
    asterisk = function (ctx, i, sx, sy, r, line, fill) {
        var r2;
        r2 = r * 0.65;
        _one_cross(ctx, r);
        _one_x(ctx, r2);
        if (line.doit) {
            line.set_vectorize(ctx, i);
            ctx.stroke();
        }
    };
    circle_cross = function (ctx, i, sx, sy, r, line, fill) {
        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            _one_cross(ctx, r);
            ctx.stroke();
        }
    };
    circle_x = function (ctx, i, sx, sy, r, line, fill) {
        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            _one_x(ctx, r);
            ctx.stroke();
        }
    };
    cross = function (ctx, i, sx, sy, r, line, fill) {
        _one_cross(ctx, r);
        if (line.doit) {
            line.set_vectorize(ctx, i);
            ctx.stroke();
        }
    };
    diamond = function (ctx, i, sx, sy, r, line, fill) {
        _one_diamond(ctx, r);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            ctx.stroke();
        }
    };
    diamond_cross = function (ctx, i, sx, sy, r, line, fill) {
        _one_diamond(ctx, r);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            _one_cross(ctx, r);
            ctx.stroke();
        }
    };
    inverted_triangle = function (ctx, i, sx, sy, r, line, fill) {
        ctx.rotate(Math.PI);
        _one_tri(ctx, r);
        ctx.rotate(-Math.PI);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            ctx.stroke();
        }
    };
    square = function (ctx, i, sx, sy, r, line, fill) {
        var size;
        size = 2 * r;
        ctx.rect(-r, -r, size, size);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            ctx.stroke();
        }
    };
    square_cross = function (ctx, i, sx, sy, r, line, fill) {
        var size;
        size = 2 * r;
        ctx.rect(-r, -r, size, size);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            _one_cross(ctx, r);
            ctx.stroke();
        }
    };
    square_x = function (ctx, i, sx, sy, r, line, fill) {
        var size;
        size = 2 * r;
        ctx.rect(-r, -r, size, size);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            _one_x(ctx, r);
            ctx.stroke();
        }
    };
    triangle = function (ctx, i, sx, sy, r, line, fill) {
        _one_tri(ctx, r);
        if (fill.doit) {
            fill.set_vectorize(ctx, i);
            ctx.fill();
        }
        if (line.doit) {
            line.set_vectorize(ctx, i);
            ctx.stroke();
        }
    };
    x = function (ctx, i, sx, sy, r, line, fill) {
        _one_x(ctx, r);
        if (line.doit) {
            line.set_vectorize(ctx, i);
            ctx.stroke();
        }
    };
    _mk_model = function (type, f) {
        var model, view;
        view = function () {
            var view = function (_super) {
                tslib_1.__extends(view, _super);
                function view() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return view;
            }(marker_1.MarkerView);
            ;
            view.prototype._render_one = f;
            return view;
        }();
        model = function () {
            var model = function (_super) {
                tslib_1.__extends(model, _super);
                function model() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return model;
            }(marker_1.Marker);
            ;
            model.prototype.default_view = view;
            model.prototype.type = type;
            return model;
        }();
        return model;
    };
    // markers are final, so no need to export views
    exports.Asterisk = _mk_model('Asterisk', asterisk);
    exports.CircleCross = _mk_model('CircleCross', circle_cross);
    exports.CircleX = _mk_model('CircleX', circle_x);
    exports.Cross = _mk_model('Cross', cross);
    exports.Diamond = _mk_model('Diamond', diamond);
    exports.DiamondCross = _mk_model('DiamondCross', diamond_cross);
    exports.InvertedTriangle = _mk_model('InvertedTriangle', inverted_triangle);
    exports.Square = _mk_model('Square', square);
    exports.SquareCross = _mk_model('SquareCross', square_cross);
    exports.SquareX = _mk_model('SquareX', square_x);
    exports.Triangle = _mk_model('Triangle', triangle);
    exports.X = _mk_model('X', x);    
},
/*models/markers/marker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var xy_glyph_1 = require(128    /* ../glyphs/xy_glyph */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    exports.MarkerView = function (_super) {
        tslib_1.__extends(MarkerView, _super);
        function MarkerView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MarkerView.prototype.draw_legend_for_index = function (ctx, x0, x1, y0, y1, index) {
            var angle, data, indices, size, sx, sy;
            // using objects like this seems a little wonky, since the keys are coerced to
            // stings, but it works
            indices = [index];
            sx = {};
            sx[index] = (x0 + x1) / 2;
            sy = {};
            sy[index] = (y0 + y1) / 2;
            size = {};
            size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;
            angle = {};
            angle[index] = this._angle[index];
            data = {
                sx: sx,
                sy: sy,
                _size: size,
                _angle: angle
            };
            return this._render(ctx, indices, data);
        };
        MarkerView.prototype._render = function (ctx, indices, _a) {
            var sx = _a.sx, sy = _a.sy, _size = _a._size, _angle = _a._angle;
            var i, j, len, r, results;
            results = [];
            for (j = 0, len = indices.length; j < len; j++) {
                i = indices[j];
                if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i])) {
                    continue;
                }
                r = _size[i] / 2;
                ctx.beginPath();
                ctx.translate(sx[i], sy[i]);
                if (_angle[i]) {
                    ctx.rotate(_angle[i]);
                }
                this._render_one(ctx, i, sx[i], sy[i], r, this.visuals.line, this.visuals.fill);
                if (_angle[i]) {
                    ctx.rotate(-_angle[i]);
                }
                results.push(ctx.translate(-sx[i], -sy[i]));
            }
            return results;
        };
        MarkerView.prototype._mask_data = function (all_indices) {
            var bbox, hr, sx0, sx1, sy0, sy1, vr, x0, x1, y0, y1;
            // dilate the inner screen region by max_size and map back to data space for use in
            // spatial query
            hr = this.renderer.plot_view.frame.bbox.h_range;
            sx0 = hr.start - this.max_size;
            sx1 = hr.end + this.max_size;
            _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
            vr = this.renderer.plot_view.frame.bbox.v_range;
            sy0 = vr.start - this.max_size;
            sy1 = vr.end + this.max_size;
            _b = this.renderer.yscale.r_invert(sy0, sy1), y0 = _b[0], y1 = _b[1];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            return this.index.indices(bbox);
            var _a, _b;
        };
        MarkerView.prototype._hit_point = function (geometry) {
            var bbox, candidates, dist, hits, i, j, len, s2, sx, sx0, sx1, sy, sy0, sy1, x0, x1, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            sx0 = sx - this.max_size;
            sx1 = sx + this.max_size;
            _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
            sy0 = sy - this.max_size;
            sy1 = sy + this.max_size;
            _b = this.renderer.yscale.r_invert(sy0, sy1), y0 = _b[0], y1 = _b[1];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            candidates = this.index.indices(bbox);
            hits = [];
            for (j = 0, len = candidates.length; j < len; j++) {
                i = candidates[j];
                s2 = this._size[i] / 2;
                dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);
                if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {
                    hits.push([
                        i,
                        dist
                    ]);
                }
            }
            return hittest.create_1d_hit_test_result(hits);
            var _a, _b;
        };
        MarkerView.prototype._hit_span = function (geometry) {
            var bbox, hits, maxX, maxY, minX, minY, ms, result, sx, sx0, sx1, sy, sy0, sy1, x0, x1, y0, y1;
            sx = geometry.sx, sy = geometry.sy;
            _a = this.bounds(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
            result = hittest.create_hit_test_result();
            if (geometry.direction === 'h') {
                y0 = minY;
                y1 = maxY;
                ms = this.max_size / 2;
                sx0 = sx - ms;
                sx1 = sx + ms;
                _b = this.renderer.xscale.r_invert(sx0, sx1), x0 = _b[0], x1 = _b[1];
            } else {
                x0 = minX;
                x1 = maxX;
                ms = this.max_size / 2;
                sy0 = sy - ms;
                sy1 = sy + ms;
                _c = this.renderer.yscale.r_invert(sy0, sy1), y0 = _c[0], y1 = _c[1];
            }
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            hits = this.index.indices(bbox);
            result['1d'].indices = hits;
            return result;
            var _a, _b, _c;
        };
        MarkerView.prototype._hit_rect = function (geometry) {
            var bbox, result, sx0, sx1, sy0, sy1, x0, x1, y0, y1;
            sx0 = geometry.sx0, sx1 = geometry.sx1, sy0 = geometry.sy0, sy1 = geometry.sy1;
            _a = this.renderer.xscale.r_invert(sx0, sx1), x0 = _a[0], x1 = _a[1];
            _b = this.renderer.yscale.r_invert(sy0, sy1), y0 = _b[0], y1 = _b[1];
            bbox = hittest.validate_bbox_coords([
                x0,
                x1
            ], [
                y0,
                y1
            ]);
            result = hittest.create_hit_test_result();
            result['1d'].indices = this.index.indices(bbox);
            return result;
            var _a, _b;
        };
        MarkerView.prototype._hit_poly = function (geometry) {
            var candidates, hits, i, idx, j, k, ref, ref1, result, results, sx, sy;
            sx = geometry.sx, sy = geometry.sy;
            // TODO (bev) use spatial index to pare candidate list
            candidates = function () {
                results = [];
                for (var j = 0, ref = this.sx.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
                    results.push(j);
                }
                return results;
            }.apply(this);
            hits = [];
            for (i = k = 0, ref1 = candidates.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                idx = candidates[i];
                if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {
                    hits.push(idx);
                }
            }
            result = hittest.create_hit_test_result();
            result['1d'].indices = hits;
            return result;
        };
        return MarkerView;
    }(xy_glyph_1.XYGlyphView);
    var Marker = function (_super) {
        tslib_1.__extends(Marker, _super);
        function Marker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Marker;
    }(xy_glyph_1.XYGlyph);
    exports.Marker = Marker;
    ;
    Marker.mixins([
        'line',
        'fill'
    ]);
    Marker.define({
        size: [
            p.DistanceSpec,
            {
                units: 'screen',
                value: 4
            }
        ],
        angle: [
            p.AngleSpec,
            0
        ]
    });    
},
/*models/plots/gmap_plot*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var logging_1 = require(14    /* core/logging */);
    var gmap_plot_canvas_1 = require(151    /* ./gmap_plot_canvas */);
    var plot_1 = require(153    /* ./plot */);
    var p = require(15    /* core/properties */);
    var model_1 = require(50    /* ../../model */);
    var MapOptions = function (_super) {
        tslib_1.__extends(MapOptions, _super);
        function MapOptions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return MapOptions;
    }(model_1.Model);
    exports.MapOptions = MapOptions;
    ;
    MapOptions.prototype.type = 'MapOptions';
    MapOptions.define({
        lat: [p.Number],
        lng: [p.Number],
        zoom: [
            p.Number,
            12
        ]
    });
    var GMapOptions = function (_super) {
        tslib_1.__extends(GMapOptions, _super);
        function GMapOptions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GMapOptions;
    }(MapOptions);
    exports.GMapOptions = GMapOptions;
    ;
    GMapOptions.prototype.type = 'GMapOptions';
    GMapOptions.define({
        map_type: [
            p.String,
            'roadmap'
        ],
        scale_control: [
            p.Bool,
            false
        ],
        styles: [p.String]
    });
    exports.GMapPlotView = function (_super) {
        tslib_1.__extends(GMapPlotView, _super);
        function GMapPlotView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GMapPlotView;
    }(plot_1.PlotView);
    var GMapPlot = function (_super) {
        tslib_1.__extends(GMapPlot, _super);
        function GMapPlot() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GMapPlot.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            if (!this.api_key) {
                return logging_1.logger.error('api_key is required. See https://developers.google.com/maps/documentation/javascript/get-api-key for more information on how to obtain your own.');
            }
        };
        GMapPlot.prototype._init_plot_canvas = function () {
            return new gmap_plot_canvas_1.GMapPlotCanvas({ plot: this });
        };
        return GMapPlot;
    }(plot_1.Plot);
    exports.GMapPlot = GMapPlot;
    ;
    GMapPlot.prototype.type = 'GMapPlot';
    GMapPlot.prototype.default_view = exports.GMapPlotView;
    // Set all the PlotCanvas properties as internal.
    // This seems to be necessary so that everything can initialize.
    // Feels very clumsy, but I'm not sure how the properties system wants
    // to handle something like this situation.
    GMapPlot.define({
        map_options: [p.Instance],
        api_key: [p.String]
    });    
},
/*models/plots/gmap_plot_canvas*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var gmaps_ready, load_google_api, boundMethodCheck = function (instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new Error('Bound instance method accessed before binding');
            }
        };
    var proj4_1 = require(31    /* core/util/proj4 */);
    var plot_canvas_1 = require(154    /* ./plot_canvas */);
    var signaling_1 = require(20    /* core/signaling */);
    gmaps_ready = new signaling_1.Signal(this, 'gmaps_ready');
    load_google_api = function (api_key) {
        var script;
        window._bokeh_gmaps_callback = function () {
            return gmaps_ready.emit();
        };
        script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = 'https://maps.googleapis.com/maps/api/js?key=' + api_key + '&callback=_bokeh_gmaps_callback';
        return document.body.appendChild(script);
    };
    exports.GMapPlotCanvasView = function (_super) {
        tslib_1.__extends(GMapPlotCanvasView, _super);
        function GMapPlotCanvasView() {
            var _this = _super.apply(this, arguments) || this;
            _this._get_latlon_bounds = _this._get_latlon_bounds.bind(_this);
            _this._get_projected_bounds = _this._get_projected_bounds.bind(_this);
            _this._set_bokeh_ranges = _this._set_bokeh_ranges.bind(_this);
            return _this;
        }
        GMapPlotCanvasView.prototype.initialize = function (options) {
            var _this = this;
            var mo, ref;
            this.pause();
            _super.prototype.initialize.call(this, options);
            this._tiles_loaded = false;
            this.zoom_count = 0;
            mo = this.model.plot.map_options;
            this.initial_zoom = mo.zoom;
            this.initial_lat = mo.lat;
            this.initial_lng = mo.lng;
            this.canvas_view.map_el.style.position = 'absolute';
            if (((ref = window.google) != null ? ref.maps : void 0) == null) {
                if (window._bokeh_gmaps_callback == null) {
                    load_google_api(this.model.plot.api_key);
                }
                gmaps_ready.connect(function () {
                    return _this.request_render();
                });
            }
            return this.unpause();
        };
        GMapPlotCanvasView.prototype.update_range = function (range_info) {
            var mo, new_map_zoom, old_map_zoom, proj_xend, proj_xstart, proj_yend, proj_ystart, zoom_change;
            // RESET -------------------------
            if (range_info == null) {
                mo = this.model.plot.map_options;
                this.map.setCenter({
                    lat: this.initial_lat,
                    lng: this.initial_lng
                });
                this.map.setOptions({ zoom: this.initial_zoom });
                _super.prototype.update_range.call(this, null);    // PAN ----------------------------
            } else if (range_info.sdx != null || range_info.sdy != null) {
                this.map.panBy(range_info.sdx, range_info.sdy);
                _super.prototype.update_range.call(this, range_info);    // ZOOM ---------------------------
            } else if (range_info.factor != null) {
                // The zoom count decreases the sensitivity of the zoom. (We could make this user configurable)
                if (this.zoom_count !== 10) {
                    this.zoom_count += 1;
                    return;
                }
                this.zoom_count = 0;
                this.pause();
                _super.prototype.update_range.call(this, range_info);
                if (range_info.factor < 0) {
                    zoom_change = -1;
                } else {
                    zoom_change = 1;
                }
                old_map_zoom = this.map.getZoom();
                new_map_zoom = old_map_zoom + zoom_change;
                // Zooming out too far causes problems
                if (new_map_zoom >= 2) {
                    this.map.setZoom(new_map_zoom);
                    // Check we haven't gone out of bounds, and if we have undo the zoom
                    _a = this._get_projected_bounds(), proj_xstart = _a[0], proj_xend = _a[1], proj_ystart = _a[2], proj_yend = _a[3];
                    if (proj_xend - proj_xstart < 0) {
                        this.map.setZoom(old_map_zoom);
                    }
                }
                this.unpause();
            }
            // Finally re-center
            return this._set_bokeh_ranges();
            var _a;
        };
        GMapPlotCanvasView.prototype._build_map = function () {
            var _this = this;
            var map_options, maps, mo;
            maps = window.google.maps;
            this.map_types = {
                satellite: maps.MapTypeId.SATELLITE,
                terrain: maps.MapTypeId.TERRAIN,
                roadmap: maps.MapTypeId.ROADMAP,
                hybrid: maps.MapTypeId.HYBRID
            };
            mo = this.model.plot.map_options;
            map_options = {
                center: new maps.LatLng(mo.lat, mo.lng),
                zoom: mo.zoom,
                disableDefaultUI: true,
                mapTypeId: this.map_types[mo.map_type],
                scaleControl: mo.scale_control
            };
            if (mo.styles != null) {
                map_options.styles = JSON.parse(mo.styles);
            }
            // create the map with above options in div
            this.map = new maps.Map(this.canvas_view.map_el, map_options);
            // update bokeh ranges whenever the map idles, which should be after most UI action
            maps.event.addListener(this.map, 'idle', function () {
                return _this._set_bokeh_ranges();
            });
            // also need an event when bounds change so that map resizes trigger renders too
            maps.event.addListener(this.map, 'bounds_changed', function () {
                return _this._set_bokeh_ranges();
            });
            maps.event.addListenerOnce(this.map, 'tilesloaded', function () {
                return _this._render_finished();
            });
            // wire up listeners so that changes to properties are reflected
            this.connect(this.model.plot.properties.map_options.change, function () {
                return _this._update_options();
            });
            this.connect(this.model.plot.map_options.properties.styles.change, function () {
                return _this._update_styles();
            });
            this.connect(this.model.plot.map_options.properties.lat.change, function () {
                return _this._update_center('lat');
            });
            this.connect(this.model.plot.map_options.properties.lng.change, function () {
                return _this._update_center('lng');
            });
            this.connect(this.model.plot.map_options.properties.zoom.change, function () {
                return _this._update_zoom();
            });
            this.connect(this.model.plot.map_options.properties.map_type.change, function () {
                return _this._update_map_type();
            });
            return this.connect(this.model.plot.map_options.properties.scale_control.change, function () {
                return _this._update_scale_control();
            });
        };
        GMapPlotCanvasView.prototype._render_finished = function () {
            this._tiles_loaded = true;
            return this.notify_finished();
        };
        GMapPlotCanvasView.prototype.has_finished = function () {
            return _super.prototype.has_finished.call(this) && this._tiles_loaded === true;
        };
        GMapPlotCanvasView.prototype._get_latlon_bounds = function () {
            var bottom_left, bounds, top_right, xend, xstart, yend, ystart;
            boundMethodCheck(this, GMapPlotCanvasView);
            bounds = this.map.getBounds();
            top_right = bounds.getNorthEast();
            bottom_left = bounds.getSouthWest();
            xstart = bottom_left.lng();
            xend = top_right.lng();
            ystart = bottom_left.lat();
            yend = top_right.lat();
            return [
                xstart,
                xend,
                ystart,
                yend
            ];
        };
        GMapPlotCanvasView.prototype._get_projected_bounds = function () {
            var proj_xend, proj_xstart, proj_yend, proj_ystart, xend, xstart, yend, ystart;
            boundMethodCheck(this, GMapPlotCanvasView);
            _a = this._get_latlon_bounds(), xstart = _a[0], xend = _a[1], ystart = _a[2], yend = _a[3];
            _b = proj4_1.proj4(proj4_1.mercator, [
                xstart,
                ystart
            ]), proj_xstart = _b[0], proj_ystart = _b[1];
            _c = proj4_1.proj4(proj4_1.mercator, [
                xend,
                yend
            ]), proj_xend = _c[0], proj_yend = _c[1];
            return [
                proj_xstart,
                proj_xend,
                proj_ystart,
                proj_yend
            ];
            var _a, _b, _c;
        };
        GMapPlotCanvasView.prototype._set_bokeh_ranges = function () {
            var proj_xend, proj_xstart, proj_yend, proj_ystart;
            boundMethodCheck(this, GMapPlotCanvasView);
            _a = this._get_projected_bounds(), proj_xstart = _a[0], proj_xend = _a[1], proj_ystart = _a[2], proj_yend = _a[3];
            this.frame.x_range.setv({
                start: proj_xstart,
                end: proj_xend
            });
            return this.frame.y_range.setv({
                start: proj_ystart,
                end: proj_yend
            });
            var _a;
        };
        GMapPlotCanvasView.prototype._update_center = function (fld) {
            var c;
            c = this.map.getCenter().toJSON();
            c[fld] = this.model.plot.map_options[fld];
            this.map.setCenter(c);
            return this._set_bokeh_ranges();
        };
        GMapPlotCanvasView.prototype._update_map_type = function () {
            var maps;
            maps = window.google.maps;
            return this.map.setOptions({ mapTypeId: this.map_types[this.model.plot.map_options.map_type] });
        };
        GMapPlotCanvasView.prototype._update_scale_control = function () {
            var maps;
            maps = window.google.maps;
            return this.map.setOptions({ scaleControl: this.model.plot.map_options.scale_control });
        };
        GMapPlotCanvasView.prototype._update_options = function () {
            this._update_styles();
            this._update_center('lat');
            this._update_center('lng');
            this._update_zoom();
            return this._update_map_type();
        };
        GMapPlotCanvasView.prototype._update_styles = function () {
            return this.map.setOptions({ styles: JSON.parse(this.model.plot.map_options.styles) });
        };
        GMapPlotCanvasView.prototype._update_zoom = function () {
            this.map.setOptions({ zoom: this.model.plot.map_options.zoom });
            return this._set_bokeh_ranges();
        };
        // this method is expected and called by PlotCanvasView.render
        GMapPlotCanvasView.prototype._map_hook = function (ctx, frame_box) {
            var height, left, ref, top, width;
            left = frame_box[0], top = frame_box[1], width = frame_box[2], height = frame_box[3];
            this.canvas_view.map_el.style.top = top + 'px';
            this.canvas_view.map_el.style.left = left + 'px';
            this.canvas_view.map_el.style.width = width + 'px';
            this.canvas_view.map_el.style.height = height + 'px';
            if (this.map == null && ((ref = window.google) != null ? ref.maps : void 0) != null) {
                return this._build_map();
            }
        };
        // this overrides the standard _paint_empty to make the inner canvas transparent
        GMapPlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {
            var ih, iw, left, oh, ow, top;
            ow = this.canvas._width.value;
            oh = this.canvas._height.value;
            left = frame_box[0], top = frame_box[1], iw = frame_box[2], ih = frame_box[3];
            ctx.clearRect(0, 0, ow, oh);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, oh);
            ctx.lineTo(ow, oh);
            ctx.lineTo(ow, 0);
            ctx.lineTo(0, 0);
            ctx.moveTo(left, top);
            ctx.lineTo(left + iw, top);
            ctx.lineTo(left + iw, top + ih);
            ctx.lineTo(left, top + ih);
            ctx.lineTo(left, top);
            ctx.closePath();
            ctx.fillStyle = this.model.plot.border_fill_color;
            return ctx.fill();
        };
        return GMapPlotCanvasView;
    }(plot_canvas_1.PlotCanvasView);
    var GMapPlotCanvas = function (_super) {
        tslib_1.__extends(GMapPlotCanvas, _super);
        function GMapPlotCanvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GMapPlotCanvas.prototype.initialize = function (attrs, options) {
            this.use_map = true;
            return _super.prototype.initialize.call(this, attrs, options);
        };
        return GMapPlotCanvas;
    }(plot_canvas_1.PlotCanvas);
    exports.GMapPlotCanvas = GMapPlotCanvas;
    ;
    GMapPlotCanvas.prototype.type = 'GMapPlotCanvas';
    GMapPlotCanvas.prototype.default_view = exports.GMapPlotCanvasView;    
},
/*models/plots/index*/
function _(require, module, exports) {
    var gmap_plot_1 = require(150    /* ./gmap_plot */);
    exports.MapOptions = gmap_plot_1.MapOptions;
    var gmap_plot_2 = require(150    /* ./gmap_plot */);
    exports.GMapOptions = gmap_plot_2.GMapOptions;
    var gmap_plot_3 = require(150    /* ./gmap_plot */);
    exports.GMapPlot = gmap_plot_3.GMapPlot;
    var gmap_plot_canvas_1 = require(151    /* ./gmap_plot_canvas */);
    exports.GMapPlotCanvas = gmap_plot_canvas_1.GMapPlotCanvas;
    var plot_1 = require(153    /* ./plot */);
    exports.Plot = plot_1.Plot;
    var plot_canvas_1 = require(154    /* ./plot_canvas */);
    exports.PlotCanvas = plot_canvas_1.PlotCanvas;    
},
/*models/plots/plot*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var solver_1 = require(13    /* core/layout/solver */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var object_1 = require(30    /* core/util/object */);
    var types_1 = require(42    /* core/util/types */);
    var layout_dom_1 = require(139    /* ../layouts/layout_dom */);
    var title_1 = require(65    /* ../annotations/title */);
    var linear_scale_1 = require(168    /* ../scales/linear_scale */);
    var toolbar_1 = require(233    /* ../tools/toolbar */);
    var toolbar_panel_1 = require(66    /* ../annotations/toolbar_panel */);
    var plot_canvas_1 = require(154    /* ./plot_canvas */);
    var column_data_source_1 = require(173    /* ../sources/column_data_source */);
    var glyph_renderer_1 = require(161    /* ../renderers/glyph_renderer */);
    var bokeh_events_1 = require(3    /* core/bokeh_events */);
    var PlotView = function (_super) {
        tslib_1.__extends(PlotView, _super);
        function PlotView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PlotView.prototype.connect_signals = function () {
            var title_msg;
            _super.prototype.connect_signals.call(this);
            // Note: Title object cannot be replaced after initialization, similar to axes, and also
            // not being able to change the sizing_mode. All of these changes require a re-initialization
            // of all constraints which we don't currently support.
            title_msg = 'Title object cannot be replaced. Try changing properties on title to update it after initialization.';
            return this.connect(this.model.properties.title.change, function () {
                return logging_1.logger.warn(title_msg);
            });
        };
        PlotView.prototype.get_height = function () {
            return this.model._width.value / this.model.get_aspect_ratio();
        };
        PlotView.prototype.get_width = function () {
            return this.model._height.value * this.model.get_aspect_ratio();
        };
        PlotView.prototype.save = function (name) {
            return this.plot_canvas_view.save(name);
        };
        return PlotView;
    }(layout_dom_1.LayoutDOMView);
    exports.PlotView = PlotView;
    ;
    PlotView.prototype.className = 'bk-plot-layout';
    PlotView.getters({
        plot_canvas_view: function () {
            return this.child_views[this.model._plot_canvas.id];
        }
    });
    var Plot = function (_super) {
        tslib_1.__extends(Plot, _super);
        function Plot() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Plot.prototype.initialize = function (options) {
            var i, j, k, layout_renderers, len, len1, len2, plots, ref, ref1, ref2, renderer, results, side, xr, yr;
            _super.prototype.initialize.call(this, options);
            ref = object_1.values(this.extra_x_ranges).concat(this.x_range);
            for (i = 0, len = ref.length; i < len; i++) {
                xr = ref[i];
                plots = xr.plots;
                if (types_1.isArray(plots)) {
                    plots = plots.concat(this);
                    xr.setv({ plots: plots }, { silent: true });
                }
            }
            ref1 = object_1.values(this.extra_y_ranges).concat(this.y_range);
            for (j = 0, len1 = ref1.length; j < len1; j++) {
                yr = ref1[j];
                plots = yr.plots;
                if (types_1.isArray(plots)) {
                    plots = plots.concat(this);
                    yr.setv({ plots: plots }, { silent: true });
                }
            }
            // Min border applies to the edge of everything
            if (this.min_border != null) {
                if (this.min_border_top == null) {
                    this.min_border_top = this.min_border;
                }
                if (this.min_border_bottom == null) {
                    this.min_border_bottom = this.min_border;
                }
                if (this.min_border_left == null) {
                    this.min_border_left = this.min_border;
                }
                if (this.min_border_right == null) {
                    this.min_border_right = this.min_border;
                }
            }
            this._init_title_panel();
            this._init_toolbar_panel();
            this._plot_canvas = this._init_plot_canvas();
            this.plot_canvas.toolbar = this.toolbar;
            // Set width & height to be the passed in plot_width and plot_height
            // We may need to be more subtle about this - not sure why people use one
            // or the other.
            if (this.width == null) {
                this.width = this.plot_width;
            }
            if (this.height == null) {
                this.height = this.plot_height;
            }
            ref2 = [
                'above',
                'below',
                'left',
                'right'
            ];
            // Setup side renderers
            results = [];
            for (k = 0, len2 = ref2.length; k < len2; k++) {
                side = ref2[k];
                layout_renderers = this.getv(side);
                results.push(function () {
                    var l, len3, results1;
                    results1 = [];
                    for (l = 0, len3 = layout_renderers.length; l < len3; l++) {
                        renderer = layout_renderers[l];
                        results1.push(renderer.add_panel(side));
                    }
                    return results1;
                }());
            }
            return results;
        };
        Plot.prototype._init_plot_canvas = function () {
            return new plot_canvas_1.PlotCanvas({ plot: this });
        };
        Plot.prototype._init_title_panel = function () {
            var title;
            if (this.title != null) {
                title = types_1.isString(this.title) ? new title_1.Title({ text: this.title }) : this.title;
                return this.add_layout(title, this.title_location);
            }
        };
        Plot.prototype._init_toolbar_panel = function () {
            var _this = this;
            var i, items, len, models, ref, title;
            if (this._toolbar_panel != null) {
                ref = [
                    this.left,
                    this.right,
                    this.above,
                    this.below,
                    this.renderers
                ];
                for (i = 0, len = ref.length; i < len; i++) {
                    items = ref[i];
                    array_1.removeBy(items, function (item) {
                        return item === _this._toolbar_panel;
                    });
                }
                this._toolbar_panel = null;
            }
            switch (this.toolbar_location) {
            case 'left':
            case 'right':
            case 'above':
            case 'below':
                this._toolbar_panel = new toolbar_panel_1.ToolbarPanel({ toolbar: this.toolbar });
                this.toolbar.toolbar_location = this.toolbar_location;
                if (this.toolbar_sticky) {
                    models = this.getv(this.toolbar_location);
                    title = array_1.find(models, function (model) {
                        return model instanceof title_1.Title;
                    });
                    if (title != null) {
                        this._toolbar_panel.set_panel(title.panel);
                        this.add_renderers(this._toolbar_panel);
                        return;
                    }
                }
                return this.add_layout(this._toolbar_panel, this.toolbar_location);
            }
        };
        Plot.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            return this.connect(this.properties.toolbar_location.change, function () {
                return _this._init_toolbar_panel();
            });
        };
        Plot.prototype._doc_attached = function () {
            this.plot_canvas.attach_document(this.document);
            return _super.prototype._doc_attached.call(this);
        };
        Plot.prototype.add_renderers = function () {
            var new_renderers = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                new_renderers[_i] = arguments[_i];
            }
            var renderers;
            renderers = this.renderers;
            renderers = renderers.concat(new_renderers);
            return this.renderers = renderers;
        };
        Plot.prototype.add_layout = function (renderer, side) {
            if (side === void 0) {
                side = 'center';
            }
            var side_renderers;
            if (renderer.props.plot != null) {
                renderer.plot = this;
            }
            if (side !== 'center') {
                side_renderers = this.getv(side);
                side_renderers.push(renderer);
                renderer.add_panel(side);
            }
            return this.add_renderers(renderer);
        };
        Plot.prototype.add_glyph = function (glyph, source, attrs) {
            if (attrs === void 0) {
                attrs = {};
            }
            var renderer;
            if (source == null) {
                source = new column_data_source_1.ColumnDataSource();
            }
            attrs = object_1.extend({}, attrs, {
                data_source: source,
                glyph: glyph
            });
            renderer = new glyph_renderer_1.GlyphRenderer(attrs);
            this.add_renderers(renderer);
            return renderer;
        };
        Plot.prototype.add_tools = function () {
            var tools = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                tools[_i] = arguments[_i];
            }
            var i, len, tool;
            for (i = 0, len = tools.length; i < len; i++) {
                tool = tools[i];
                if (tool.overlay != null) {
                    this.add_renderers(tool.overlay);
                }
            }
            return this.toolbar.tools = this.toolbar.tools.concat(tools);
        };
        Plot.prototype.get_layoutable_children = function () {
            return [this.plot_canvas];
        };
        Plot.prototype.get_constraints = function () {
            var constraints;
            constraints = _super.prototype.get_constraints.call(this);
            constraints.push(solver_1.EQ(this._width, [
                -1,
                this.plot_canvas._width
            ]));
            constraints.push(solver_1.EQ(this._height, [
                -1,
                this.plot_canvas._height
            ]));
            return constraints;
        };
        Plot.prototype.get_constrained_variables = function () {
            var vars;
            vars = object_1.extend({}, _super.prototype.get_constrained_variables.call(this), {
                on_edge_align_top: this.plot_canvas._top,
                on_edge_align_bottom: this.plot_canvas._height_minus_bottom,
                on_edge_align_left: this.plot_canvas._left,
                on_edge_align_right: this.plot_canvas._width_minus_right,
                box_cell_align_top: this.plot_canvas._top,
                box_cell_align_bottom: this.plot_canvas._height_minus_bottom,
                box_cell_align_left: this.plot_canvas._left,
                box_cell_align_right: this.plot_canvas._width_minus_right,
                box_equal_size_top: this.plot_canvas._top,
                box_equal_size_bottom: this.plot_canvas._height_minus_bottom
            });
            if (this.sizing_mode !== 'fixed') {
                vars.box_equal_size_left = this.plot_canvas._left;
                vars.box_equal_size_right = this.plot_canvas._width_minus_right;
            }
            return vars;
        };
        return Plot;
    }(layout_dom_1.LayoutDOM);
    exports.Plot = Plot;
    ;
    Plot.prototype.type = 'Plot';
    Plot.prototype.default_view = PlotView;
    Plot.getters({
        plot_canvas: function () {
            return this._plot_canvas;
        }
    });
    // SETUP PROPERTIES
    Plot.mixins([
        'line:outline_',
        'fill:background_',
        'fill:border_'
    ]);
    Plot.define({
        toolbar: [
            p.Instance,
            function () {
                return new toolbar_1.Toolbar();
            }
        ],
        toolbar_location: [
            p.Location,
            'right'
        ],
        toolbar_sticky: [
            p.Boolean,
            true
        ],
        plot_width: [
            p.Number,
            600
        ],
        plot_height: [
            p.Number,
            600
        ],
        title: [
            p.Any,
            function () {
                return new title_1.Title({
                    text: ''    // TODO: p.Either(p.Instance(Title), p.String)
                });
            }
        ],
        title_location: [
            p.Location,
            'above'
        ],
        h_symmetry: [
            p.Bool,
            true
        ],
        v_symmetry: [
            p.Bool,
            false
        ],
        above: [
            p.Array,
            []
        ],
        below: [
            p.Array,
            []
        ],
        left: [
            p.Array,
            []
        ],
        right: [
            p.Array,
            []
        ],
        renderers: [
            p.Array,
            []
        ],
        x_range: [p.Instance],
        extra_x_ranges: [
            p.Any,
            {}
        ],
        y_range: [p.Instance],
        extra_y_ranges: [
            p.Any,
            {}
        ],
        x_scale: [
            p.Instance,
            function () {
                return new linear_scale_1.LinearScale();
            }
        ],
        y_scale: [
            p.Instance,
            function () {
                return new linear_scale_1.LinearScale();
            }
        ],
        lod_factor: [
            p.Number,
            10
        ],
        lod_interval: [
            p.Number,
            300
        ],
        lod_threshold: [
            p.Number,
            2000
        ],
        lod_timeout: [
            p.Number,
            500
        ],
        hidpi: [
            p.Bool,
            true
        ],
        output_backend: [
            p.OutputBackend,
            'canvas'
        ],
        min_border: [
            p.Number,
            5
        ],
        min_border_top: [
            p.Number,
            null
        ],
        min_border_left: [
            p.Number,
            null
        ],
        min_border_bottom: [
            p.Number,
            null
        ],
        min_border_right: [
            p.Number,
            null
        ],
        inner_width: [p.Number],
        inner_height: [p.Number],
        layout_width: [p.Number],
        layout_height: [p.Number],
        match_aspect: [
            p.Bool,
            false
        ],
        aspect_scale: [
            p.Number,
            1
        ]
    });
    Plot.override({
        outline_line_color: '#e5e5e5',
        border_fill_color: '#ffffff',
        background_fill_color: '#ffffff'
    });
    Plot.getters({
        all_renderers: function () {
            var i, len, ref, renderers, tool;
            renderers = this.renderers;
            ref = this.toolbar.tools;
            for (i = 0, len = ref.length; i < len; i++) {
                tool = ref[i];
                renderers = renderers.concat(tool.synthetic_renderers);
            }
            return renderers;
        },
        webgl: function () {
            log.warning('webgl attr is deprecated, use output_backend');
            return this.output_backend === 'webgl';
        },
        tool_events: function () {
            log.warning('tool_events attr is deprecated, use SelectionGeometry Event');
            return null;
        }
    });
    bokeh_events_1.register_with_event(bokeh_events_1.UIEvent, Plot);    
},
/*models/plots/plot_canvas*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var AbovePanel, BelowPanel, LeftPanel, RightPanel, global_glcanvas, indexOf = [].indexOf;
    var canvas_1 = require(79    /* ../canvas/canvas */);
    var cartesian_frame_1 = require(80    /* ../canvas/cartesian_frame */);
    var data_range1d_1 = require(156    /* ../ranges/data_range1d */);
    var glyph_renderer_1 = require(161    /* ../renderers/glyph_renderer */);
    var layout_dom_1 = require(139    /* ../layouts/layout_dom */);
    var signaling_1 = require(20    /* core/signaling */);
    var build_views_1 = require(4    /* core/build_views */);
    var ui_events_1 = require(21    /* core/ui_events */);
    var visuals_1 = require(46    /* core/visuals */);
    var dom_view_1 = require(6    /* core/dom_view */);
    var layout_canvas_1 = require(11    /* core/layout/layout_canvas */);
    var alignments_1 = require(10    /* core/layout/alignments */);
    var solver_1 = require(13    /* core/layout/solver */);
    var logging_1 = require(14    /* core/logging */);
    var enums = require(7    /* core/enums */);
    var p = require(15    /* core/properties */);
    var throttle_1 = require(41    /* core/util/throttle */);
    var types_1 = require(42    /* core/util/types */);
    var array_1 = require(22    /* core/util/array */);
    var object_1 = require(30    /* core/util/object */);
    var side_panel_1 = require(12    /* core/layout/side_panel */);
    // Notes on WebGL support:
    // Glyps can be rendered into the original 2D canvas, or in a (hidden)
    // webgl canvas that we create below. In this way, the rest of bokehjs
    // can keep working as it is, and we can incrementally update glyphs to
    // make them use GL.
    // When the author or user wants to, we try to create a webgl canvas,
    // which is saved on the ctx object that gets passed around during drawing.
    // The presence (and not-being-false) of the ctx.glcanvas attribute is the
    // marker that we use throughout that determines whether we have gl support.
    global_glcanvas = null;
    var PlotCanvasView = function (_super) {
        tslib_1.__extends(PlotCanvasView, _super);
        function PlotCanvasView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PlotCanvasView.prototype.view_options = function () {
            return object_1.extend({
                plot_view: this,
                parent: this
            }, this.options);
        };
        PlotCanvasView.prototype.pause = function () {
            if (this._is_paused == null) {
                return this._is_paused = 1;
            } else {
                return this._is_paused += 1;
            }
        };
        PlotCanvasView.prototype.unpause = function (no_render) {
            if (no_render === void 0) {
                no_render = false;
            }
            this._is_paused -= 1;
            if (this._is_paused === 0 && !no_render) {
                return this.request_render();
            }
        };
        PlotCanvasView.prototype.request_render = function () {
            return this.request_paint();
        };
        PlotCanvasView.prototype.request_paint = function () {
            if (!this.is_paused) {
                this.throttled_paint();
            }
        };
        PlotCanvasView.prototype.remove = function () {
            build_views_1.remove_views(this.renderer_views);
            build_views_1.remove_views(this.tool_views);
            this.canvas_view.remove();
            this.canvas_view = null;
            return _super.prototype.remove.call(this);
        };
        PlotCanvasView.prototype.initialize = function (options) {
            var _this = this;
            var j, len, level, ref;
            this.pause();
            _super.prototype.initialize.call(this, options);
            this.force_paint = new signaling_1.Signal(this, 'force_paint');
            this.state_changed = new signaling_1.Signal(this, 'state_changed');
            this.lod_started = false;
            this.visuals = new visuals_1.Visuals(this.model.plot);
            this._initial_state_info = {
                range: null,
                selection: {},
                dimensions: {
                    width: this.model.canvas._width.value,
                    height: this.model.canvas._height.value
                }
            };
            // compat, to be removed
            this.frame = this.model.frame;
            this.canvas = this.model.canvas;
            this.canvas_view = new this.canvas.default_view({
                model: this.canvas,
                parent: this
            });
            this.el.appendChild(this.canvas_view.el);
            this.canvas_view.render();
            // If requested, try enabling webgl
            if (this.model.plot.output_backend === 'webgl') {
                this.init_webgl();
            }
            this.throttled_paint = throttle_1.throttle(function () {
                return _this.force_paint.emit();
            }, 15);
            // TODO (bev) configurable
            this.ui_event_bus = new ui_events_1.UIEvents(this, this.model.toolbar, this.canvas_view.el, this.model.plot);
            this.levels = {};
            ref = enums.RenderLevel;
            for (j = 0, len = ref.length; j < len; j++) {
                level = ref[j];
                this.levels[level] = {};
            }
            this.renderer_views = {};
            this.tool_views = {};
            this.build_levels();
            this.build_tools();
            this.update_dataranges();
            this.unpause(true);
            logging_1.logger.debug('PlotView initialized');
            return this;
        };
        PlotCanvasView.prototype.set_cursor = function (cursor) {
            if (cursor === void 0) {
                cursor = 'default';
            }
            return this.canvas_view.el.style.cursor = cursor;
        };
        PlotCanvasView.prototype.init_webgl = function () {
            var ctx, glcanvas, opts;
            ctx = this.canvas_view.ctx;
            // We use a global invisible canvas and gl context. By having a global context,
            // we avoid the limitation of max 16 contexts that most browsers have.
            glcanvas = global_glcanvas;
            if (glcanvas == null) {
                global_glcanvas = glcanvas = document.createElement('canvas');
                opts = {
                    'premultipliedAlpha': true    // premultipliedAlpha is true by default
                };
                glcanvas.gl = glcanvas.getContext('webgl', opts) || glcanvas.getContext('experimental-webgl', opts);
            }
            // If WebGL is available, we store a reference to the gl canvas on
            // the ctx object, because that's what gets passed everywhere.
            if (glcanvas.gl != null) {
                return ctx.glcanvas = glcanvas;
            } else {
                return logging_1.logger.warn('WebGL is not supported, falling back to 2D canvas.');
            }
        };
        PlotCanvasView.prototype.prepare_webgl = function (ratio, frame_box) {
            var canvas, ctx, gl;
            // Prepare WebGL for a drawing pass
            ctx = this.canvas_view.ctx;
            canvas = this.canvas_view.get_canvas_element();
            if (ctx.glcanvas) {
                // Sync canvas size
                ctx.glcanvas.width = canvas.width;
                ctx.glcanvas.height = canvas.height;
                // Prepare GL for drawing
                gl = ctx.glcanvas.gl;
                gl.viewport(0, 0, ctx.glcanvas.width, ctx.glcanvas.height);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);
                // Clipping
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(ratio * frame_box[0], ratio * frame_box[1], ratio * frame_box[2], ratio * frame_box[3]);
                // Setup blending
                gl.enable(gl.BLEND);
                return gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE);    // premultipliedAlpha == true
            }
        };
        //gl.blendFuncSeparate(gl.ONE_MINUS_DST_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE)  # Without premultipliedAlpha == false
        PlotCanvasView.prototype.blit_webgl = function (ratio) {
            var ctx;
            // This should be called when the ctx has no state except the HIDPI transform
            ctx = this.canvas_view.ctx;
            if (ctx.glcanvas) {
                // Blit gl canvas into the 2D canvas. To do 1-on-1 blitting, we need
                // to remove the hidpi transform, then blit, then restore.
                // ctx.globalCompositeOperation = "source-over"  -> OK; is the default
                logging_1.logger.debug('drawing with WebGL');
                ctx.restore();
                ctx.drawImage(ctx.glcanvas, 0, 0);
                // Set back hidpi transform
                ctx.save();
                ctx.scale(ratio, ratio);
                return ctx.translate(0.5, 0.5);
            }
        };
        PlotCanvasView.prototype.update_dataranges = function () {
            var bds, bounds, bounds_to_use, calculate_log_bounds, follow_enabled, frame, has_bounds, height, j, k, l, len, len1, len2, len3, len4, log_bds, log_bounds, m, n, o, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, v, width, xcenter, xr, ycenter, yr;
            // Update any DataRange1ds here
            frame = this.model.frame;
            bounds = {};
            log_bounds = {};
            calculate_log_bounds = false;
            ref = object_1.values(frame.x_ranges).concat(object_1.values(frame.y_ranges));
            for (j = 0, len = ref.length; j < len; j++) {
                r = ref[j];
                if (r instanceof data_range1d_1.DataRange1d) {
                    if (r.scale_hint === 'log') {
                        calculate_log_bounds = true;
                    }
                }
            }
            ref1 = this.renderer_views;
            for (k in ref1) {
                v = ref1[k];
                bds = (ref2 = v.glyph) != null ? typeof ref2.bounds === 'function' ? ref2.bounds() : void 0 : void 0;
                if (bds != null) {
                    bounds[k] = bds;
                }
                if (calculate_log_bounds) {
                    log_bds = (ref3 = v.glyph) != null ? typeof ref3.log_bounds === 'function' ? ref3.log_bounds() : void 0 : void 0;
                    if (log_bds != null) {
                        log_bounds[k] = log_bds;
                    }
                }
            }
            follow_enabled = false;
            has_bounds = false;
            if (this.model.plot.match_aspect !== false && this.frame._width.value !== 0 && this.frame._height.value !== 0) {
                r = 1 / this.model.plot.aspect_scale * (this.frame._width.value / this.frame._height.value);
                for (k in bounds) {
                    v = bounds[k];
                    if (isFinite(v.maxX) && isFinite(v.minX) && isFinite(v.maxY) && isFinite(v.minY)) {
                        width = v.maxX - v.minX;
                        if (width <= 0) {
                            width = 1;
                        }
                        height = v.maxY - v.minY;
                        if (height <= 0) {
                            height = 1;
                        }
                        xcenter = 0.5 * (v.maxX + v.minX);
                        ycenter = 0.5 * (v.maxY + v.minY);
                        if (width < r * height) {
                            width = r * height;
                        } else {
                            height = width / r;
                        }
                        bounds[k].maxX = xcenter + 0.5 * width;
                        bounds[k].minX = xcenter - 0.5 * width;
                        bounds[k].maxY = ycenter + 0.5 * height;
                        bounds[k].minY = ycenter - 0.5 * height;
                    }
                }
            }
            ref4 = object_1.values(frame.x_ranges);
            for (l = 0, len1 = ref4.length; l < len1; l++) {
                xr = ref4[l];
                if (xr instanceof data_range1d_1.DataRange1d) {
                    bounds_to_use = xr.scale_hint === 'log' ? log_bounds : bounds;
                    xr.update(bounds_to_use, 0, this.model.id);
                    if (xr.follow) {
                        follow_enabled = true;
                    }
                }
                if (xr.bounds != null) {
                    has_bounds = true;
                }
            }
            ref5 = object_1.values(frame.y_ranges);
            for (m = 0, len2 = ref5.length; m < len2; m++) {
                yr = ref5[m];
                if (yr instanceof data_range1d_1.DataRange1d) {
                    bounds_to_use = yr.scale_hint === 'log' ? log_bounds : bounds;
                    yr.update(bounds_to_use, 1, this.model.id);
                    if (yr.follow) {
                        follow_enabled = true;
                    }
                }
                if (yr.bounds != null) {
                    has_bounds = true;
                }
            }
            if (follow_enabled && has_bounds) {
                logging_1.logger.warn('Follow enabled so bounds are unset.');
                ref6 = object_1.values(frame.x_ranges);
                for (n = 0, len3 = ref6.length; n < len3; n++) {
                    xr = ref6[n];
                    xr.bounds = null;
                }
                ref7 = object_1.values(frame.y_ranges);
                for (o = 0, len4 = ref7.length; o < len4; o++) {
                    yr = ref7[o];
                    yr.bounds = null;
                }
            }
            return this.range_update_timestamp = Date.now();
        };
        PlotCanvasView.prototype.map_to_screen = function (x, y, x_name, y_name) {
            if (x_name === void 0) {
                x_name = 'default';
            }
            if (y_name === void 0) {
                y_name = 'default';
            }
            return this.frame.map_to_screen(x, y, x_name, y_name);
        };
        PlotCanvasView.prototype.push_state = function (type, info) {
            var prev_info, ref;
            prev_info = ((ref = this.state.history[this.state.index]) != null ? ref.info : void 0) || {};
            info = object_1.extend({}, this._initial_state_info, prev_info, info);
            this.state.history.slice(0, this.state.index + 1);
            this.state.history.push({
                type: type,
                info: info
            });
            this.state.index = this.state.history.length - 1;
            return this.state_changed.emit();
        };
        PlotCanvasView.prototype.clear_state = function () {
            this.state = {
                history: [],
                index: -1
            };
            return this.state_changed.emit();
        };
        PlotCanvasView.prototype.can_undo = function () {
            return this.state.index >= 0;
        };
        PlotCanvasView.prototype.can_redo = function () {
            return this.state.index < this.state.history.length - 1;
        };
        PlotCanvasView.prototype.undo = function () {
            if (this.can_undo()) {
                this.state.index -= 1;
                this._do_state_change(this.state.index);
                return this.state_changed.emit();
            }
        };
        PlotCanvasView.prototype.redo = function () {
            if (this.can_redo()) {
                this.state.index += 1;
                this._do_state_change(this.state.index);
                return this.state_changed.emit();
            }
        };
        PlotCanvasView.prototype._do_state_change = function (index) {
            var info, ref;
            info = ((ref = this.state.history[index]) != null ? ref.info : void 0) || this._initial_state_info;
            if (info.range != null) {
                this.update_range(info.range);
            }
            if (info.selection != null) {
                return this.update_selection(info.selection);
            }
        };
        PlotCanvasView.prototype.get_selection = function () {
            var j, len, ref, renderer, selected, selection;
            selection = [];
            ref = this.model.plot.renderers;
            for (j = 0, len = ref.length; j < len; j++) {
                renderer = ref[j];
                if (renderer instanceof glyph_renderer_1.GlyphRenderer) {
                    selected = renderer.data_source.selected;
                    selection[renderer.id] = selected;
                }
            }
            return selection;
        };
        PlotCanvasView.prototype.update_selection = function (selection) {
            var ds, j, len, ref, ref1, renderer, results;
            ref = this.model.plot.renderers;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                renderer = ref[j];
                if (!(renderer instanceof glyph_renderer_1.GlyphRenderer)) {
                    continue;
                }
                ds = renderer.data_source;
                if (selection != null) {
                    if (ref1 = renderer.id, indexOf.call(selection, ref1) >= 0) {
                        results.push(ds.selected = selection[renderer.id]);
                    } else {
                        results.push(void 0);
                    }
                } else {
                    results.push(ds.selection_manager.clear());
                }
            }
            return results;
        };
        PlotCanvasView.prototype.reset_selection = function () {
            return this.update_selection(null);
        };
        PlotCanvasView.prototype._update_ranges_together = function (range_info_iter) {
            var j, l, len, len1, range_info, results, rng, weight;
            // Get weight needed to scale the diff of the range to honor interval limits
            weight = 1;
            for (j = 0, len = range_info_iter.length; j < len; j++) {
                _a = range_info_iter[j], rng = _a[0], range_info = _a[1];
                weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));
            }
            // Apply shared weight to all ranges
            if (weight < 1) {
                results = [];
                for (l = 0, len1 = range_info_iter.length; l < len1; l++) {
                    _b = range_info_iter[l], rng = _b[0], range_info = _b[1];
                    range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;
                    results.push(range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end);
                }
                return results;
            }
            var _a, _b;
        };
        PlotCanvasView.prototype._update_ranges_individually = function (range_info_iter, is_panning, is_scrolling) {
            var hit_bound, is_reversed, j, l, len, len1, max, min, new_interval, range_info, results, rng, weight;
            hit_bound = false;
            for (j = 0, len = range_info_iter.length; j < len; j++) {
                _a = range_info_iter[j], rng = _a[0], range_info = _a[1];
                // Is this a reversed range?
                is_reversed = rng.start > rng.end;
                // Limit range interval first. Note that for scroll events,
                // the interval has already been limited for all ranges simultaneously
                if (!is_scrolling) {
                    weight = this._get_weight_to_constrain_interval(rng, range_info);
                    if (weight < 1) {
                        range_info['start'] = weight * range_info['start'] + (1 - weight) * rng.start;
                        range_info['end'] = weight * range_info['end'] + (1 - weight) * rng.end;
                    }
                }
                // Prevent range from going outside limits
                // Also ensure that range keeps the same delta when panning/scrolling
                if (rng.bounds != null) {
                    min = rng.bounds[0];
                    max = rng.bounds[1];
                    new_interval = Math.abs(range_info['end'] - range_info['start']);
                    if (is_reversed) {
                        if (min != null) {
                            if (min >= range_info['end']) {
                                hit_bound = true;
                                range_info['end'] = min;
                                if (is_panning != null || is_scrolling != null) {
                                    range_info['start'] = min + new_interval;
                                }
                            }
                        }
                        if (max != null) {
                            if (max <= range_info['start']) {
                                hit_bound = true;
                                range_info['start'] = max;
                                if (is_panning != null || is_scrolling != null) {
                                    range_info['end'] = max - new_interval;
                                }
                            }
                        }
                    } else {
                        if (min != null) {
                            if (min >= range_info['start']) {
                                hit_bound = true;
                                range_info['start'] = min;
                                if (is_panning != null || is_scrolling != null) {
                                    range_info['end'] = min + new_interval;
                                }
                            }
                        }
                        if (max != null) {
                            if (max <= range_info['end']) {
                                hit_bound = true;
                                range_info['end'] = max;
                                if (is_panning != null || is_scrolling != null) {
                                    range_info['start'] = max - new_interval;
                                }
                            }
                        }
                    }
                }
            }
            // Cancel the event when hitting a bound while scrolling. This ensures that
            // the scroll-zoom tool maintains its focus position. Disabling the next
            // two lines would result in a more "gliding" behavior, allowing one to
            // zoom out more smoothly, at the cost of losing the focus position.
            if (is_scrolling && hit_bound) {
                return;
            }
            results = [];
            for (l = 0, len1 = range_info_iter.length; l < len1; l++) {
                _b = range_info_iter[l], rng = _b[0], range_info = _b[1];
                rng.have_updated_interactively = true;
                if (rng.start !== range_info['start'] || rng.end !== range_info['end']) {
                    results.push(rng.setv(range_info));
                } else {
                    results.push(void 0);
                }
            }
            return results;
            var _a, _b;
        };
        PlotCanvasView.prototype._get_weight_to_constrain_interval = function (rng, range_info) {
            var max, max_interval, max_interval2, min, min_interval, new_interval, old_interval, weight;
            // Get the weight by which a range-update can be applied
            // to still honor the interval limits (including the implicit
            // max interval imposed by the bounds)
            min_interval = rng.min_interval;
            max_interval = rng.max_interval;
            weight = 1;
            // Express bounds as a max_interval. By doing this, the application of
            // bounds and interval limits can be applied independent from each-other.
            if (rng.bounds != null) {
                _a = rng.bounds, min = _a[0], max = _a[1];
                if (min != null && max != null) {
                    max_interval2 = Math.abs(max - min);
                    max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;
                }
            }
            if (min_interval != null || max_interval != null) {
                old_interval = Math.abs(rng.end - rng.start);
                new_interval = Math.abs(range_info['end'] - range_info['start']);
                if (min_interval > 0 && new_interval < min_interval) {
                    weight = (old_interval - min_interval) / (old_interval - new_interval);
                }
                if (max_interval > 0 && new_interval > max_interval) {
                    weight = (max_interval - old_interval) / (new_interval - old_interval);
                }
                weight = Math.max(0, Math.min(1, weight));
            }
            return weight;
            var _a;
        };
        PlotCanvasView.prototype.update_range = function (range_info, is_panning, is_scrolling) {
            var name, range_info_iter, ref, ref1, ref2, ref3, rng;
            this.pause();
            if (range_info == null) {
                ref = this.frame.x_ranges;
                for (name in ref) {
                    rng = ref[name];
                    rng.reset();
                }
                ref1 = this.frame.y_ranges;
                for (name in ref1) {
                    rng = ref1[name];
                    rng.reset();
                }
                this.update_dataranges();
            } else {
                range_info_iter = [];
                ref2 = this.frame.x_ranges;
                for (name in ref2) {
                    rng = ref2[name];
                    range_info_iter.push([
                        rng,
                        range_info.xrs[name]
                    ]);
                }
                ref3 = this.frame.y_ranges;
                for (name in ref3) {
                    rng = ref3[name];
                    range_info_iter.push([
                        rng,
                        range_info.yrs[name]
                    ]);
                }
                if (is_scrolling) {
                    this._update_ranges_together(range_info_iter);    // apply interval bounds while keeping aspect
                }
                this._update_ranges_individually(range_info_iter, is_panning, is_scrolling);
            }
            return this.unpause();
        };
        PlotCanvasView.prototype.reset_range = function () {
            return this.update_range(null);
        };
        PlotCanvasView.prototype.build_levels = function () {
            var id_, j, l, len, len1, model, new_renderer_views, old_renderers, renderer_models, renderers_to_remove, view;
            renderer_models = this.model.plot.all_renderers;
            // should only bind events on NEW views
            old_renderers = Object.keys(this.renderer_views);
            new_renderer_views = build_views_1.build_views(this.renderer_views, renderer_models, this.view_options());
            renderers_to_remove = array_1.difference(old_renderers, function () {
                var j, len, results;
                results = [];
                for (j = 0, len = renderer_models.length; j < len; j++) {
                    model = renderer_models[j];
                    results.push(model.id);
                }
                return results;
            }());
            for (j = 0, len = renderers_to_remove.length; j < len; j++) {
                id_ = renderers_to_remove[j];
                delete this.levels.glyph[id_];
            }
            for (l = 0, len1 = new_renderer_views.length; l < len1; l++) {
                view = new_renderer_views[l];
                this.levels[view.model.level][view.model.id] = view;
            }
            return this;
        };
        PlotCanvasView.prototype.get_renderer_views = function () {
            var j, len, r, ref, results;
            ref = this.model.plot.renderers;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                r = ref[j];
                results.push(this.levels[r.level][r.id]);
            }
            return results;
        };
        PlotCanvasView.prototype.build_tools = function () {
            var j, len, new_tool_views, results, tool_models, tool_view;
            tool_models = this.model.plot.toolbar.tools;
            new_tool_views = build_views_1.build_views(this.tool_views, tool_models, this.view_options());
            results = [];
            for (j = 0, len = new_tool_views.length; j < len; j++) {
                tool_view = new_tool_views[j];
                results.push(this.ui_event_bus.register_tool(tool_view));
            }
            return results;
        };
        PlotCanvasView.prototype.connect_signals = function () {
            var _this = this;
            var name, ref, ref1, rng;
            _super.prototype.connect_signals.call(this);
            this.connect(this.force_paint, function () {
                return _this.repaint();
            });
            ref = this.model.frame.x_ranges;
            for (name in ref) {
                rng = ref[name];
                this.connect(rng.change, function () {
                    return this.request_render();
                });
            }
            ref1 = this.model.frame.y_ranges;
            for (name in ref1) {
                rng = ref1[name];
                this.connect(rng.change, function () {
                    return this.request_render();
                });
            }
            this.connect(this.model.plot.properties.renderers.change, function () {
                return _this.build_levels();
            });
            this.connect(this.model.plot.toolbar.properties.tools.change, function () {
                _this.build_levels();
                return _this.build_tools();
            });
            return this.connect(this.model.plot.change, function () {
                return this.request_render();
            });
        };
        PlotCanvasView.prototype.set_initial_range = function () {
            var good_vals, name, ref, ref1, rng, xrs, yrs;
            // check for good values for ranges before setting initial range
            good_vals = true;
            xrs = {};
            ref = this.frame.x_ranges;
            for (name in ref) {
                rng = ref[name];
                if (rng.start == null || rng.end == null || types_1.isStrictNaN(rng.start + rng.end)) {
                    good_vals = false;
                    break;
                }
                xrs[name] = {
                    start: rng.start,
                    end: rng.end
                };
            }
            if (good_vals) {
                yrs = {};
                ref1 = this.frame.y_ranges;
                for (name in ref1) {
                    rng = ref1[name];
                    if (rng.start == null || rng.end == null || types_1.isStrictNaN(rng.start + rng.end)) {
                        good_vals = false;
                        break;
                    }
                    yrs[name] = {
                        start: rng.start,
                        end: rng.end
                    };
                }
            }
            if (good_vals) {
                this._initial_state_info.range = this.initial_range_info = {
                    xrs: xrs,
                    yrs: yrs
                };
                return logging_1.logger.debug('initial ranges set');
            } else {
                return logging_1.logger.warn('could not set initial ranges');
            }
        };
        PlotCanvasView.prototype.update_constraints = function () {
            var _, ref, view;
            this.solver.suggest_value(this.frame._width, this.canvas._width.value);
            this.solver.suggest_value(this.frame._height, this.canvas._height.value);
            ref = this.renderer_views;
            for (_ in ref) {
                view = ref[_];
                if (view.model.panel != null) {
                    side_panel_1.update_panel_constraints(view);
                }
            }
            return this.solver.update_variables();
        };
        // XXX: bacause PlotCanvas is NOT a LayoutDOM
        PlotCanvasView.prototype._layout = function (final) {
            if (final === void 0) {
                final = false;
            }
            this.render();
            if (final) {
                this.model.plot.setv({
                    inner_width: Math.round(this.frame._width.value),
                    inner_height: Math.round(this.frame._height.value),
                    layout_width: Math.round(this.canvas._width.value),
                    layout_height: Math.round(this.canvas._height.value)
                }, { no_change: true });
                // XXX: can't be @request_paint(), because it would trigger back-and-forth
                // layout recomputing feedback loop between plots. Plots are also much more
                // responsive this way, especially in interactive mode.
                return this.paint();
            }
        };
        PlotCanvasView.prototype.has_finished = function () {
            var _, ref, renderer_views, view;
            if (!_super.prototype.has_finished.call(this)) {
                return false;
            }
            ref = this.levels;
            for (_ in ref) {
                renderer_views = ref[_];
                for (_ in renderer_views) {
                    view = renderer_views[_];
                    if (!view.has_finished()) {
                        return false;
                    }
                }
            }
            return true;
        };
        PlotCanvasView.prototype.render = function () {
            var height, width;
            // Set the plot and canvas to the current model's size
            // This gets called upon solver resize events
            width = this.model._width.value;
            height = this.model._height.value;
            this.canvas_view.set_dims([
                width,
                height
            ]);
            this.update_constraints();
            if (this.model.plot.match_aspect !== false && this.frame._width.value !== 0 && this.frame._height.value !== 0) {
                this.update_dataranges();
            }
            // This allows the plot canvas to be positioned around the toolbar
            this.el.style.position = 'absolute';
            this.el.style.left = this.model._dom_left.value + 'px';
            this.el.style.top = this.model._dom_top.value + 'px';
            this.el.style.width = this.model._width.value + 'px';
            return this.el.style.height = this.model._height.value + 'px';
        };
        PlotCanvasView.prototype._needs_layout = function () {
            var _, ref, view;
            ref = this.renderer_views;
            for (_ in ref) {
                view = ref[_];
                if (view.model.panel != null) {
                    if (side_panel_1._view_sizes.get(view) !== view.get_size()) {
                        return true;
                    }
                }
            }
            return false;
        };
        PlotCanvasView.prototype.repaint = function () {
            if (this._needs_layout()) {
                return this.parent.partial_layout();
            } else {
                return this.paint();
            }
        };
        PlotCanvasView.prototype.paint = function () {
            var _this = this;
            var ctx, frame_box, h, interactive_duration, k, lod_timeout, ratio, ref, v, w, x0, y0;
            if (this.is_paused) {
                return;
            }
            logging_1.logger.trace('PlotCanvas.render() for ' + this.model.id);
            // Prepare the canvas size, taking HIDPI into account. Note that this may cause a resize
            // of the canvas, which means that any previous calls to ctx.save() will be undone.
            this.canvas_view.prepare_canvas();
            if (this.model.document != null) {
                interactive_duration = this.model.document.interactive_duration();
                if (interactive_duration >= 0 && interactive_duration < this.model.plot.lod_interval) {
                    lod_timeout = this.model.plot.lod_timeout;
                    setTimeout(function () {
                        if (_this.model.document.interactive_duration() > lod_timeout) {
                            _this.model.document.interactive_stop(_this.model.plot);
                        }
                        return _this.request_render();
                    }, lod_timeout);
                } else {
                    this.model.document.interactive_stop(this.model.plot);
                }
            }
            ref = this.renderer_views;
            for (k in ref) {
                v = ref[k];
                if (this.range_update_timestamp == null || v.set_data_timestamp > this.range_update_timestamp) {
                    this.update_dataranges();
                    break;
                }
            }
            // TODO (bev) OK this sucks, but the event from the solver update doesn't
            // reach the frame in time (sometimes) so force an update here for now
            // (mp) not only that, but models don't know about solver anymore, so
            // frame can't update its scales.
            this.model.frame._update_scales();
            ctx = this.canvas_view.ctx;
            ctx.pixel_ratio = ratio = this.canvas.pixel_ratio;
            // Also store on cts for WebGL
            // Set hidpi-transform
            ctx.save();
            // Save default state, do *after* getting ratio, cause setting canvas.width resets transforms
            ctx.scale(ratio, ratio);
            ctx.translate(0.5, 0.5);
            frame_box = [
                this.frame._left.value,
                this.frame._top.value,
                this.frame._width.value,
                this.frame._height.value
            ];
            this._map_hook(ctx, frame_box);
            this._paint_empty(ctx, frame_box);
            this.prepare_webgl(ratio, frame_box);
            ctx.save();
            if (this.visuals.outline_line.doit) {
                this.visuals.outline_line.set_value(ctx);
                x0 = frame_box[0], y0 = frame_box[1], w = frame_box[2], h = frame_box[3];
                // XXX: shrink outline region by 1px to make right and bottom lines visible
                // if they are on the edge of the canvas.
                if (x0 + w === this.canvas._width.value) {
                    w -= 1;
                }
                if (y0 + h === this.canvas._height.value) {
                    h -= 1;
                }
                ctx.strokeRect(x0, y0, w, h);
            }
            ctx.restore();
            this._paint_levels(ctx, [
                'image',
                'underlay',
                'glyph'
            ], frame_box);
            this.blit_webgl(ratio);
            this._paint_levels(ctx, ['annotation'], frame_box);
            this._paint_levels(ctx, ['overlay']);
            if (this.initial_range_info == null) {
                this.set_initial_range();
            }
            ctx.restore();
            // Restore to default state
            if (!this._has_finished) {
                this._has_finished = true;
                return this.notify_finished();
            }
        };
        PlotCanvasView.prototype._paint_levels = function (ctx, levels, clip_region) {
            var i, indices, j, l, len, len1, len2, level, m, ref, renderer, renderer_view, renderer_views, sortKey;
            ctx.save();
            if (clip_region != null && this.model.plot.output_backend === 'canvas') {
                ctx.beginPath();
                ctx.rect.apply(ctx, clip_region);
                ctx.clip();
            }
            indices = {};
            ref = this.model.plot.renderers;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
                renderer = ref[i];
                indices[renderer.id] = i;
            }
            sortKey = function (renderer_view) {
                return indices[renderer_view.model.id];
            };
            for (l = 0, len1 = levels.length; l < len1; l++) {
                level = levels[l];
                renderer_views = array_1.sortBy(object_1.values(this.levels[level]), sortKey);
                for (m = 0, len2 = renderer_views.length; m < len2; m++) {
                    renderer_view = renderer_views[m];
                    renderer_view.render();
                }
            }
            return ctx.restore();
        };
        PlotCanvasView.prototype._map_hook = function (ctx, frame_box) {
        };
        PlotCanvasView.prototype._paint_empty = function (ctx, frame_box) {
            ctx.clearRect(0, 0, this.canvas_view.model._width.value, this.canvas_view.model._height.value);
            if (this.visuals.border_fill.doit) {
                this.visuals.border_fill.set_value(ctx);
                ctx.fillRect(0, 0, this.canvas_view.model._width.value, this.canvas_view.model._height.value);
                ctx.clearRect.apply(ctx, frame_box);
            }
            if (this.visuals.background_fill.doit) {
                this.visuals.background_fill.set_value(ctx);
                return ctx.fillRect.apply(ctx, frame_box);
            }
        };
        PlotCanvasView.prototype.save = function (name) {
            var blob, canvas, downloadLink, link, ref, svg, svgblob;
            if ((ref = this.model.plot.output_backend) === 'canvas' || ref === 'webgl') {
                canvas = this.canvas_view.get_canvas_element();
                if (canvas.msToBlob != null) {
                    blob = canvas.msToBlob();
                    return window.navigator.msSaveBlob(blob, name);
                } else {
                    link = document.createElement('a');
                    link.href = canvas.toDataURL('image/png');
                    link.download = name + '.png';
                    link.target = '_blank';
                    return link.dispatchEvent(new MouseEvent('click'));
                }
            } else if (this.model.plot.output_backend === 'svg') {
                svg = this.canvas_view.ctx.getSerializedSvg(true);
                svgblob = new Blob([svg], { type: 'text/plain' });
                downloadLink = document.createElement('a');
                downloadLink.download = name + '.svg';
                downloadLink.innerHTML = 'Download svg';
                downloadLink.href = window.URL.createObjectURL(svgblob);
                downloadLink.onclick = function (event) {
                    return document.body.removeChild(event.target);
                };
                downloadLink.style.display = 'none';
                document.body.appendChild(downloadLink);
                return downloadLink.click();
            }
        };
        return PlotCanvasView;
    }(dom_view_1.DOMView);
    exports.PlotCanvasView = PlotCanvasView;
    ;
    PlotCanvasView.prototype.className = 'bk-plot-wrapper';
    PlotCanvasView.prototype.state = {
        history: [],
        index: -1
    };
    PlotCanvasView.getters({
        canvas_overlays: function () {
            return this.canvas_view.overlays_el;
        },
        canvas_events: function () {
            return this.canvas_view.events_el;
        },
        is_paused: function () {
            return this._is_paused != null && this._is_paused !== 0;
        }
    });
    AbovePanel = function () {
        var AbovePanel = function (_super) {
            tslib_1.__extends(AbovePanel, _super);
            function AbovePanel() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return AbovePanel;
        }(layout_canvas_1.LayoutCanvas);
        ;
        AbovePanel.prototype.type = 'AbovePanel';
        return AbovePanel;
    }();
    BelowPanel = function () {
        var BelowPanel = function (_super) {
            tslib_1.__extends(BelowPanel, _super);
            function BelowPanel() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return BelowPanel;
        }(layout_canvas_1.LayoutCanvas);
        ;
        BelowPanel.prototype.type = 'BelowPanel';
        return BelowPanel;
    }();
    LeftPanel = function () {
        var LeftPanel = function (_super) {
            tslib_1.__extends(LeftPanel, _super);
            function LeftPanel() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return LeftPanel;
        }(layout_canvas_1.LayoutCanvas);
        ;
        LeftPanel.prototype.type = 'LeftPanel';
        return LeftPanel;
    }();
    RightPanel = function () {
        var RightPanel = function (_super) {
            tslib_1.__extends(RightPanel, _super);
            function RightPanel() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return RightPanel;
        }(layout_canvas_1.LayoutCanvas);
        ;
        RightPanel.prototype.type = 'RightPanel';
        return RightPanel;
    }();
    var PlotCanvas = function (_super) {
        tslib_1.__extends(PlotCanvas, _super);
        function PlotCanvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PlotCanvas.prototype.initialize = function (attrs, options) {
            var ref;
            _super.prototype.initialize.call(this, attrs, options);
            this.canvas = new canvas_1.Canvas({
                map: (ref = this.use_map) != null ? ref : false,
                use_hidpi: this.plot.hidpi,
                output_backend: this.plot.output_backend
            });
            this.frame = new cartesian_frame_1.CartesianFrame({
                x_range: this.plot.x_range,
                extra_x_ranges: this.plot.extra_x_ranges,
                x_scale: this.plot.x_scale,
                y_range: this.plot.y_range,
                extra_y_ranges: this.plot.extra_y_ranges,
                y_scale: this.plot.y_scale
            });
            this.above_panel = new AbovePanel();
            this.below_panel = new BelowPanel();
            this.left_panel = new LeftPanel();
            this.right_panel = new RightPanel();
            return logging_1.logger.debug('PlotCanvas initialized');
        };
        PlotCanvas.prototype._doc_attached = function () {
            this.canvas.attach_document(this.document);
            this.frame.attach_document(this.document);
            this.above_panel.attach_document(this.document);
            this.below_panel.attach_document(this.document);
            this.left_panel.attach_document(this.document);
            this.right_panel.attach_document(this.document);
            _super.prototype._doc_attached.call(this);
            return logging_1.logger.debug('PlotCanvas attached to document');
        };
        PlotCanvas.prototype.get_layoutable_children = function () {
            var children, collect_panels;
            children = [
                this.above_panel,
                this.below_panel,
                this.left_panel,
                this.right_panel,
                this.canvas,
                this.frame
            ];
            collect_panels = function (layout_renderers) {
                var j, len, r, results;
                results = [];
                for (j = 0, len = layout_renderers.length; j < len; j++) {
                    r = layout_renderers[j];
                    if (r.panel != null) {
                        results.push(children.push(r.panel));
                    } else {
                        results.push(void 0);
                    }
                }
                return results;
            };
            collect_panels(this.plot.above);
            collect_panels(this.plot.below);
            collect_panels(this.plot.left);
            collect_panels(this.plot.right);
            return children;
        };
        PlotCanvas.prototype.get_constraints = function () {
            return _super.prototype.get_constraints.call(this).concat(this._get_constant_constraints(), this._get_side_constraints());
        };
        PlotCanvas.prototype._get_constant_constraints = function () {
            // Set the origin. Everything else is positioned absolutely wrt canvas.
            return [
                solver_1.EQ(this.canvas._left, 0),
                solver_1.EQ(this.canvas._top, 0),
                solver_1.GE(this.above_panel._top, [
                    -1,
                    this.canvas._top
                ]),
                solver_1.EQ(this.above_panel._bottom, [
                    -1,
                    this.frame._top
                ]),
                solver_1.EQ(this.above_panel._left, [
                    -1,
                    this.left_panel._right
                ]),
                solver_1.EQ(this.above_panel._right, [
                    -1,
                    this.right_panel._left
                ]),
                solver_1.EQ(this.below_panel._top, [
                    -1,
                    this.frame._bottom
                ]),
                solver_1.LE(this.below_panel._bottom, [
                    -1,
                    this.canvas._bottom
                ]),
                solver_1.EQ(this.below_panel._left, [
                    -1,
                    this.left_panel._right
                ]),
                solver_1.EQ(this.below_panel._right, [
                    -1,
                    this.right_panel._left
                ]),
                solver_1.EQ(this.left_panel._top, [
                    -1,
                    this.above_panel._bottom
                ]),
                solver_1.EQ(this.left_panel._bottom, [
                    -1,
                    this.below_panel._top
                ]),
                solver_1.GE(this.left_panel._left, [
                    -1,
                    this.canvas._left
                ]),
                solver_1.EQ(this.left_panel._right, [
                    -1,
                    this.frame._left
                ]),
                solver_1.EQ(this.right_panel._top, [
                    -1,
                    this.above_panel._bottom
                ]),
                solver_1.EQ(this.right_panel._bottom, [
                    -1,
                    this.below_panel._top
                ]),
                solver_1.EQ(this.right_panel._left, [
                    -1,
                    this.frame._right
                ]),
                solver_1.LE(this.right_panel._right, [
                    -1,
                    this.canvas._right
                ]),
                solver_1.EQ(this._top, [
                    -1,
                    this.above_panel._bottom
                ]),
                solver_1.EQ(this._left, [
                    -1,
                    this.left_panel._right
                ]),
                solver_1.EQ(this._height, [
                    -1,
                    this._bottom
                ], [
                    -1,
                    this.canvas._bottom
                ], this.below_panel._top),
                solver_1.EQ(this._width, [
                    -1,
                    this._right
                ], [
                    -1,
                    this.canvas._right
                ], this.right_panel._left),
                solver_1.GE(this._top, -this.plot.min_border_top),
                solver_1.GE(this._left, -this.plot.min_border_left),
                solver_1.GE(this._height, [
                    -1,
                    this._bottom
                ], -this.plot.min_border_bottom),
                solver_1.GE(this._width, [
                    -1,
                    this._right
                ], -this.plot.min_border_right)
            ];
        };
        PlotCanvas.prototype._get_side_constraints = function () {
            var above, below, left, panels, right;
            panels = function (objs) {
                var j, len, obj, results;
                results = [];
                for (j = 0, len = objs.length; j < len; j++) {
                    obj = objs[j];
                    results.push(obj.panel);
                }
                return results;
            };
            above = alignments_1.vstack(this.above_panel, panels(this.plot.above));
            below = alignments_1.vstack(this.below_panel, array_1.reversed(panels(this.plot.below)));
            left = alignments_1.hstack(this.left_panel, panels(this.plot.left));
            right = alignments_1.hstack(this.right_panel, array_1.reversed(panels(this.plot.right)));
            return [].concat(above, below, left, right);
        };
        return PlotCanvas;
    }(layout_dom_1.LayoutDOM);
    exports.PlotCanvas = PlotCanvas;
    ;
    PlotCanvas.prototype.type = 'PlotCanvas';
    PlotCanvas.prototype.default_view = PlotCanvasView;
    PlotCanvas.override({
        // We should find a way to enforce this
        sizing_mode: 'stretch_both'
    });
    PlotCanvas.internal({
        plot: [p.Instance],
        toolbar: [p.Instance],
        canvas: [p.Instance],
        frame: [p.Instance]
    });    
},
/*models/ranges/data_range*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var range_1 = require(159    /* ./range */);
    var p = require(15    /* core/properties */);
    var DataRange = function (_super) {
        tslib_1.__extends(DataRange, _super);
        function DataRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DataRange;
    }(range_1.Range);
    exports.DataRange = DataRange;
    ;
    DataRange.prototype.type = 'DataRange';
    DataRange.define({
        names: [
            p.Array,
            []
        ],
        renderers: [
            p.Array,
            []
        ]
    });    
},
/*models/ranges/data_range1d*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var data_range_1 = require(155    /* ./data_range */);
    var glyph_renderer_1 = require(161    /* ../renderers/glyph_renderer */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var bbox = require(23    /* core/util/bbox */);
    var DataRange1d = function (_super) {
        tslib_1.__extends(DataRange1d, _super);
        function DataRange1d() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DataRange1d.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this.plot_bounds = {};
            this.have_updated_interactively = false;
            this._initial_start = this.start;
            this._initial_end = this.end;
            this._initial_range_padding = this.range_padding;
            this._initial_range_padding_units = this.range_padding_units;
            this._initial_follow = this.follow;
            this._initial_follow_interval = this.follow_interval;
            return this._initial_default_span = this.default_span;
        };
        DataRange1d.prototype.computed_renderers = function () {
            var all_renderers, i, j, len, len1, names, plot, r, ref, renderers, rs;
            // TODO (bev) check that renderers actually configured with this range
            names = this.names;
            renderers = this.renderers;
            if (renderers.length === 0) {
                ref = this.plots;
                for (i = 0, len = ref.length; i < len; i++) {
                    plot = ref[i];
                    all_renderers = plot.renderers;
                    rs = function () {
                        var j, len1, results;
                        results = [];
                        for (j = 0, len1 = all_renderers.length; j < len1; j++) {
                            r = all_renderers[j];
                            if (r instanceof glyph_renderer_1.GlyphRenderer) {
                                results.push(r);
                            }
                        }
                        return results;
                    }();
                    renderers = renderers.concat(rs);
                }
            }
            if (names.length > 0) {
                renderers = function () {
                    var j, len1, results;
                    results = [];
                    for (j = 0, len1 = renderers.length; j < len1; j++) {
                        r = renderers[j];
                        if (names.indexOf(r.name) >= 0) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
            }
            logging_1.logger.debug('computed ' + renderers.length + ' renderers for DataRange1d ' + this.id);
            for (j = 0, len1 = renderers.length; j < len1; j++) {
                r = renderers[j];
                logging_1.logger.trace(' - ' + r.type + ' ' + r.id);
            }
            return renderers;
        };
        DataRange1d.prototype._compute_plot_bounds = function (renderers, bounds) {
            var i, len, r, result;
            result = bbox.empty();
            for (i = 0, len = renderers.length; i < len; i++) {
                r = renderers[i];
                if (bounds[r.id] != null) {
                    result = bbox.union(result, bounds[r.id]);
                }
            }
            return result;
        };
        DataRange1d.prototype._compute_min_max = function (plot_bounds, dimension) {
            var k, max, min, overall, v;
            overall = bbox.empty();
            for (k in plot_bounds) {
                v = plot_bounds[k];
                overall = bbox.union(overall, v);
            }
            if (dimension === 0) {
                _a = [
                    overall.minX,
                    overall.maxX
                ], min = _a[0], max = _a[1];
            } else {
                _b = [
                    overall.minY,
                    overall.maxY
                ], min = _b[0], max = _b[1];
            }
            return [
                min,
                max
            ];
            var _a, _b;
        };
        DataRange1d.prototype._compute_range = function (min, max) {
            var center, end, follow_interval, follow_sign, log_max, log_min, range_padding, ref, span, start;
            range_padding = (ref = this.range_padding) != null ? ref : 0;
            if (this.scale_hint === 'log') {
                if (isNaN(min) || !isFinite(min) || min <= 0) {
                    if (isNaN(max) || !isFinite(max) || max <= 0) {
                        min = 0.1;
                    } else {
                        min = max / 100;
                    }
                    logging_1.logger.warn('could not determine minimum data value for log axis, DataRange1d using value ' + min);
                }
                if (isNaN(max) || !isFinite(max) || max <= 0) {
                    if (isNaN(min) || !isFinite(min) || min <= 0) {
                        max = 10;
                    } else {
                        max = min * 100;
                    }
                    logging_1.logger.warn('could not determine maximum data value for log axis, DataRange1d using value ' + max);
                }
                if (max === min) {
                    span = this.default_span + 0.001;
                    center = Math.log(min) / Math.log(10);
                } else {
                    if (this.range_padding_units === 'percent') {
                        log_min = Math.log(min) / Math.log(10);
                        log_max = Math.log(max) / Math.log(10);
                        span = (log_max - log_min) * (1 + range_padding);
                    } else {
                        log_min = Math.log(min - range_padding) / Math.log(10);
                        log_max = Math.log(max + range_padding) / Math.log(10);
                        span = log_max - log_min;
                    }
                    center = (log_min + log_max) / 2;
                }
                _a = [
                    Math.pow(10, center - span / 2),
                    Math.pow(10, center + span / 2)
                ], start = _a[0], end = _a[1];
            } else {
                if (max === min) {
                    span = this.default_span;
                } else {
                    if (this.range_padding_units === 'percent') {
                        span = (max - min) * (1 + range_padding);
                    } else {
                        span = max - min + 2 * range_padding;
                    }
                }
                center = (max + min) / 2;
                _b = [
                    center - span / 2,
                    center + span / 2
                ], start = _b[0], end = _b[1];
            }
            follow_sign = +1;
            if (this.flipped) {
                _c = [
                    end,
                    start
                ], start = _c[0], end = _c[1];
                follow_sign = -1;
            }
            follow_interval = this.follow_interval;
            if (follow_interval != null && Math.abs(start - end) > follow_interval) {
                if (this.follow === 'start') {
                    end = start + follow_sign * follow_interval;
                } else if (this.follow === 'end') {
                    start = end - follow_sign * follow_interval;
                }
            }
            return [
                start,
                end
            ];
            var _a, _b, _c;
        };
        DataRange1d.prototype.update = function (bounds, dimension, bounds_id) {
            var _end, _start, end, max, min, new_range, renderers, start;
            if (this.have_updated_interactively) {
                return;
            }
            renderers = this.computed_renderers();
            // update the raw data bounds for all renderers we care about
            this.plot_bounds[bounds_id] = this._compute_plot_bounds(renderers, bounds);
            // compute the min/mix for our specified dimension
            _a = this._compute_min_max(this.plot_bounds, dimension), min = _a[0], max = _a[1];
            // derive start, end from bounds and data range config
            _b = this._compute_range(min, max), start = _b[0], end = _b[1];
            if (this._initial_start != null) {
                if (this.scale_hint === 'log') {
                    if (this._initial_start > 0) {
                        start = this._initial_start;
                    }
                } else {
                    start = this._initial_start;
                }
            }
            if (this._initial_end != null) {
                if (this.scale_hint === 'log') {
                    if (this._initial_end > 0) {
                        end = this._initial_end;
                    }
                } else {
                    end = this._initial_end;
                }
            }
            // only trigger updates when there are changes
            _c = [
                this.start,
                this.end
            ], _start = _c[0], _end = _c[1];
            if (start !== _start || end !== _end) {
                new_range = {};
                if (start !== _start) {
                    new_range.start = start;
                }
                if (end !== _end) {
                    new_range.end = end;
                }
                this.setv(new_range);
            }
            if (this.bounds === 'auto') {
                this.setv({
                    bounds: [
                        start,
                        end
                    ]
                }, { silent: true });
            }
            return this.change.emit();
            var _a, _b, _c;
        };
        DataRange1d.prototype.reset = function () {
            this.have_updated_interactively = false;
            // change events silenced as PlotCanvasView.update_dataranges triggers property callbacks
            this.setv({
                range_padding: this._initial_range_padding,
                range_padding_units: this._initial_range_padding_units,
                follow: this._initial_follow,
                follow_interval: this._initial_follow_interval,
                default_span: this._initial_default_span
            }, { silent: true });
            return this.change.emit();
        };
        return DataRange1d;
    }(data_range_1.DataRange);
    exports.DataRange1d = DataRange1d;
    ;
    DataRange1d.prototype.type = 'DataRange1d';
    DataRange1d.define({
        start: [p.Number],
        end: [p.Number],
        range_padding: [
            p.Number,
            0.1
        ],
        range_padding_units: [
            p.PaddingUnits,
            'percent'
        ],
        flipped: [
            p.Bool,
            false
        ],
        follow: [p.StartEnd],
        follow_interval: [p.Number],
        default_span: [
            p.Number,
            2
        ],
        bounds: [p.Any],
        min_interval: [p.Any],
        max_interval: [p.Any]
    });
    DataRange1d.internal({
        scale_hint: [
            p.String,
            'auto'
        ]
    });
    DataRange1d.getters({
        min: function () {
            return Math.min(this.start, this.end);
        },
        max: function () {
            return Math.max(this.start, this.end);
        }
    });    
},
/*models/ranges/factor_range*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var range_1 = require(159    /* ./range */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    // exported for testing
    exports.map_one_level = function (factors, padding, offset) {
        if (offset === void 0) {
            offset = 0;
        }
        var f, i, j, len, mapping;
        mapping = {};
        for (i = j = 0, len = factors.length; j < len; i = ++j) {
            f = factors[i];
            if (f in mapping) {
                throw new Error('duplicate factor or subfactor ' + f);
            }
            mapping[f] = { value: 0.5 + i * (1 + padding) + offset };
        }
        return [
            mapping,
            (factors.length - 1) * padding
        ];
    };
    // exported for testing
    exports.map_two_levels = function (factors, outer_pad, factor_pad, offset) {
        if (offset === void 0) {
            offset = 0;
        }
        var f0, f1, j, k, len, len1, mapping, n, submap, suboffset, subpad, subtot, tops, tops_order, total_subpad;
        mapping = {};
        tops = {};
        tops_order = [];
        for (j = 0, len = factors.length; j < len; j++) {
            _a = factors[j], f0 = _a[0], f1 = _a[1];
            if (!(f0 in tops)) {
                tops[f0] = [];
                tops_order.push(f0);
            }
            tops[f0].push(f1);
        }
        suboffset = offset;
        total_subpad = 0;
        for (k = 0, len1 = tops_order.length; k < len1; k++) {
            f0 = tops_order[k];
            n = tops[f0].length;
            _b = exports.map_one_level(tops[f0], factor_pad, suboffset), submap = _b[0], subpad = _b[1];
            total_subpad += subpad;
            subtot = array_1.sum(function () {
                var l, len2, ref, results;
                ref = tops[f0];
                results = [];
                for (l = 0, len2 = ref.length; l < len2; l++) {
                    f1 = ref[l];
                    results.push(submap[f1].value);
                }
                return results;
            }());
            mapping[f0] = {
                value: subtot / n,
                mapping: submap
            };
            suboffset += n + outer_pad + subpad;
        }
        return [
            mapping,
            tops_order,
            (tops_order.length - 1) * outer_pad + total_subpad
        ];
        var _a, _b;
    };
    // exported for testing
    exports.map_three_levels = function (factors, outer_pad, inner_pad, factor_pad, offset) {
        if (offset === void 0) {
            offset = 0;
        }
        var f0, f1, f2, j, k, l, len, len1, len2, mapping, mids_order, n, submap, submids_order, suboffset, subpad, subtot, tops, tops_order, total_subpad;
        mapping = {};
        tops = {};
        tops_order = [];
        for (j = 0, len = factors.length; j < len; j++) {
            _a = factors[j], f0 = _a[0], f1 = _a[1], f2 = _a[2];
            if (!(f0 in tops)) {
                tops[f0] = [];
                tops_order.push(f0);
            }
            tops[f0].push([
                f1,
                f2
            ]);
        }
        mids_order = [];
        suboffset = offset;
        total_subpad = 0;
        for (k = 0, len1 = tops_order.length; k < len1; k++) {
            f0 = tops_order[k];
            n = tops[f0].length;
            _b = exports.map_two_levels(tops[f0], inner_pad, factor_pad, suboffset), submap = _b[0], submids_order = _b[1], subpad = _b[2];
            for (l = 0, len2 = submids_order.length; l < len2; l++) {
                f1 = submids_order[l];
                mids_order.push([
                    f0,
                    f1
                ]);
            }
            total_subpad += subpad;
            subtot = array_1.sum(function () {
                var len3, m, ref, results;
                ref = tops[f0];
                results = [];
                for (m = 0, len3 = ref.length; m < len3; m++) {
                    _a = ref[m], f1 = _a[0], f2 = _a[1];
                    results.push(submap[f1].value);
                }
                return results;
                var _a;
            }());
            mapping[f0] = {
                value: subtot / n,
                mapping: submap
            };
            suboffset += n + outer_pad + subpad;
        }
        return [
            mapping,
            tops_order,
            mids_order,
            (tops_order.length - 1) * outer_pad + total_subpad
        ];
        var _a, _b;
    };
    var FactorRange = function (_super) {
        tslib_1.__extends(FactorRange, _super);
        function FactorRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FactorRange.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._init();
            this.connect(this.properties.factors.change, function () {
                return this._init();
            });
            this.connect(this.properties.factor_padding.change, function () {
                return this._init();
            });
            this.connect(this.properties.group_padding.change, function () {
                return this._init();
            });
            this.connect(this.properties.subgroup_padding.change, function () {
                return this._init();
            });
            this.connect(this.properties.range_padding.change, function () {
                return this._init();
            });
            return this.connect(this.properties.range_padding_units.change, function () {
                return this._init();
            });
        };
        FactorRange.prototype.reset = function () {
            this._init();
            return this.change.emit();
        };
        // convert a string factor into a synthetic coordinate
        FactorRange.prototype.synthetic = function (x) {
            var offset;
            if (types_1.isNumber(x)) {
                return x;
            }
            if (types_1.isString(x)) {
                return this._lookup([x]);
            }
            offset = 0;
            if (types_1.isNumber(x[x.length - 1])) {
                offset = x[x.length - 1];
                x = x.slice(0, -1);
            }
            return this._lookup(x) + offset;
        };
        // convert an array of string factors into synthetic coordinates
        FactorRange.prototype.v_synthetic = function (xs) {
            var result, x;
            return result = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = xs.length; j < len; j++) {
                    x = xs[j];
                    results.push(this.synthetic(x));
                }
                return results;
            }.call(this);
        };
        FactorRange.prototype._init = function () {
            var end, half_span, inside_padding, levels, start;
            if (array_1.all(this.factors, types_1.isString)) {
                levels = 1;
                _a = exports.map_one_level(this.factors, this.factor_padding), this._mapping = _a[0], inside_padding = _a[1];
            } else if (array_1.all(this.factors, function (x) {
                    return types_1.isArray(x) && x.length === 2 && types_1.isString(x[0]) && types_1.isString(x[1]);
                })) {
                levels = 2;
                _b = exports.map_two_levels(this.factors, this.group_padding, this.factor_padding), this._mapping = _b[0], this.tops = _b[1], inside_padding = _b[2];
            } else if (array_1.all(this.factors, function (x) {
                    return types_1.isArray(x) && x.length === 3 && types_1.isString(x[0]) && types_1.isString(x[1]) && types_1.isString(x[2]);
                })) {
                levels = 3;
                _c = exports.map_three_levels(this.factors, this.group_padding, this.subgroup_padding, this.factor_padding), this._mapping = _c[0], this.tops = _c[1], this.mids = _c[2], inside_padding = _c[3];
            } else {
                throw new Error('');
            }
            start = 0;
            end = this.factors.length + inside_padding;
            if (this.range_padding_units === 'percent') {
                half_span = (end - start) * this.range_padding / 2;
                start -= half_span;
                end += half_span;
            } else {
                start -= this.range_padding;
                end += this.range_padding;
            }
            this.setv({
                start: start,
                end: end,
                levels: levels
            }, { silent: true });
            if (this.bounds === 'auto') {
                return this.setv({
                    bounds: [
                        start,
                        end
                    ]
                }, { silent: true });
            }
            var _a, _b, _c;
        };
        FactorRange.prototype._lookup = function (x) {
            if (x.length === 1) {
                return this._mapping[x[0]].value;
            } else if (x.length === 2) {
                return this._mapping[x[0]].mapping[x[1]].value;
            } else if (x.length === 3) {
                return this._mapping[x[0]].mapping[x[1]].mapping[x[2]].value;
            }
        };
        return FactorRange;
    }(range_1.Range);
    exports.FactorRange = FactorRange;
    ;
    FactorRange.prototype.type = 'FactorRange';
    FactorRange.define({
        factors: [
            p.Array,
            []
        ],
        factor_padding: [
            p.Number,
            0
        ],
        subgroup_padding: [
            p.Number,
            0.8
        ],
        group_padding: [
            p.Number,
            1.4
        ],
        range_padding: [
            p.Number,
            0
        ],
        range_padding_units: [
            p.PaddingUnits,
            'percent'
        ],
        start: [p.Number],
        end: [p.Number],
        bounds: [p.Any],
        min_interval: [p.Any],
        max_interval: [p.Any]
    });
    FactorRange.getters({
        min: function () {
            return this.start;
        },
        max: function () {
            return this.end;
        }
    });
    FactorRange.internal({
        levels: [p.Number],
        mids: [p.Array],
        tops: [p.Array],
        tops_groups: [p.Array]    // ordered list of full factors for each top level factor in tops
    });    
},
/*models/ranges/index*/
function _(require, module, exports) {
    var data_range_1 = require(155    /* ./data_range */);
    exports.DataRange = data_range_1.DataRange;
    var data_range1d_1 = require(156    /* ./data_range1d */);
    exports.DataRange1d = data_range1d_1.DataRange1d;
    var factor_range_1 = require(157    /* ./factor_range */);
    exports.FactorRange = factor_range_1.FactorRange;
    var range_1 = require(159    /* ./range */);
    exports.Range = range_1.Range;
    var range1d_1 = require(160    /* ./range1d */);
    exports.Range1d = range1d_1.Range1d;    
},
/*models/ranges/range*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    var Range = function (_super) {
        tslib_1.__extends(Range, _super);
        function Range() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Range.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.connect(this.change, function () {
                return this._emit_callback();
            });
        };
        Range.prototype.reset = function () {
            'This method should be reimplemented by subclasses and ensure that\nthe callback, if exists, is executed at completion.';
            return this.change.emit();
        };
        Range.prototype._emit_callback = function () {
            if (this.callback != null) {
                if (types_1.isFunction(this.callback)) {
                    return this.callback(this);
                } else {
                    return this.callback.execute(this);
                }
            }
        };
        return Range;
    }(model_1.Model);
    exports.Range = Range;
    ;
    Range.prototype.type = 'Range';
    Range.define({
        callback: [p.Any]    // TODO: p.Either(p.Instance(Callback), p.Function)
    });
    Range.internal({
        plots: [
            p.Array,
            []
        ]
    });    
},
/*models/ranges/range1d*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var range_1 = require(159    /* ./range */);
    var p = require(15    /* core/properties */);
    var Range1d = function (_super) {
        tslib_1.__extends(Range1d, _super);
        function Range1d() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Range1d.prototype._set_auto_bounds = function () {
            var max, min;
            if (this.bounds === 'auto') {
                min = Math.min(this._initial_start, this._initial_end);
                max = Math.max(this._initial_start, this._initial_end);
                return this.setv({
                    bounds: [
                        min,
                        max
                    ]
                }, { silent: true });
            }
        };
        Range1d.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._initial_start = this.start;
            this._initial_end = this.end;
            return this._set_auto_bounds();
        };
        Object.defineProperty(Range1d.prototype, 'min', {
            get: function () {
                return Math.min(this.start, this.end);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range1d.prototype, 'max', {
            get: function () {
                return Math.max(this.start, this.end);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range1d.prototype, 'is_reversed', {
            get: function () {
                return this.start > this.end;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Range1d.prototype.reset = function () {
            this._set_auto_bounds();
            if (this.start !== this._initial_start || this.end !== this._initial_end) {
                return this.setv({
                    start: this._initial_start,
                    end: this._initial_end
                });
            } else {
                return this.change.emit();
            }
        };
        return Range1d;
    }(range_1.Range);
    exports.Range1d = Range1d;
    ;
    Range1d.prototype.type = 'Range1d';
    Range1d.define({
        start: [
            p.Number,
            0
        ],
        end: [
            p.Number,
            1
        ],
        bounds: [p.Any],
        min_interval: [p.Any],
        max_interval: [p.Any]
    });    
},
/*models/renderers/glyph_renderer*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var indexOf = [].indexOf;
    var renderer_1 = require(165    /* ./renderer */);
    var line_1 = require(114    /* ../glyphs/line */);
    var remote_data_source_1 = require(178    /* ../sources/remote_data_source */);
    var cds_view_1 = require(172    /* ../sources/cds_view */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var object_1 = require(30    /* core/util/object */);
    exports.GlyphRendererView = function (_super) {
        tslib_1.__extends(GlyphRendererView, _super);
        function GlyphRendererView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GlyphRendererView.prototype.initialize = function (options) {
            var base_glyph, decimated_glyph, glyph_attrs, has_fill, has_line, hover_glyph, mk_glyph, muted_glyph, nonselection_glyph, selection_glyph;
            _super.prototype.initialize.call(this, options);
            base_glyph = this.model.glyph;
            has_fill = indexOf.call(base_glyph.mixins, 'fill') >= 0;
            has_line = indexOf.call(base_glyph.mixins, 'line') >= 0;
            glyph_attrs = object_1.clone(base_glyph.attributes);
            delete glyph_attrs.id;
            mk_glyph = function (defaults) {
                var attrs;
                attrs = object_1.clone(glyph_attrs);
                if (has_fill) {
                    object_1.extend(attrs, defaults.fill);
                }
                if (has_line) {
                    object_1.extend(attrs, defaults.line);
                }
                return new base_glyph.constructor(attrs);
            };
            this.glyph = this.build_glyph_view(base_glyph);
            selection_glyph = this.model.selection_glyph;
            if (selection_glyph == null) {
                selection_glyph = mk_glyph({
                    fill: {},
                    line: {}
                });
            } else if (selection_glyph === 'auto') {
                selection_glyph = mk_glyph(this.model.selection_defaults);
            }
            this.selection_glyph = this.build_glyph_view(selection_glyph);
            nonselection_glyph = this.model.nonselection_glyph;
            if (nonselection_glyph == null) {
                nonselection_glyph = mk_glyph({
                    fill: {},
                    line: {}
                });
            } else if (nonselection_glyph === 'auto') {
                nonselection_glyph = mk_glyph(this.model.nonselection_defaults);
            }
            this.nonselection_glyph = this.build_glyph_view(nonselection_glyph);
            hover_glyph = this.model.hover_glyph;
            if (hover_glyph != null) {
                this.hover_glyph = this.build_glyph_view(hover_glyph);
            }
            muted_glyph = this.model.muted_glyph;
            if (muted_glyph != null) {
                this.muted_glyph = this.build_glyph_view(muted_glyph);
            }
            decimated_glyph = mk_glyph(this.model.decimated_defaults);
            this.decimated_glyph = this.build_glyph_view(decimated_glyph);
            this.xscale = this.plot_view.frame.xscales[this.model.x_range_name];
            this.yscale = this.plot_view.frame.yscales[this.model.y_range_name];
            this.set_data(false);
            if (this.model.data_source instanceof remote_data_source_1.RemoteDataSource) {
                return this.model.data_source.setup();
            }
        };
        GlyphRendererView.prototype.build_glyph_view = function (model) {
            return new model.default_view({
                model: model,
                renderer: this,
                plot_view: this.plot_view,
                parent: this
            });
        };
        GlyphRendererView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            this.connect(this.model.change, function () {
                return this.request_render();
            });
            this.connect(this.model.glyph.change, function () {
                return this.set_data();
            });
            this.connect(this.model.data_source.change, function () {
                return this.set_data();
            });
            this.connect(this.model.data_source.streaming, function () {
                return this.set_data();
            });
            this.connect(this.model.data_source.patching, function (indices) {
                return this.set_data(true, indices);
            });
            this.connect(this.model.data_source.select, function () {
                return this.request_render();
            });
            if (this.hover_glyph != null) {
                this.connect(this.model.data_source.inspect, function () {
                    return this.request_render();
                });
            }
            this.connect(this.model.properties.view.change, function () {
                return this.set_data();
            });
            this.connect(this.model.view.change, function () {
                return this.set_data();
            });
            return this.connect(this.model.glyph.transformchange, function () {
                return this.set_data();
            });
        };
        GlyphRendererView.prototype.have_selection_glyphs = function () {
            return this.selection_glyph != null && this.nonselection_glyph != null;
        };
        // in case of partial updates like patching, the list of indices that actually
        // changed may be passed as the "indices" parameter to afford any optional optimizations
        GlyphRendererView.prototype.set_data = function (request_render, indices) {
            if (request_render === void 0) {
                request_render = true;
            }
            var dt, i, j, lod_factor, ref, source, t0;
            t0 = Date.now();
            source = this.model.data_source;
            this.all_indices = this.model.view.indices;
            // TODO (bev) this is a bit clunky, need to make sure glyphs use the correct ranges when they call
            // mapping functions on the base Renderer class
            this.glyph.model.setv({
                x_range_name: this.model.x_range_name,
                y_range_name: this.model.y_range_name
            }, { silent: true });
            this.glyph.set_data(source, this.all_indices, indices);
            this.glyph.set_visuals(source);
            this.decimated_glyph.set_visuals(source);
            if (this.have_selection_glyphs()) {
                this.selection_glyph.set_visuals(source);
                this.nonselection_glyph.set_visuals(source);
            }
            if (this.hover_glyph != null) {
                this.hover_glyph.set_visuals(source);
            }
            if (this.muted_glyph != null) {
                this.muted_glyph.set_visuals(source);
            }
            lod_factor = this.plot_model.plot.lod_factor;
            this.decimated = [];
            for (i = j = 0, ref = Math.floor(this.all_indices.length / lod_factor); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                this.decimated.push(i * lod_factor);
            }
            dt = Date.now() - t0;
            logging_1.logger.debug(this.glyph.model.type + ' GlyphRenderer (' + this.model.id + '): set_data finished in ' + dt + 'ms');
            this.set_data_timestamp = Date.now();
            if (request_render) {
                return this.request_render();
            }
        };
        GlyphRendererView.prototype.render = function () {
            var ctx, dtmap, dtmask, dtrender, dtselect, dttot, glsupport, glyph, i, indices, inspected, j, k, l, len, len1, len2, lod_threshold, m, nonselected, nonselection_glyph, ref, ref1, ref2, results, selected, selected_mask, selection_glyph, t0, tmap, tmask, trender, tselect;
            if (!this.model.visible) {
                return;
            }
            t0 = Date.now();
            glsupport = this.glyph.glglyph;
            tmap = Date.now();
            this.glyph.map_data();
            dtmap = Date.now() - t0;
            tmask = Date.now();
            // all_indices is in full data space, indices is converted to subset space
            // either by mask_data (that uses the spatial index) or manually
            indices = this.glyph.mask_data(this.all_indices);
            if (indices.length === this.all_indices.length) {
                indices = function () {
                    results = [];
                    for (var j = 0, ref = this.all_indices.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
                        results.push(j);
                    }
                    return results;
                }.apply(this);
            }
            dtmask = Date.now() - tmask;
            ctx = this.plot_view.canvas_view.ctx;
            ctx.save();
            // selected is in full set space
            selected = this.model.data_source.selected;
            if (!selected || selected.length === 0) {
                selected = [];
            } else {
                if (selected['0d'].glyph) {
                    selected = this.model.view.convert_indices_from_subset(indices);
                } else if (selected['1d'].indices.length > 0) {
                    selected = selected['1d'].indices;
                } else {
                    selected = function () {
                        var k, len, ref1, results1;
                        ref1 = Object.keys(selected['2d'].indices);
                        results1 = [];
                        for (k = 0, len = ref1.length; k < len; k++) {
                            i = ref1[k];
                            results1.push(parseInt(i));
                        }
                        return results1;
                    }();
                }
            }
            // inspected is in full set space
            inspected = this.model.data_source.inspected;
            if (!inspected || inspected.length === 0) {
                inspected = [];
            } else {
                if (inspected['0d'].glyph) {
                    inspected = this.model.view.convert_indices_from_subset(indices);
                } else if (inspected['1d'].indices.length > 0) {
                    inspected = inspected['1d'].indices;
                } else {
                    inspected = function () {
                        var k, len, ref1, results1;
                        ref1 = Object.keys(inspected['2d'].indices);
                        results1 = [];
                        for (k = 0, len = ref1.length; k < len; k++) {
                            i = ref1[k];
                            results1.push(parseInt(i));
                        }
                        return results1;
                    }();
                }
            }
            // inspected is transformed to subset space
            inspected = function () {
                var k, len, ref1, results1;
                results1 = [];
                for (k = 0, len = indices.length; k < len; k++) {
                    i = indices[k];
                    if (ref1 = this.all_indices[i], indexOf.call(inspected, ref1) >= 0) {
                        results1.push(i);
                    }
                }
                return results1;
            }.call(this);
            lod_threshold = this.plot_model.plot.lod_threshold;
            if (((ref1 = this.model.document) != null ? ref1.interactive_duration() : void 0) > 0 && !glsupport && lod_threshold != null && this.all_indices.length > lod_threshold) {
                // Render decimated during interaction if too many elements and not using GL
                indices = this.decimated;
                glyph = this.decimated_glyph;
                nonselection_glyph = this.decimated_glyph;
                selection_glyph = this.selection_glyph;
            } else {
                glyph = this.model.muted && this.muted_glyph != null ? this.muted_glyph : this.glyph;
                nonselection_glyph = this.nonselection_glyph;
                selection_glyph = this.selection_glyph;
            }
            if (this.hover_glyph != null && inspected.length) {
                indices = array_1.difference(indices, inspected);
            }
            if (!(selected.length && this.have_selection_glyphs())) {
                trender = Date.now();
                if (this.glyph instanceof line_1.LineView) {
                    if (this.hover_glyph && inspected.length) {
                        this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected), this.glyph);
                    } else {
                        glyph.render(ctx, this.all_indices, this.glyph);
                    }
                } else {
                    glyph.render(ctx, indices, this.glyph);
                    if (this.hover_glyph && inspected.length) {
                        this.hover_glyph.render(ctx, inspected, this.glyph);
                    }
                }
                dtrender = Date.now() - trender;
            } else {
                // reset the selection mask
                tselect = Date.now();
                selected_mask = {};
                for (k = 0, len = selected.length; k < len; k++) {
                    i = selected[k];
                    selected_mask[i] = true;
                }
                // intersect/different selection with render mask
                selected = new Array();
                nonselected = new Array();
                // now, selected is changed to subset space, except for Line glyph
                if (this.glyph instanceof line_1.LineView) {
                    ref2 = this.all_indices;
                    for (l = 0, len1 = ref2.length; l < len1; l++) {
                        i = ref2[l];
                        if (selected_mask[i] != null) {
                            selected.push(i);
                        } else {
                            nonselected.push(i);
                        }
                    }
                } else {
                    for (m = 0, len2 = indices.length; m < len2; m++) {
                        i = indices[m];
                        if (selected_mask[this.all_indices[i]] != null) {
                            selected.push(i);
                        } else {
                            nonselected.push(i);
                        }
                    }
                }
                dtselect = Date.now() - tselect;
                trender = Date.now();
                nonselection_glyph.render(ctx, nonselected, this.glyph);
                selection_glyph.render(ctx, selected, this.glyph);
                if (this.hover_glyph != null) {
                    if (this.glyph instanceof line_1.LineView) {
                        this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected), this.glyph);
                    } else {
                        this.hover_glyph.render(ctx, inspected, this.glyph);
                    }
                }
                dtrender = Date.now() - trender;
            }
            this.last_dtrender = dtrender;
            dttot = Date.now() - t0;
            logging_1.logger.debug(this.glyph.model.type + ' GlyphRenderer (' + this.model.id + '): render finished in ' + dttot + 'ms');
            logging_1.logger.trace(' - map_data finished in       : ' + dtmap + 'ms');
            if (dtmask != null) {
                logging_1.logger.trace(' - mask_data finished in      : ' + dtmask + 'ms');
            }
            if (dtselect != null) {
                logging_1.logger.trace(' - selection mask finished in : ' + dtselect + 'ms');
            }
            logging_1.logger.trace(' - glyph renders finished in  : ' + dtrender + 'ms');
            return ctx.restore();
        };
        GlyphRendererView.prototype.draw_legend = function (ctx, x0, x1, y0, y1, field, label) {
            var index;
            index = this.model.get_reference_point(field, label);
            return this.glyph.draw_legend_for_index(ctx, x0, x1, y0, y1, index);
        };
        GlyphRendererView.prototype.hit_test = function (geometry, final, append, mode) {
            if (mode === void 0) {
                mode = 'select';
            }
            return this.model.hit_test_helper(geometry, this, final, append, mode);
        };
        return GlyphRendererView;
    }(renderer_1.RendererView);
    var GlyphRenderer = function (_super) {
        tslib_1.__extends(GlyphRenderer, _super);
        function GlyphRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GlyphRenderer.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            if (this.view.source == null) {
                this.view.source = this.data_source;
                return this.view.compute_indices();
            }
        };
        GlyphRenderer.prototype.get_reference_point = function (field, value) {
            var data, i, index;
            index = 0;
            // This is the default to return
            if (field != null && this.data_source.get_column != null) {
                data = this.data_source.get_column(field);
                if (data) {
                    i = data.indexOf(value);
                    if (i > 0) {
                        index = i;
                    }
                }
            }
            return index;
        };
        GlyphRenderer.prototype.hit_test_helper = function (geometry, renderer_view, final, append, mode) {
            var hit_test_result, indices, inspector, selector;
            if (!this.visible) {
                return false;
            }
            hit_test_result = renderer_view.glyph.hit_test(geometry);
            // glyphs that don't have hit-testing implemented will return null
            if (hit_test_result === null) {
                return false;
            }
            indices = this.view.convert_selection_from_subset(hit_test_result);
            if (mode === 'select') {
                selector = this.data_source.selection_manager.selector;
                selector.update(indices, final, append);
                this.data_source.selected = selector.indices;
                this.data_source.select.emit();    // mode == "inspect"
            } else {
                inspector = this.data_source.selection_manager.get_or_create_inspector(this);
                inspector.update(indices, true, false, true);
                // silently set inspected attr to avoid triggering data_source.change event and rerender
                this.data_source.setv({ inspected: inspector.indices }, { silent: true });
                this.data_source.inspect.emit([
                    renderer_view,
                    { geometry: geometry }
                ]);
            }
            return !indices.is_empty();
        };
        GlyphRenderer.prototype.get_selection_manager = function () {
            return this.data_source.selection_manager;
        };
        return GlyphRenderer;
    }(renderer_1.Renderer);
    exports.GlyphRenderer = GlyphRenderer;
    ;
    GlyphRenderer.prototype.default_view = exports.GlyphRendererView;
    GlyphRenderer.prototype.type = 'GlyphRenderer';
    GlyphRenderer.define({
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        data_source: [p.Instance],
        view: [
            p.Instance,
            function () {
                return new cds_view_1.CDSView();
            }
        ],
        glyph: [p.Instance],
        hover_glyph: [p.Instance],
        nonselection_glyph: [
            p.Any,
            'auto'    // Instance or "auto"
        ],
        selection_glyph: [
            p.Any,
            'auto'    // Instance or "auto"
        ],
        muted_glyph: [p.Instance],
        muted: [
            p.Bool,
            false
        ]
    });
    GlyphRenderer.override({ level: 'glyph' });
    GlyphRenderer.prototype.selection_defaults = {
        fill: {},
        line: {}
    };
    GlyphRenderer.prototype.decimated_defaults = {
        fill: {
            fill_alpha: 0.3,
            fill_color: 'grey'
        },
        line: {
            line_alpha: 0.3,
            line_color: 'grey'
        }
    };
    GlyphRenderer.prototype.nonselection_defaults = {
        fill: {
            fill_alpha: 0.2,
            line_alpha: 0.2
        },
        line: {}
    };    
},
/*models/renderers/graph_renderer*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var renderer_1 = require(165    /* ../renderers/renderer */);
    var graph_hit_test_policy_1 = require(129    /* ../graphs/graph_hit_test_policy */);
    var p = require(15    /* core/properties */);
    var build_views_1 = require(4    /* core/build_views */);
    exports.GraphRendererView = function (_super) {
        tslib_1.__extends(GraphRendererView, _super);
        function GraphRendererView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GraphRendererView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.xscale = this.plot_view.frame.xscales['default'];
            this.yscale = this.plot_view.frame.yscales['default'];
            this._renderer_views = {};
            _a = build_views_1.build_views(this._renderer_views, [
                this.model.node_renderer,
                this.model.edge_renderer
            ], this.plot_view.view_options()), this.node_view = _a[0], this.edge_view = _a[1];
            return this.set_data();
            var _a;
        };
        GraphRendererView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            this.connect(this.model.layout_provider.change, function () {
                return this.set_data();
            });
            this.connect(this.model.node_renderer.data_source.select, function () {
                return this.set_data();
            });
            this.connect(this.model.node_renderer.data_source.inspect, function () {
                return this.set_data();
            });
            this.connect(this.model.node_renderer.data_source.change, function () {
                return this.set_data();
            });
            this.connect(this.model.edge_renderer.data_source.select, function () {
                return this.set_data();
            });
            this.connect(this.model.edge_renderer.data_source.inspect, function () {
                return this.set_data();
            });
            return this.connect(this.model.edge_renderer.data_source.change, function () {
                return this.set_data();
            });
        };
        GraphRendererView.prototype.set_data = function (request_render) {
            if (request_render === void 0) {
                request_render = true;
            }
            // TODO (bev) this is a bit clunky, need to make sure glyphs use the correct ranges when they call
            // mapping functions on the base Renderer class
            this.node_view.glyph.model.setv({
                x_range_name: this.model.x_range_name,
                y_range_name: this.model.y_range_name
            }, { silent: true });
            this.edge_view.glyph.model.setv({
                x_range_name: this.model.x_range_name,
                y_range_name: this.model.y_range_name
            }, { silent: true });
            _a = this.model.layout_provider.get_node_coordinates(this.model.node_renderer.data_source), this.node_view.glyph._x = _a[0], this.node_view.glyph._y = _a[1];
            _b = this.model.layout_provider.get_edge_coordinates(this.model.edge_renderer.data_source), this.edge_view.glyph._xs = _b[0], this.edge_view.glyph._ys = _b[1];
            this.node_view.glyph.index = this.node_view.glyph._index_data();
            this.edge_view.glyph.index = this.edge_view.glyph._index_data();
            if (request_render) {
                return this.request_render();
            }
            var _a, _b;
        };
        GraphRendererView.prototype.render = function () {
            this.edge_view.render();
            return this.node_view.render();
        };
        GraphRendererView.prototype.hit_test = function (geometry, final, append, mode) {
            if (mode === void 0) {
                mode = 'select';
            }
            var did_hit, ref, ref1;
            if (!this.model.visible) {
                return false;
            }
            did_hit = false;
            if (mode === 'select') {
                did_hit = (ref = this.model.selection_policy) != null ? ref.do_selection(geometry, this, final, append) : void 0;    // if mode == "inspect"
            } else {
                did_hit = (ref1 = this.model.inspection_policy) != null ? ref1.do_inspection(geometry, this, final, append) : void 0;
            }
            return did_hit;
        };
        return GraphRendererView;
    }(renderer_1.RendererView);
    var GraphRenderer = function (_super) {
        tslib_1.__extends(GraphRenderer, _super);
        function GraphRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GraphRenderer.prototype.get_selection_manager = function () {
            return this.node_renderer.data_source.selection_manager;
        };
        return GraphRenderer;
    }(renderer_1.Renderer);
    exports.GraphRenderer = GraphRenderer;
    ;
    GraphRenderer.prototype.default_view = exports.GraphRendererView;
    GraphRenderer.prototype.type = 'GraphRenderer';
    GraphRenderer.define({
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        layout_provider: [p.Instance],
        node_renderer: [p.Instance],
        edge_renderer: [p.Instance],
        selection_policy: [
            p.Instance,
            function () {
                return new graph_hit_test_policy_1.NodesOnly();
            }
        ],
        inspection_policy: [
            p.Instance,
            function () {
                return new graph_hit_test_policy_1.NodesOnly();
            }
        ]
    });
    GraphRenderer.override({ level: 'glyph' });    
},
/*models/renderers/guide_renderer*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var renderer_1 = require(165    /* ./renderer */);
    var p = require(15    /* core/properties */);
    var GuideRenderer = function (_super) {
        tslib_1.__extends(GuideRenderer, _super);
        function GuideRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GuideRenderer;
    }(renderer_1.Renderer);
    exports.GuideRenderer = GuideRenderer;
    ;
    GuideRenderer.prototype.type = 'GuideRenderer';
    GuideRenderer.define({ plot: [p.Instance] });
    GuideRenderer.override({ level: 'overlay' });    
},
/*models/renderers/index*/
function _(require, module, exports) {
    var glyph_renderer_1 = require(161    /* ./glyph_renderer */);
    exports.GlyphRenderer = glyph_renderer_1.GlyphRenderer;
    var graph_renderer_1 = require(162    /* ./graph_renderer */);
    exports.GraphRenderer = graph_renderer_1.GraphRenderer;
    var guide_renderer_1 = require(163    /* ./guide_renderer */);
    exports.GuideRenderer = guide_renderer_1.GuideRenderer;
    var renderer_1 = require(165    /* ./renderer */);
    exports.Renderer = renderer_1.Renderer;    
},
/*models/renderers/renderer*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var dom_view_1 = require(6    /* core/dom_view */);
    var visuals_1 = require(46    /* core/visuals */);
    var p = require(15    /* core/properties */);
    var proj = require(32    /* core/util/projections */);
    var object_1 = require(30    /* core/util/object */);
    var model_1 = require(50    /* ../../model */);
    var RendererView = function (_super) {
        tslib_1.__extends(RendererView, _super);
        function RendererView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RendererView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.plot_view = options.plot_view;
            this.visuals = new visuals_1.Visuals(this.model);
            return this._has_finished = true;    // XXX: should be in render() but subclasses don't respect super()
        };
        RendererView.prototype.request_render = function () {
            return this.plot_view.request_render();
        };
        RendererView.prototype.set_data = function (source) {
            var data;
            data = this.model.materialize_dataspecs(source);
            object_1.extend(this, data);
            if (this.plot_model.use_map) {
                if (this._x != null) {
                    _a = proj.project_xy(this._x, this._y), this._x = _a[0], this._y = _a[1];
                }
                if (this._xs != null) {
                    return _b = proj.project_xsys(this._xs, this._ys), this._xs = _b[0], this._ys = _b[1], _b;
                }
            }
            var _a, _b;
        };
        RendererView.prototype.map_to_screen = function (x, y) {
            return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);
        };
        return RendererView;
    }(dom_view_1.DOMView);
    exports.RendererView = RendererView;
    ;
    RendererView.getters({
        plot_model: function () {
            return this.plot_view.model;
        }
    });
    var Renderer = function (_super) {
        tslib_1.__extends(Renderer, _super);
        function Renderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Renderer;
    }(model_1.Model);
    exports.Renderer = Renderer;
    ;
    Renderer.prototype.type = 'Renderer';
    Renderer.define({
        level: [
            p.RenderLevel,
            null
        ],
        visible: [
            p.Bool,
            true
        ]
    });    
},
/*models/scales/categorical_scale*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var linear_scale_1 = require(168    /* ./linear_scale */);
    var CategoricalScale = function (_super) {
        tslib_1.__extends(CategoricalScale, _super);
        function CategoricalScale() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CategoricalScale.prototype.compute = function (x) {
            return _super.prototype.compute.call(this, this.source_range.synthetic(x));
        };
        CategoricalScale.prototype.v_compute = function (xs) {
            return _super.prototype.v_compute.call(this, this.source_range.v_synthetic(xs));
        };
        return CategoricalScale;
    }(linear_scale_1.LinearScale);
    exports.CategoricalScale = CategoricalScale;
    ;
    CategoricalScale.prototype.type = 'CategoricalScale';    
},
/*models/scales/index*/
function _(require, module, exports) {
    var categorical_scale_1 = require(166    /* ./categorical_scale */);
    exports.CategoricalScale = categorical_scale_1.CategoricalScale;
    var linear_scale_1 = require(168    /* ./linear_scale */);
    exports.LinearScale = linear_scale_1.LinearScale;
    var log_scale_1 = require(169    /* ./log_scale */);
    exports.LogScale = log_scale_1.LogScale;
    var scale_1 = require(170    /* ./scale */);
    exports.Scale = scale_1.Scale;    
},
/*models/scales/linear_scale*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var scale_1 = require(170    /* ./scale */);
    var LinearScale = function (_super) {
        tslib_1.__extends(LinearScale, _super);
        function LinearScale() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LinearScale.prototype.compute = function (x) {
            var factor, offset;
            _a = this._compute_state(), factor = _a[0], offset = _a[1];
            return factor * x + offset;
            var _a;
        };
        LinearScale.prototype.v_compute = function (xs) {
            var factor, i, idx, len, offset, result, x;
            _a = this._compute_state(), factor = _a[0], offset = _a[1];
            result = new Float64Array(xs.length);
            for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
                x = xs[idx];
                result[idx] = factor * x + offset;
            }
            return result;
            var _a;
        };
        LinearScale.prototype.invert = function (xprime) {
            var factor, offset;
            _a = this._compute_state(), factor = _a[0], offset = _a[1];
            return (xprime - offset) / factor;
            var _a;
        };
        LinearScale.prototype.v_invert = function (xprimes) {
            var factor, i, idx, len, offset, result, xprime;
            _a = this._compute_state(), factor = _a[0], offset = _a[1];
            result = new Float64Array(xprimes.length);
            for (idx = i = 0, len = xprimes.length; i < len; idx = ++i) {
                xprime = xprimes[idx];
                result[idx] = (xprime - offset) / factor;
            }
            return result;
            var _a;
        };
        LinearScale.prototype._compute_state = function () {
            var factor, offset, source_end, source_start, target_end, target_start;
            //  (t1 - t0)       (t1 - t0)
            //  --------- * x - --------- * s0 + t0
            //  (s1 - s0)       (s1 - s0)
            // [  factor  ]     [    offset    ]
            source_start = this.source_range.start;
            source_end = this.source_range.end;
            target_start = this.target_range.start;
            target_end = this.target_range.end;
            factor = (target_end - target_start) / (source_end - source_start);
            offset = -(factor * source_start) + target_start;
            return [
                factor,
                offset
            ];
        };
        return LinearScale;
    }(scale_1.Scale);
    exports.LinearScale = LinearScale;
    ;
    LinearScale.prototype.type = 'LinearScale';    
},
/*models/scales/log_scale*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var scale_1 = require(170    /* ./scale */);
    var LogScale = function (_super) {
        tslib_1.__extends(LogScale, _super);
        function LogScale() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LogScale.prototype.compute = function (x) {
            var _x, factor, inter_factor, inter_offset, offset, value;
            _a = this._compute_state(), factor = _a[0], offset = _a[1], inter_factor = _a[2], inter_offset = _a[3];
            if (inter_factor === 0) {
                value = 0;
            } else {
                _x = (Math.log(x) - inter_offset) / inter_factor;
                if (isFinite(_x)) {
                    value = _x * factor + offset;
                } else {
                    value = 0 / 0;
                }
            }
            return value;
            var _a;
        };
        LogScale.prototype.v_compute = function (xs) {
            var _x, factor, i, inter_factor, inter_offset, j, k, offset, ref, ref1, result, value;
            _a = this._compute_state(), factor = _a[0], offset = _a[1], inter_factor = _a[2], inter_offset = _a[3];
            result = new Float64Array(xs.length);
            if (inter_factor === 0) {
                for (i = j = 0, ref = xs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    result[i] = 0;
                }
            } else {
                for (i = k = 0, ref1 = xs.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                    _x = (Math.log(xs[i]) - inter_offset) / inter_factor;
                    if (isFinite(_x)) {
                        value = _x * factor + offset;
                    } else {
                        value = 0 / 0;
                    }
                    result[i] = value;
                }
            }
            return result;
            var _a;
        };
        LogScale.prototype.invert = function (xprime) {
            var factor, inter_factor, inter_offset, offset, value;
            _a = this._compute_state(), factor = _a[0], offset = _a[1], inter_factor = _a[2], inter_offset = _a[3];
            value = (xprime - offset) / factor;
            return Math.exp(inter_factor * value + inter_offset);
            var _a;
        };
        LogScale.prototype.v_invert = function (xprimes) {
            var factor, i, inter_factor, inter_offset, j, offset, ref, result, value;
            _a = this._compute_state(), factor = _a[0], offset = _a[1], inter_factor = _a[2], inter_offset = _a[3];
            result = new Float64Array(xprimes.length);
            for (i = j = 0, ref = xprimes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                value = (xprimes[i] - offset) / factor;
                result[i] = Math.exp(inter_factor * value + inter_offset);
            }
            return result;
            var _a;
        };
        LogScale.prototype._get_safe_factor = function (orig_start, orig_end) {
            var end, log_val, start;
            if (orig_start < 0) {
                start = 0;
            } else {
                start = orig_start;
            }
            if (orig_end < 0) {
                end = 0;
            } else {
                end = orig_end;
            }
            if (start === end) {
                if (start === 0) {
                    _a = [
                        1,
                        10
                    ], start = _a[0], end = _a[1];
                } else {
                    log_val = Math.log(start) / Math.log(10);
                    start = Math.pow(10, Math.floor(log_val));
                    if (Math.ceil(log_val) !== Math.floor(log_val)) {
                        end = Math.pow(10, Math.ceil(log_val));
                    } else {
                        end = Math.pow(10, Math.ceil(log_val) + 1);
                    }
                }
            }
            return [
                start,
                end
            ];
            var _a;
        };
        LogScale.prototype._compute_state = function () {
            var end, factor, inter_factor, inter_offset, offset, screen_range, source_end, source_start, start, target_end, target_start;
            source_start = this.source_range.start;
            source_end = this.source_range.end;
            target_start = this.target_range.start;
            target_end = this.target_range.end;
            screen_range = target_end - target_start;
            _a = this._get_safe_factor(source_start, source_end), start = _a[0], end = _a[1];
            if (start === 0) {
                inter_factor = Math.log(end);
                inter_offset = 0;
            } else {
                inter_factor = Math.log(end) - Math.log(start);
                inter_offset = Math.log(start);
            }
            factor = screen_range;
            offset = target_start;
            return [
                factor,
                offset,
                inter_factor,
                inter_offset
            ];
            var _a;
        };
        return LogScale;
    }(scale_1.Scale);
    exports.LogScale = LogScale;
    ;
    LogScale.prototype.type = 'LogScale';    
},
/*models/scales/scale*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var transforms_1 = require(238    /* ../transforms */);
    var p = require(15    /* core/properties */);
    var Scale = function (_super) {
        tslib_1.__extends(Scale, _super);
        function Scale() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Scale.prototype.r_compute = function (x0, x1) {
            if (this.target_range.is_reversed)
                return [
                    this.compute(x1),
                    this.compute(x0)
                ];
            else
                return [
                    this.compute(x0),
                    this.compute(x1)
                ];
        };
        Scale.prototype.r_invert = function (sx0, sx1) {
            if (this.target_range.is_reversed)
                return [
                    this.invert(sx1),
                    this.invert(sx0)
                ];
            else
                return [
                    this.invert(sx0),
                    this.invert(sx1)
                ];
        };
        return Scale;
    }(transforms_1.Transform);
    exports.Scale = Scale;
    Scale.prototype.type = 'Scale';
    Scale.internal({
        source_range: [p.Any],
        target_range: [p.Any]
    });    
},
/*models/sources/ajax_data_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var boundMethodCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new Error('Bound instance method accessed before binding');
        }
    };
    var remote_data_source_1 = require(178    /* ./remote_data_source */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var AjaxDataSource = function (_super) {
        tslib_1.__extends(AjaxDataSource, _super);
        function AjaxDataSource() {
            var _this = _super.apply(this, arguments) || this;
            _this.destroy = _this.destroy.bind(_this);
            _this.setup = _this.setup.bind(_this);
            _this.get_data = _this.get_data.bind(_this);
            return _this;
        }
        AjaxDataSource.prototype.destroy = function () {
            boundMethodCheck(this, AjaxDataSource);
            if (this.interval != null) {
                return clearInterval(this.interval);
            }
        };
        AjaxDataSource.prototype.setup = function () {
            boundMethodCheck(this, AjaxDataSource);
            if (this.initialized == null) {
                this.initialized = true;
                this.get_data(this.mode);
                if (this.polling_interval) {
                    return this.interval = setInterval(this.get_data, this.polling_interval, this.mode, this.max_size, this.if_modified);
                }
            }
        };
        AjaxDataSource.prototype.get_data = function (mode, max_size, if_modified) {
            var _this = this;
            if (max_size === void 0) {
                max_size = 0;
            }
            if (if_modified === void 0) {
                if_modified = false;
            }
            var name, ref, value, xhr;
            boundMethodCheck(this, AjaxDataSource);
            xhr = new XMLHttpRequest();
            xhr.open(this.method, this.data_url, true);
            xhr.withCredentials = false;
            xhr.setRequestHeader('Content-Type', this.content_type);
            ref = this.http_headers;
            for (name in ref) {
                value = ref[name];
                xhr.setRequestHeader(name, value);
            }
            // TODO: if_modified
            xhr.addEventListener('load', function () {
                var column, data, i, len, original_data, ref1;
                if (xhr.status === 200) {
                    data = JSON.parse(xhr.responseText);
                    switch (mode) {
                    case 'replace':
                        return _this.data = data;
                    case 'append':
                        original_data = _this.data;
                        ref1 = _this.columns();
                        for (i = 0, len = ref1.length; i < len; i++) {
                            column = ref1[i];
                            data[column] = original_data[column].concat(data[column]).slice(-max_size);
                        }
                        return _this.data = data;
                    }
                }
            });
            xhr.addEventListener('error', function () {
                return logging_1.logger.error('Failed to fetch JSON from ' + _this.data_url + ' with code ' + xhr.status);
            });
            xhr.send();
            return null;
        };
        return AjaxDataSource;
    }(remote_data_source_1.RemoteDataSource);
    exports.AjaxDataSource = AjaxDataSource;
    ;
    AjaxDataSource.prototype.type = 'AjaxDataSource';
    AjaxDataSource.define({
        mode: [
            p.String,
            'replace'
        ],
        content_type: [
            p.String,
            'application/json'
        ],
        http_headers: [
            p.Any,
            {}
        ],
        max_size: [p.Number],
        method: [
            p.String,
            'POST'    // TODO (bev)  enum?
        ],
        if_modified: [
            p.Bool,
            false
        ]
    });    
},
/*models/sources/cds_view*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var p = require(15    /* core/properties */);
    var hittest_1 = require(9    /* core/hittest */);
    var array_1 = require(22    /* core/util/array */);
    var columnar_data_source_1 = require(174    /* ./columnar_data_source */);
    var CDSView = function (_super) {
        tslib_1.__extends(CDSView, _super);
        function CDSView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CDSView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.compute_indices();
        };
        CDSView.prototype.connect_signals = function () {
            var ref, ref1, ref2;
            _super.prototype.connect_signals.call(this);
            this.connect(this.properties.filters.change, function () {
                this.compute_indices();
                return this.change.emit();
            });
            if (((ref = this.source) != null ? ref.change : void 0) != null) {
                this.connect(this.source.change, function () {
                    return this.compute_indices();
                });
            }
            if (((ref1 = this.source) != null ? ref1.streaming : void 0) != null) {
                this.connect(this.source.streaming, function () {
                    return this.compute_indices();
                });
            }
            if (((ref2 = this.source) != null ? ref2.patching : void 0) != null) {
                return this.connect(this.source.patching, function () {
                    return this.compute_indices();
                });
            }
        };
        CDSView.prototype.compute_indices = function () {
            var filter, indices, inds, ref;
            indices = function () {
                var j, len, ref, results;
                ref = this.filters;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    filter = ref[j];
                    results.push(filter.compute_indices(this.source));
                }
                return results;
            }.call(this);
            indices = function () {
                var j, len, results;
                results = [];
                for (j = 0, len = indices.length; j < len; j++) {
                    inds = indices[j];
                    if (inds != null) {
                        results.push(inds);
                    }
                }
                return results;
            }();
            if (indices.length > 0) {
                this.indices = array_1.intersection.apply(this, indices);
            } else {
                if (this.source instanceof columnar_data_source_1.ColumnarDataSource) {
                    this.indices = (ref = this.source) != null ? ref.get_indices() : void 0;
                }
            }
            return this.indices_map_to_subset();
        };
        CDSView.prototype.indices_map_to_subset = function () {
            var i, j, ref, results;
            this.indices_map = {};
            results = [];
            for (i = j = 0, ref = this.indices.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(this.indices_map[this.indices[i]] = i);
            }
            return results;
        };
        CDSView.prototype.convert_selection_from_subset = function (selection_subset) {
            var i, indices_1d, selection_full;
            selection_full = hittest_1.create_hit_test_result();
            selection_full.update_through_union(selection_subset);
            indices_1d = function () {
                var j, len, ref, results;
                ref = selection_subset['1d']['indices'];
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    i = ref[j];
                    results.push(this.indices[i]);
                }
                return results;
            }.call(this);
            selection_full['1d']['indices'] = indices_1d;
            return selection_full;
        };
        CDSView.prototype.convert_selection_to_subset = function (selection_full) {
            var i, indices_1d, selection_subset;
            selection_subset = hittest_1.create_hit_test_result();
            selection_subset.update_through_union(selection_full);
            indices_1d = function () {
                var j, len, ref, results;
                ref = selection_full['1d']['indices'];
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    i = ref[j];
                    results.push(this.indices_map[i]);
                }
                return results;
            }.call(this);
            selection_subset['1d']['indices'] = indices_1d;
            return selection_subset;
        };
        CDSView.prototype.convert_indices_from_subset = function (indices) {
            var i;
            return function () {
                var j, len, results;
                results = [];
                for (j = 0, len = indices.length; j < len; j++) {
                    i = indices[j];
                    results.push(this.indices[i]);
                }
                return results;
            }.call(this);
        };
        return CDSView;
    }(model_1.Model);
    exports.CDSView = CDSView;
    ;
    CDSView.prototype.type = 'CDSView';
    CDSView.define({
        filters: [
            p.Array,
            []
        ],
        source: [p.Instance]
    });
    CDSView.internal({
        indices: [
            p.Array,
            []
        ],
        indices_map: [
            p.Any,
            {}
        ]
    });    
},
/*models/sources/column_data_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var hasProp = {}.hasOwnProperty;
    var columnar_data_source_1 = require(174    /* ./columnar_data_source */);
    var has_props_1 = require(8    /* core/has_props */);
    var p = require(15    /* core/properties */);
    var data_structures_1 = require(27    /* core/util/data_structures */);
    var serialization = require(35    /* core/util/serialization */);
    var types_1 = require(42    /* core/util/types */);
    // exported for testing
    exports.concat_typed_arrays = function (a, b) {
        var c;
        c = new a.constructor(a.length + b.length);
        c.set(a, 0);
        c.set(b, a.length);
        return c;
    };
    //exported for testing
    exports.stream_to_column = function (col, new_col, rollover) {
        var end, i, l, m, ref, ref1, ref2, start, tmp, total_len;
        // handle regular (non-typed) arrays
        if (col.concat != null) {
            col = col.concat(new_col);
            if (col.length > rollover) {
                col = col.slice(-rollover);
            }
            return col;
        }
        total_len = col.length + new_col.length;
        // handle rollover case for typed arrays
        if (rollover != null && total_len > rollover) {
            start = total_len - rollover;
            end = col.length;
            // resize col if it is shorter than the rollover length
            if (col.length < rollover) {
                tmp = new col.constructor(rollover);
                tmp.set(col, 0);
                col = tmp;
            }
            // shift values in original col to accommodate new_col
            for (i = l = ref = start, ref1 = end; ref <= ref1 ? l < ref1 : l > ref1; i = ref <= ref1 ? ++l : --l) {
                col[i - start] = col[i];
            }
            // update end values in col with new_col
            for (i = m = 0, ref2 = new_col.length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
                col[i + (end - start)] = new_col[i];
            }
            return col;
        }
        // handle non-rollover case for typed arrays
        tmp = new col.constructor(new_col);
        return exports.concat_typed_arrays(col, tmp);
    };
    // exported for testing
    exports.slice = function (ind, length) {
        var ref, ref1, ref2, start, step, stop;
        if (types_1.isObject(ind)) {
            return [
                (ref = ind.start) != null ? ref : 0,
                (ref1 = ind.stop) != null ? ref1 : length,
                (ref2 = ind.step) != null ? ref2 : 1
            ];
        }
        return _a = [
            ind,
            ind + 1,
            1
        ], start = _a[0], stop = _a[1], step = _a[2], _a;
        var _a;
    };
    // exported for testing
    exports.patch_to_column = function (col, patch, shapes) {
        var flat_index, i, ind, istart, istep, istop, item, j, jstart, jstep, jstop, l, len, m, n, patched, patched_range, ref, ref1, ref2, ref3, ref4, ref5, shape, value;
        patched = new data_structures_1.Set();
        patched_range = false;
        for (l = 0, len = patch.length; l < len; l++) {
            _a = patch[l], ind = _a[0], value = _a[1];
            // make the single index case look like the length-3 multi-index case
            if (!types_1.isArray(ind)) {
                if (types_1.isNumber(ind)) {
                    value = [value];
                    patched.push(ind);
                } else {
                    patched_range = true;
                }
                ind = [
                    0,
                    0,
                    ind
                ];
                shape = [
                    1,
                    col.length
                ];
                item = col;
            } else {
                patched.push(ind[0]);
                shape = shapes[ind[0]];
                item = col[ind[0]];
            }
            // this is basically like NumPy's "newaxis", inserting an empty dimension
            // makes length 2 and 3 multi-index cases uniform, so that the same code
            // can handle both
            if (ind.length === 2) {
                shape = [
                    1,
                    shape[0]
                ];
                ind = [
                    ind[0],
                    0,
                    ind[1]
                ];
            }
            // now this one nested loop handles all cases
            flat_index = 0;
            _b = exports.slice(ind[1], shape[0]), istart = _b[0], istop = _b[1], istep = _b[2];
            _c = exports.slice(ind[2], shape[1]), jstart = _c[0], jstop = _c[1], jstep = _c[2];
            for (i = m = ref = istart, ref1 = istop, ref2 = istep; ref2 > 0 ? m < ref1 : m > ref1; i = m += ref2) {
                for (j = n = ref3 = jstart, ref4 = jstop, ref5 = jstep; ref5 > 0 ? n < ref4 : n > ref4; j = n += ref5) {
                    if (patched_range) {
                        patched.push(j);
                    }
                    item[i * shape[1] + j] = value[flat_index];
                    flat_index++;
                }
            }
        }
        return patched;
        var _a, _b, _c;
    };
    var ColumnDataSource = function (_super) {
        tslib_1.__extends(ColumnDataSource, _super);
        function ColumnDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColumnDataSource.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return _a = serialization.decode_column_data(this.data), this.data = _a[0], this._shapes = _a[1], _a;
            var _a;
        };
        ColumnDataSource.prototype.attributes_as_json = function (include_defaults, value_to_json) {
            if (include_defaults === void 0) {
                include_defaults = true;
            }
            if (value_to_json === void 0) {
                value_to_json = ColumnDataSource._value_to_json;
            }
            var attrs, key, ref, value;
            attrs = {};
            ref = this.serializable_attributes();
            for (key in ref) {
                if (!hasProp.call(ref, key))
                    continue;
                value = ref[key];
                if (key === 'data') {
                    value = serialization.encode_column_data(value, this._shapes);
                }
                if (include_defaults) {
                    attrs[key] = value;
                } else if (key in this._set_after_defaults) {
                    attrs[key] = value;
                }
            }
            return value_to_json('attributes', attrs, this);
        };
        ColumnDataSource._value_to_json = function (key, value, optional_parent_object) {
            if (types_1.isObject(value) && key === 'data') {
                return serialization.encode_column_data(value, optional_parent_object._shapes);
            } else {
                return has_props_1.HasProps._value_to_json(key, value, optional_parent_object);
            }
        };
        ColumnDataSource.prototype.stream = function (new_data, rollover) {
            var data, k, v;
            data = this.data;
            for (k in new_data) {
                v = new_data[k];
                data[k] = exports.stream_to_column(data[k], new_data[k], rollover);
            }
            this.setv({ data: data }, { silent: true });
            return this.streaming.emit();
        };
        ColumnDataSource.prototype.patch = function (patches) {
            var data, k, patch, patched;
            data = this.data;
            patched = new data_structures_1.Set();
            for (k in patches) {
                patch = patches[k];
                patched = patched.union(exports.patch_to_column(data[k], patch, this._shapes[k]));
            }
            this.setv({ data: data }, { silent: true });
            return this.patching.emit(patched.values);
        };
        return ColumnDataSource;
    }(columnar_data_source_1.ColumnarDataSource);
    exports.ColumnDataSource = ColumnDataSource;
    ;
    ColumnDataSource.prototype.type = 'ColumnDataSource';
    ColumnDataSource.define({
        data: [
            p.Any,
            {}
        ]
    });    
},
/*models/sources/columnar_data_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var data_source_1 = require(175    /* ./data_source */);
    var signaling_1 = require(20    /* core/signaling */);
    var logging_1 = require(14    /* core/logging */);
    var selection_manager_1 = require(17    /* core/selection_manager */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var ColumnarDataSource = function (_super) {
        tslib_1.__extends(ColumnarDataSource, _super);
        function ColumnarDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColumnarDataSource.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.select = new signaling_1.Signal(this, 'select');
            this.inspect = new signaling_1.Signal(this, 'inspect');
            // XXX: <[indices, tool, renderer-view, source, data], this>
            this.streaming = new signaling_1.Signal(this, 'streaming');
            return this.patching = new signaling_1.Signal(this, 'patching');    // <number[], ColumnarDataSource>
        };
        ColumnarDataSource.prototype.get_column = function (colname) {
            var ref;
            return (ref = this.data[colname]) != null ? ref : null;
        };
        ColumnarDataSource.prototype.columns = function () {
            // return the column names in this data source
            return Object.keys(this.data);
        };
        ColumnarDataSource.prototype.get_length = function (soft) {
            if (soft === void 0) {
                soft = true;
            }
            var _key, lengths, msg, val;
            lengths = array_1.uniq(function () {
                var ref, results;
                ref = this.data;
                results = [];
                for (_key in ref) {
                    val = ref[_key];
                    results.push(val.length);
                }
                return results;
            }.call(this));
            switch (lengths.length) {
            case 0:
                return null;
            // XXX: don't guess, treat on case-by-case basis
            case 1:
                return lengths[0];
            default:
                msg = 'data source has columns of inconsistent lengths';
                if (soft) {
                    logging_1.logger.warn(msg);
                    return lengths.sort()[0];
                } else {
                    throw new Error(msg);
                }
            }
        };
        ColumnarDataSource.prototype.get_indices = function () {
            var i, length, results;
            length = this.get_length();
            if (length == null) {
                length = 1;
            }
            return function () {
                results = [];
                for (var i = 0; 0 <= length ? i < length : i > length; 0 <= length ? i++ : i--) {
                    results.push(i);
                }
                return results;
            }.apply(this);
        };
        return ColumnarDataSource;
    }(data_source_1.DataSource);
    exports.ColumnarDataSource = ColumnarDataSource;
    ;
    ColumnarDataSource.prototype.type = 'ColumnarDataSource';
    ColumnarDataSource.define({
        column_names: [
            p.Array,
            []
        ]
    });
    ColumnarDataSource.internal({
        selection_manager: [
            p.Instance,
            function (self) {
                return new selection_manager_1.SelectionManager({ source: self });
            }
        ],
        inspected: [p.Any],
        _shapes: [
            p.Any,
            {}
        ]
    });    
},
/*models/sources/data_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    var hittest = require(9    /* core/hittest */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    var DataSource = function (_super) {
        tslib_1.__extends(DataSource, _super);
        function DataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DataSource.prototype.initialize = function (options) {
            var _this = this;
            _super.prototype.initialize.call(this, options);
            return this.connect(this.properties.selected.change, function () {
                var callback;
                callback = _this.callback;
                if (callback != null) {
                    if (types_1.isFunction(callback)) {
                        return callback(_this);
                    } else {
                        return callback.execute(_this);
                    }
                }
            });
        };
        return DataSource;
    }(model_1.Model);
    exports.DataSource = DataSource;
    ;
    DataSource.prototype.type = 'DataSource';
    DataSource.define({
        selected: [
            p.Any,
            hittest.create_hit_test_result()    // TODO (bev)
        ],
        callback: [p.Any]    // TODO: p.Either(p.Instance(Callback), p.Function) ]
    });    
},
/*models/sources/geojson_data_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var columnar_data_source_1 = require(174    /* ./columnar_data_source */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var GeoJSONDataSource = function (_super) {
        tslib_1.__extends(GeoJSONDataSource, _super);
        function GeoJSONDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GeoJSONDataSource.prototype.initialize = function (options) {
            var _this = this;
            _super.prototype.initialize.call(this, options);
            this._update_data();
            return this.connect(this.properties.geojson.change, function () {
                return _this._update_data();
            });
        };
        GeoJSONDataSource.prototype._update_data = function () {
            return this.data = this.geojson_to_column_data();
        };
        GeoJSONDataSource.prototype._get_new_list_array = function (length) {
            var i, k, ref, results;
            results = [];
            for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                results.push([]);
            }
            return results;
        };
        GeoJSONDataSource.prototype._get_new_nan_array = function (length) {
            var i, k, ref, results;
            results = [];
            for (i = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                results.push(0 / 0);
            }
            return results;
        };
        GeoJSONDataSource.prototype._flatten_function = function (accumulator, currentItem) {
            return accumulator.concat([[
                    0 / 0,
                    0 / 0,
                    0 / 0
                ]]).concat(currentItem);
        };
        GeoJSONDataSource.prototype._add_properties = function (item, data, i, item_count) {
            var property, results;
            results = [];
            for (property in item.properties) {
                if (!data.hasOwnProperty(property)) {
                    data[property] = this._get_new_nan_array(item_count);
                }
                results.push(data[property][i] = item.properties[property]);
            }
            return results;
        };
        GeoJSONDataSource.prototype._add_geometry = function (geometry, data, i) {
            var coord_list, coords, exterior_ring, exterior_rings, flattened_coord_list, j, k, l, len, len1, len2, len3, len4, m, n, o, polygon, ref, ref1, ref2, ref3, ref4, ref5, results, results1, results2, results3;
            switch (geometry.type) {
            case 'Point':
                coords = geometry.coordinates;
                data.x[i] = coords[0];
                data.y[i] = coords[1];
                return data.z[i] = (ref = coords[2]) != null ? ref : 0 / 0;
            case 'LineString':
                coord_list = geometry.coordinates;
                results = [];
                for (j = k = 0, len = coord_list.length; k < len; j = ++k) {
                    coords = coord_list[j];
                    data.xs[i][j] = coords[0];
                    data.ys[i][j] = coords[1];
                    results.push(data.zs[i][j] = (ref1 = coords[2]) != null ? ref1 : 0 / 0);
                }
                return results;
                break;
            case 'Polygon':
                if (geometry.coordinates.length > 1) {
                    logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');
                }
                exterior_ring = geometry.coordinates[0];
                results1 = [];
                for (j = l = 0, len1 = exterior_ring.length; l < len1; j = ++l) {
                    coords = exterior_ring[j];
                    data.xs[i][j] = coords[0];
                    data.ys[i][j] = coords[1];
                    results1.push(data.zs[i][j] = (ref2 = coords[2]) != null ? ref2 : 0 / 0);
                }
                return results1;
                break;
            case 'MultiPoint':
                return logging_1.logger.warn('MultiPoint not supported in Bokeh');
            case 'MultiLineString':
                flattened_coord_list = geometry.coordinates.reduce(this._flatten_function);
                results2 = [];
                for (j = m = 0, len2 = flattened_coord_list.length; m < len2; j = ++m) {
                    coords = flattened_coord_list[j];
                    data.xs[i][j] = coords[0];
                    data.ys[i][j] = coords[1];
                    results2.push(data.zs[i][j] = (ref3 = coords[2]) != null ? ref3 : 0 / 0);
                }
                return results2;
                break;
            case 'MultiPolygon':
                exterior_rings = [];
                ref4 = geometry.coordinates;
                for (n = 0, len3 = ref4.length; n < len3; n++) {
                    polygon = ref4[n];
                    if (polygon.length > 1) {
                        logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');
                    }
                    exterior_rings.push(polygon[0]);
                }
                flattened_coord_list = exterior_rings.reduce(this._flatten_function);
                results3 = [];
                for (j = o = 0, len4 = flattened_coord_list.length; o < len4; j = ++o) {
                    coords = flattened_coord_list[j];
                    data.xs[i][j] = coords[0];
                    data.ys[i][j] = coords[1];
                    results3.push(data.zs[i][j] = (ref5 = coords[2]) != null ? ref5 : 0 / 0);
                }
                return results3;
                break;
            default:
                throw new Error('Invalid type ' + geometry.type);
            }
        };
        GeoJSONDataSource.prototype._get_items_length = function (items) {
            var count, g, geometry, i, item, j, k, l, len, len1, ref;
            count = 0;
            for (i = k = 0, len = items.length; k < len; i = ++k) {
                item = items[i];
                geometry = item.type === 'Feature' ? item.geometry : item;
                if (geometry.type === 'GeometryCollection') {
                    ref = geometry.geometries;
                    for (j = l = 0, len1 = ref.length; l < len1; j = ++l) {
                        g = ref[j];
                        count += 1;
                    }
                } else {
                    count += 1;
                }
            }
            return count;
        };
        GeoJSONDataSource.prototype.geojson_to_column_data = function () {
            var arr_index, data, g, geojson, geometry, i, item, item_count, items, j, k, l, len, len1, ref, ref1;
            geojson = JSON.parse(this.geojson);
            if ((ref = geojson.type) !== 'GeometryCollection' && ref !== 'FeatureCollection') {
                throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');
            }
            if (geojson.type === 'GeometryCollection') {
                if (geojson.geometries == null) {
                    throw new Error('No geometries found in GeometryCollection');
                }
                if (geojson.geometries.length === 0) {
                    throw new Error('geojson.geometries must have one or more items');
                }
                items = geojson.geometries;
            }
            if (geojson.type === 'FeatureCollection') {
                if (geojson.features == null) {
                    throw new Error('No features found in FeaturesCollection');
                }
                if (geojson.features.length === 0) {
                    throw new Error('geojson.features must have one or more items');
                }
                items = geojson.features;
            }
            item_count = this._get_items_length(items);
            data = {
                'x': this._get_new_nan_array(item_count),
                'y': this._get_new_nan_array(item_count),
                'z': this._get_new_nan_array(item_count),
                'xs': this._get_new_list_array(item_count),
                'ys': this._get_new_list_array(item_count),
                'zs': this._get_new_list_array(item_count)
            };
            arr_index = 0;
            for (i = k = 0, len = items.length; k < len; i = ++k) {
                item = items[i];
                geometry = item.type === 'Feature' ? item.geometry : item;
                if (geometry.type === 'GeometryCollection') {
                    ref1 = geometry.geometries;
                    for (j = l = 0, len1 = ref1.length; l < len1; j = ++l) {
                        g = ref1[j];
                        this._add_geometry(g, data, arr_index);
                        if (item.type === 'Feature') {
                            this._add_properties(item, data, arr_index, item_count);
                        }
                        arr_index += 1;
                    }
                } else {
                    // Now populate based on Geometry type
                    this._add_geometry(geometry, data, arr_index);
                    if (item.type === 'Feature') {
                        this._add_properties(item, data, arr_index, item_count);
                    }
                    arr_index += 1;
                }
            }
            return data;
        };
        return GeoJSONDataSource;
    }(columnar_data_source_1.ColumnarDataSource);
    exports.GeoJSONDataSource = GeoJSONDataSource;
    ;
    GeoJSONDataSource.prototype.type = 'GeoJSONDataSource';
    GeoJSONDataSource.define({
        geojson: [p.Any]    // TODO (bev)
    });
    GeoJSONDataSource.internal({
        data: [
            p.Any,
            {}
        ]
    });    
},
/*models/sources/index*/
function _(require, module, exports) {
    var ajax_data_source_1 = require(171    /* ./ajax_data_source */);
    exports.AjaxDataSource = ajax_data_source_1.AjaxDataSource;
    var column_data_source_1 = require(173    /* ./column_data_source */);
    exports.ColumnDataSource = column_data_source_1.ColumnDataSource;
    var columnar_data_source_1 = require(174    /* ./columnar_data_source */);
    exports.ColumnarDataSource = columnar_data_source_1.ColumnarDataSource;
    var cds_view_1 = require(172    /* ./cds_view */);
    exports.CDSView = cds_view_1.CDSView;
    var data_source_1 = require(175    /* ./data_source */);
    exports.DataSource = data_source_1.DataSource;
    var geojson_data_source_1 = require(176    /* ./geojson_data_source */);
    exports.GeoJSONDataSource = geojson_data_source_1.GeoJSONDataSource;
    var remote_data_source_1 = require(178    /* ./remote_data_source */);
    exports.RemoteDataSource = remote_data_source_1.RemoteDataSource;    
},
/*models/sources/remote_data_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var column_data_source_1 = require(173    /* ./column_data_source */);
    var p = require(15    /* core/properties */);
    var RemoteDataSource = function (_super) {
        tslib_1.__extends(RemoteDataSource, _super);
        function RemoteDataSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RemoteDataSource;
    }(column_data_source_1.ColumnDataSource);
    exports.RemoteDataSource = RemoteDataSource;
    ;
    RemoteDataSource.prototype.type = 'RemoteDataSource';
    RemoteDataSource.define({
        data_url: [p.String],
        polling_interval: [p.Number]
    });    
},
/*models/tickers/adaptive_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var continuous_ticker_1 = require(183    /* ./continuous_ticker */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    // Forces a number x into a specified range [min_val, max_val].
    function clamp(x, min_val, max_val) {
        return Math.max(min_val, Math.min(max_val, x));
    }
    // A log function with an optional base.
    function log(x, base) {
        if (base === void 0) {
            base = Math.E;
        }
        return Math.log(x) / Math.log(base);
    }
    // This Ticker produces nice round ticks at any magnitude.
    // AdaptiveTicker([1, 2, 5]) will choose the best tick interval from the
    // following:
    // ..., 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, ...
    var AdaptiveTicker = function (_super) {
        tslib_1.__extends(AdaptiveTicker, _super);
        function AdaptiveTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // These arguments control the range of possible intervals.  The interval I
        // returned by get_interval() will be the one that most closely matches the
        // desired number of ticks, subject to the following constraints:
        // I = (M * B^N), where
        // M is a member of mantissas,
        // B is base,
        // and N is an integer;
        // and min_interval <= I <= max_interval.
        AdaptiveTicker.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            var prefix_mantissa = array_1.nth(this.mantissas, -1) / this.base;
            var suffix_mantissa = array_1.nth(this.mantissas, 0) * this.base;
            this.extended_mantissas = [prefix_mantissa].concat(this.mantissas, [suffix_mantissa]);
            this.base_factor = this.get_min_interval() === 0 ? 1 : this.get_min_interval();
        };
        AdaptiveTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {
            var data_range = data_high - data_low;
            var ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
            var interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));
            var ideal_magnitude = Math.pow(this.base, interval_exponent) * this.base_factor;
            // An untested optimization.
            //   const ideal_mantissa = ideal_interval / ideal_magnitude
            //   index = sortedIndex(this.extended_mantissas, ideal_mantissa)
            //   candidate_mantissas = this.extended_mantissas[index..index + 1]
            var candidate_mantissas = this.extended_mantissas;
            var errors = candidate_mantissas.map(function (mantissa) {
                return Math.abs(desired_n_ticks - data_range / (mantissa * ideal_magnitude));
            });
            var best_mantissa = candidate_mantissas[array_1.argmin(errors)];
            var interval = best_mantissa * ideal_magnitude;
            return clamp(interval, this.get_min_interval(), this.get_max_interval());
        };
        return AdaptiveTicker;
    }(continuous_ticker_1.ContinuousTicker);
    exports.AdaptiveTicker = AdaptiveTicker;
    AdaptiveTicker.prototype.type = 'AdaptiveTicker';
    AdaptiveTicker.define({
        base: [
            p.Number,
            10
        ],
        mantissas: [
            p.Array,
            [
                1,
                2,
                5
            ]
        ],
        min_interval: [
            p.Number,
            0
        ],
        max_interval: [p.Number]
    });    
},
/*models/tickers/basic_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var adaptive_ticker_1 = require(179    /* ./adaptive_ticker */);
    var BasicTicker = function (_super) {
        tslib_1.__extends(BasicTicker, _super);
        function BasicTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return BasicTicker;
    }(adaptive_ticker_1.AdaptiveTicker);
    exports.BasicTicker = BasicTicker;
    BasicTicker.prototype.type = 'BasicTicker';    
},
/*models/tickers/categorical_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var ticker_1 = require(192    /* ./ticker */);
    var CategoricalTicker = function (_super) {
        tslib_1.__extends(CategoricalTicker, _super);
        function CategoricalTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CategoricalTicker.prototype.get_ticks = function (start, end, range, _cross_loc, _) {
            var majors = this._collect(range.factors, range, start, end);
            var tops = this._collect(range.tops || [], range, start, end);
            var mids = this._collect(range.mids || [], range, start, end);
            return {
                major: majors,
                minor: [],
                tops: tops,
                mids: mids
            };
        };
        CategoricalTicker.prototype._collect = function (factors, range, start, end) {
            var result = [];
            for (var _i = 0, factors_1 = factors; _i < factors_1.length; _i++) {
                var factor = factors_1[_i];
                var coord = range.synthetic(factor);
                if (coord > start && coord < end)
                    result.push(factor);
            }
            return result;
        };
        return CategoricalTicker;
    }(ticker_1.Ticker);
    exports.CategoricalTicker = CategoricalTicker;
    CategoricalTicker.prototype.type = 'CategoricalTicker';    
},
/*models/tickers/composite_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var continuous_ticker_1 = require(183    /* ./continuous_ticker */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var object_1 = require(30    /* core/util/object */);
    // This Ticker takes a collection of Tickers and picks the one most appropriate
    // for a given range.
    var CompositeTicker = function (_super) {
        tslib_1.__extends(CompositeTicker, _super);
        function CompositeTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(CompositeTicker.prototype, 'min_intervals', {
            // The tickers should be in order of increasing interval size; specifically,
            // if S comes before T, then it should be the case that
            // S.get_max_interval() < T.get_min_interval().
            // FIXME Enforce this automatically.
            get: function () {
                return this.tickers.map(function (ticker) {
                    return ticker.get_min_interval();
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeTicker.prototype, 'max_intervals', {
            get: function () {
                return this.tickers.map(function (ticker) {
                    return ticker.get_max_interval();
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeTicker.prototype, 'min_interval', {
            get: function () {
                return this.min_intervals[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompositeTicker.prototype, 'max_interval', {
            get: function () {
                return this.max_intervals[0];
            },
            enumerable: true,
            configurable: true
        });
        CompositeTicker.prototype.get_best_ticker = function (data_low, data_high, desired_n_ticks) {
            var data_range = data_high - data_low;
            var ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
            var ticker_ndxs = [
                array_1.sortedIndex(this.min_intervals, ideal_interval) - 1,
                array_1.sortedIndex(this.max_intervals, ideal_interval)
            ];
            var intervals = [
                this.min_intervals[ticker_ndxs[0]],
                this.max_intervals[ticker_ndxs[1]]
            ];
            var errors = intervals.map(function (interval) {
                return Math.abs(desired_n_ticks - data_range / interval);
            });
            var best_ticker;
            if (object_1.isEmpty(errors.filter(function (e) {
                    return !isNaN(e);
                }))) {
                // this can happen if the data isn't loaded yet, we just default to the first scale
                best_ticker = this.tickers[0];
            } else {
                var best_index = array_1.argmin(errors);
                var best_ticker_ndx = ticker_ndxs[best_index];
                best_ticker = this.tickers[best_ticker_ndx];
            }
            return best_ticker;
        };
        CompositeTicker.prototype.get_interval = function (data_low, data_high, desired_n_ticks) {
            var best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
            return best_ticker.get_interval(data_low, data_high, desired_n_ticks);
        };
        CompositeTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
            var best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
            return best_ticker.get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks);
        };
        return CompositeTicker;
    }(continuous_ticker_1.ContinuousTicker);
    exports.CompositeTicker = CompositeTicker;
    CompositeTicker.prototype.type = 'CompositeTicker';
    CompositeTicker.define({
        tickers: [
            p.Array,
            []
        ]
    });    
},
/*models/tickers/continuous_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var ticker_1 = require(192    /* ./ticker */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var types_1 = require(42    /* core/util/types */);
    // The base class for all Ticker objects.  It needs to be subclassed before
    // being used.  The simplest subclass is SingleIntervalTicker.
    //
    // The main value of a Ticker is its get_ticks() method, which takes a min and
    // max value and (optionally) a desired number of ticks, and returns an array
    // of approximately that many ticks, evenly spaced, with nice round values,
    // within that range.
    //
    // Different Tickers are suited to different types of data or different
    // magnitudes.  To make it possible to select Tickers programmatically, they
    // also support some additional methods: get_interval(), get_min_interval(),
    // and get_max_interval().
    var ContinuousTicker = function (_super) {
        tslib_1.__extends(ContinuousTicker, _super);
        function ContinuousTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ContinuousTicker.prototype.get_ticks = function (data_low, data_high, _range, cross_loc, _) {
            return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);
        };
        // The version of get_ticks() that does the work (and the version that
        // should be overridden in subclasses).
        ContinuousTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, _cross_loc, desired_n_ticks) {
            var interval = this.get_interval(data_low, data_high, desired_n_ticks);
            var start_factor = Math.floor(data_low / interval);
            var end_factor = Math.ceil(data_high / interval);
            var factors;
            if (types_1.isStrictNaN(start_factor) || types_1.isStrictNaN(end_factor))
                factors = [];
            else
                factors = array_1.range(start_factor, end_factor + 1);
            var ticks = factors.map(function (factor) {
                return factor * interval;
            }).filter(function (tick) {
                return data_low <= tick && tick <= data_high;
            });
            var num_minor_ticks = this.num_minor_ticks;
            var minor_ticks = [];
            if (num_minor_ticks > 0 && ticks.length > 0) {
                var minor_interval_1 = interval / num_minor_ticks;
                var minor_offsets = array_1.range(0, num_minor_ticks).map(function (i) {
                    return i * minor_interval_1;
                });
                for (var _i = 0, _a = minor_offsets.slice(1); _i < _a.length; _i++) {
                    var x = _a[_i];
                    minor_ticks.push(ticks[0] - x);
                }
                for (var _b = 0, ticks_1 = ticks; _b < ticks_1.length; _b++) {
                    var tick = ticks_1[_b];
                    for (var _c = 0, minor_offsets_1 = minor_offsets; _c < minor_offsets_1.length; _c++) {
                        var x = minor_offsets_1[_c];
                        minor_ticks.push(tick + x);
                    }
                }
            }
            return {
                major: ticks,
                minor: minor_ticks
            };
        };
        // Returns the smallest interval that can be returned by get_interval().
        ContinuousTicker.prototype.get_min_interval = function () {
            return this.min_interval;
        };
        // Returns the largest interval that can be returned by get_interval().
        ContinuousTicker.prototype.get_max_interval = function () {
            return this.max_interval != null ? this.max_interval : Infinity;
        };
        // Returns the interval size that would produce exactly the number of
        // desired ticks.  (In general we won't use exactly this interval, because
        // we want the ticks to be round numbers.)
        ContinuousTicker.prototype.get_ideal_interval = function (data_low, data_high, desired_n_ticks) {
            var data_range = data_high - data_low;
            return data_range / desired_n_ticks;
        };
        return ContinuousTicker;
    }(ticker_1.Ticker);
    exports.ContinuousTicker = ContinuousTicker;
    ContinuousTicker.prototype.type = 'ContinuousTicker';
    ContinuousTicker.define({
        num_minor_ticks: [
            p.Number,
            5
        ],
        desired_num_ticks: [
            p.Number,
            6
        ]
    });    
},
/*models/tickers/datetime_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var array_1 = require(22    /* core/util/array */);
    var adaptive_ticker_1 = require(179    /* ./adaptive_ticker */);
    var composite_ticker_1 = require(182    /* ./composite_ticker */);
    var days_ticker_1 = require(185    /* ./days_ticker */);
    var months_ticker_1 = require(190    /* ./months_ticker */);
    var years_ticker_1 = require(194    /* ./years_ticker */);
    var util_1 = require(193    /* ./util */);
    // This is a decent ticker for time data (in milliseconds).
    // It could certainly be improved:
    // FIXME There should probably be a special ticker for years.
    // FIXME Some of the adaptive tickers probably have too many mantissas, which
    // leads to too-frequent tick transitions.
    var DatetimeTicker = function (_super) {
        tslib_1.__extends(DatetimeTicker, _super);
        function DatetimeTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DatetimeTicker;
    }(composite_ticker_1.CompositeTicker);
    exports.DatetimeTicker = DatetimeTicker;
    DatetimeTicker.prototype.type = 'DatetimeTicker';
    DatetimeTicker.override({
        num_minor_ticks: 0,
        tickers: function () {
            return [
                // Sub-second.
                new adaptive_ticker_1.AdaptiveTicker({
                    mantissas: [
                        1,
                        2,
                        5
                    ],
                    base: 10,
                    min_interval: 0,
                    max_interval: 500 * util_1.ONE_MILLI,
                    num_minor_ticks: 0
                }),
                // Seconds, minutes.
                new adaptive_ticker_1.AdaptiveTicker({
                    mantissas: [
                        1,
                        2,
                        5,
                        10,
                        15,
                        20,
                        30
                    ],
                    base: 60,
                    min_interval: util_1.ONE_SECOND,
                    max_interval: 30 * util_1.ONE_MINUTE,
                    num_minor_ticks: 0
                }),
                // Hours.
                new adaptive_ticker_1.AdaptiveTicker({
                    mantissas: [
                        1,
                        2,
                        4,
                        6,
                        8,
                        12
                    ],
                    base: 24,
                    min_interval: util_1.ONE_HOUR,
                    max_interval: 12 * util_1.ONE_HOUR,
                    num_minor_ticks: 0
                }),
                // Days.
                new days_ticker_1.DaysTicker({ days: array_1.range(1, 32) }),
                new days_ticker_1.DaysTicker({ days: array_1.range(1, 31, 3) }),
                new days_ticker_1.DaysTicker({
                    days: [
                        1,
                        8,
                        15,
                        22
                    ]
                }),
                new days_ticker_1.DaysTicker({
                    days: [
                        1,
                        15
                    ]
                }),
                // Months.
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 1) }),
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 2) }),
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 4) }),
                new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 6) }),
                // Years
                new years_ticker_1.YearsTicker({})
            ];
        }
    });    
},
/*models/tickers/days_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var single_interval_ticker_1 = require(191    /* ./single_interval_ticker */);
    var util_1 = require(193    /* ./util */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    // Given a start and end time in millis, returns the shortest array of
    // consecutive months (as Dates) that surrounds both times.
    function date_range_by_month(start_time, end_time) {
        var start_date = util_1.last_month_no_later_than(new Date(start_time));
        var end_date = util_1.last_month_no_later_than(new Date(end_time));
        // XXX This is not a reliable technique in general, but it should be
        // safe when the day of the month is 1.  (The problem case is this:
        // Mar 31 -> Apr 31, which becomes May 1.)
        end_date.setUTCMonth(end_date.getUTCMonth() + 1);
        var dates = [];
        var date = start_date;
        while (true) {
            dates.push(util_1.copy_date(date));
            date.setUTCMonth(date.getUTCMonth() + 1);
            if (date > end_date)
                break;
        }
        return dates;
    }
    // A DaysTicker produces ticks from a fixed subset of calendar days.
    // E.g., DaysTicker([1, 15]) produces ticks on the 1st and 15th days of each
    // month.
    var DaysTicker = function (_super) {
        tslib_1.__extends(DaysTicker, _super);
        function DaysTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DaysTicker.prototype.initialize = function (attrs, options) {
            attrs.num_minor_ticks = 0;
            _super.prototype.initialize.call(this, attrs, options);
            var days = this.days;
            if (days.length > 1)
                this.interval = (days[1] - days[0]) * util_1.ONE_DAY;
            else
                this.interval = 31 * util_1.ONE_DAY;
        };
        DaysTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, _cross_loc, _desired_n_ticks) {
            var month_dates = date_range_by_month(data_low, data_high);
            var days = this.days;
            var days_of_month = function (month_date, interval) {
                var dates = [];
                for (var _i = 0, days_1 = days; _i < days_1.length; _i++) {
                    var day = days_1[_i];
                    var day_date = util_1.copy_date(month_date);
                    day_date.setUTCDate(day);
                    // We can't use all of the values in this.days, because they may not
                    // fall within the current month.  In fact, if, e.g., our month is 28 days
                    // and we're marking every third day, we don't want day 28 to show up
                    // because it'll be right next to the 1st of the next month.  So we
                    // make sure we have a bit of room before we include a day.
                    var future_date = new Date(day_date.getTime() + interval / 2);
                    if (future_date.getUTCMonth() == month_date.getUTCMonth())
                        dates.push(day_date);
                }
                return dates;
            };
            var interval = this.interval;
            var day_dates = array_1.concat(month_dates.map(function (date) {
                return days_of_month(date, interval);
            }));
            var all_ticks = day_dates.map(function (day_date) {
                return day_date.getTime();
            });
            // FIXME Since the ticks are sorted, this could be done more efficiently.
            var ticks_in_range = all_ticks.filter(function (tick) {
                return data_low <= tick && tick <= data_high;
            });
            return {
                major: ticks_in_range,
                minor: []
            };
        };
        return DaysTicker;
    }(single_interval_ticker_1.SingleIntervalTicker);
    exports.DaysTicker = DaysTicker;
    DaysTicker.prototype.type = 'DaysTicker';
    DaysTicker.define({
        days: [
            p.Array,
            []
        ]
    });    
},
/*models/tickers/fixed_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var continuous_ticker_1 = require(183    /* ./continuous_ticker */);
    var p = require(15    /* core/properties */);
    var FixedTicker = function (_super) {
        tslib_1.__extends(FixedTicker, _super);
        function FixedTicker() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.min_interval = 0;
            _this.max_interval = 0;
            return _this;    //
        }
        FixedTicker.prototype.get_ticks_no_defaults = function (_data_low, _data_high, _cross_loc, _desired_n_ticks) {
            return {
                major: this.ticks,
                minor: []
            };
        };
        // XXX: whatever, because FixedTicker needs to fullfill the interface somehow
        FixedTicker.prototype.get_interval = function (_data_low, _data_high, _desired_n_ticks) {
            return 0;
        };
        return FixedTicker;
    }(continuous_ticker_1.ContinuousTicker);
    exports.FixedTicker = FixedTicker;
    FixedTicker.prototype.type = 'FixedTicker';
    FixedTicker.define({
        ticks: [
            p.Array,
            []
        ]
    });    
},
/*models/tickers/index*/
function _(require, module, exports) {
    var adaptive_ticker_1 = require(179    /* ./adaptive_ticker */);
    exports.AdaptiveTicker = adaptive_ticker_1.AdaptiveTicker;
    var basic_ticker_1 = require(180    /* ./basic_ticker */);
    exports.BasicTicker = basic_ticker_1.BasicTicker;
    var categorical_ticker_1 = require(181    /* ./categorical_ticker */);
    exports.CategoricalTicker = categorical_ticker_1.CategoricalTicker;
    var composite_ticker_1 = require(182    /* ./composite_ticker */);
    exports.CompositeTicker = composite_ticker_1.CompositeTicker;
    var continuous_ticker_1 = require(183    /* ./continuous_ticker */);
    exports.ContinuousTicker = continuous_ticker_1.ContinuousTicker;
    var datetime_ticker_1 = require(184    /* ./datetime_ticker */);
    exports.DatetimeTicker = datetime_ticker_1.DatetimeTicker;
    var days_ticker_1 = require(185    /* ./days_ticker */);
    exports.DaysTicker = days_ticker_1.DaysTicker;
    var fixed_ticker_1 = require(186    /* ./fixed_ticker */);
    exports.FixedTicker = fixed_ticker_1.FixedTicker;
    var log_ticker_1 = require(188    /* ./log_ticker */);
    exports.LogTicker = log_ticker_1.LogTicker;
    var mercator_ticker_1 = require(189    /* ./mercator_ticker */);
    exports.MercatorTicker = mercator_ticker_1.MercatorTicker;
    var months_ticker_1 = require(190    /* ./months_ticker */);
    exports.MonthsTicker = months_ticker_1.MonthsTicker;
    var single_interval_ticker_1 = require(191    /* ./single_interval_ticker */);
    exports.SingleIntervalTicker = single_interval_ticker_1.SingleIntervalTicker;
    var ticker_1 = require(192    /* ./ticker */);
    exports.Ticker = ticker_1.Ticker;
    var years_ticker_1 = require(194    /* ./years_ticker */);
    exports.YearsTicker = years_ticker_1.YearsTicker;    
},
/*models/tickers/log_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var array_1 = require(22    /* core/util/array */);
    var adaptive_ticker_1 = require(179    /* ./adaptive_ticker */);
    var LogTicker = function (_super) {
        tslib_1.__extends(LogTicker, _super);
        function LogTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LogTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, _cross_loc, desired_n_ticks) {
            var num_minor_ticks = this.num_minor_ticks;
            var minor_ticks = [];
            var base = this.base;
            var log_low = Math.log(data_low) / Math.log(base);
            var log_high = Math.log(data_high) / Math.log(base);
            var log_interval = log_high - log_low;
            var ticks;
            if (!isFinite(log_interval)) {
                ticks = [];
            } else if (log_interval < 2) {
                var interval_1 = this.get_interval(data_low, data_high, desired_n_ticks);
                var start_factor = Math.floor(data_low / interval_1);
                var end_factor = Math.ceil(data_high / interval_1);
                ticks = array_1.range(start_factor, end_factor + 1).filter(function (factor) {
                    return factor != 0;
                }).map(function (factor) {
                    return factor * interval_1;
                }).filter(function (tick) {
                    return data_low <= tick && tick <= data_high;
                });
                if (num_minor_ticks > 0 && ticks.length > 0) {
                    var minor_interval_1 = interval_1 / num_minor_ticks;
                    var minor_offsets = array_1.range(0, num_minor_ticks).map(function (i) {
                        return i * minor_interval_1;
                    });
                    for (var _i = 0, _a = minor_offsets.slice(1); _i < _a.length; _i++) {
                        var x = _a[_i];
                        minor_ticks.push(ticks[0] - x);
                    }
                    for (var _b = 0, ticks_1 = ticks; _b < ticks_1.length; _b++) {
                        var tick = ticks_1[_b];
                        for (var _c = 0, minor_offsets_1 = minor_offsets; _c < minor_offsets_1.length; _c++) {
                            var x = minor_offsets_1[_c];
                            minor_ticks.push(tick + x);
                        }
                    }
                }
            } else {
                var startlog = Math.ceil(log_low * 0.999999);
                var endlog = Math.floor(log_high * 1.000001);
                var interval = Math.ceil((endlog - startlog) / 9);
                ticks = array_1.range(startlog, endlog + 1, interval).map(function (i) {
                    return Math.pow(base, i);
                }).filter(function (tick) {
                    return data_low <= tick && tick <= data_high;
                });
                if (num_minor_ticks > 0 && ticks.length > 0) {
                    var minor_interval_2 = Math.pow(base, interval) / num_minor_ticks;
                    var minor_offsets = array_1.range(1, num_minor_ticks + 1).map(function (i) {
                        return i * minor_interval_2;
                    });
                    for (var _d = 0, minor_offsets_2 = minor_offsets; _d < minor_offsets_2.length; _d++) {
                        var x = minor_offsets_2[_d];
                        minor_ticks.push(ticks[0] / x);
                    }
                    minor_ticks.push(ticks[0]);
                    for (var _e = 0, ticks_2 = ticks; _e < ticks_2.length; _e++) {
                        var tick = ticks_2[_e];
                        for (var _f = 0, minor_offsets_3 = minor_offsets; _f < minor_offsets_3.length; _f++) {
                            var x = minor_offsets_3[_f];
                            minor_ticks.push(tick * x);
                        }
                    }
                }
            }
            return {
                major: ticks,
                minor: minor_ticks
            };
        };
        return LogTicker;
    }(adaptive_ticker_1.AdaptiveTicker);
    exports.LogTicker = LogTicker;
    LogTicker.prototype.type = 'LogTicker';
    LogTicker.override({
        mantissas: [
            1,
            5
        ]
    });    
},
/*models/tickers/mercator_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var basic_ticker_1 = require(180    /* ./basic_ticker */);
    var p = require(15    /* core/properties */);
    var proj4_1 = require(31    /* core/util/proj4 */);
    var MercatorTicker = function (_super) {
        tslib_1.__extends(MercatorTicker, _super);
        function MercatorTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MercatorTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
            if (this.dimension == null) {
                throw new Error('MercatorTicker.dimension not configured');
            }
            _a = proj4_1.clip_mercator(data_low, data_high, this.dimension), data_low = _a[0], data_high = _a[1];
            var proj_low, proj_high, proj_cross_loc;
            if (this.dimension === 'lon') {
                _b = proj4_1.proj4(proj4_1.mercator).inverse([
                    data_low,
                    cross_loc
                ]), proj_low = _b[0], proj_cross_loc = _b[1];
                _c = proj4_1.proj4(proj4_1.mercator).inverse([
                    data_high,
                    cross_loc
                ]), proj_high = _c[0], proj_cross_loc = _c[1];
            } else {
                _d = proj4_1.proj4(proj4_1.mercator).inverse([
                    cross_loc,
                    data_low
                ]), proj_cross_loc = _d[0], proj_low = _d[1];
                _e = proj4_1.proj4(proj4_1.mercator).inverse([
                    cross_loc,
                    data_high
                ]), proj_cross_loc = _e[0], proj_high = _e[1];
            }
            var proj_ticks = _super.prototype.get_ticks_no_defaults.call(this, proj_low, proj_high, cross_loc, desired_n_ticks);
            var major = [];
            var minor = [];
            if (this.dimension === 'lon') {
                for (var _i = 0, _f = proj_ticks.major; _i < _f.length; _i++) {
                    var tick = _f[_i];
                    if (proj4_1.in_bounds(tick, 'lon')) {
                        var lon = proj4_1.proj4(proj4_1.mercator).forward([
                            tick,
                            proj_cross_loc
                        ])[0];
                        major.push(lon);
                    }
                }
                for (var _g = 0, _h = proj_ticks.minor; _g < _h.length; _g++) {
                    var tick = _h[_g];
                    if (proj4_1.in_bounds(tick, 'lon')) {
                        var lon = proj4_1.proj4(proj4_1.mercator).forward([
                            tick,
                            proj_cross_loc
                        ])[0];
                        minor.push(lon);
                    }
                }
            } else {
                for (var _j = 0, _k = proj_ticks.major; _j < _k.length; _j++) {
                    var tick = _k[_j];
                    if (proj4_1.in_bounds(tick, 'lat')) {
                        var _l = proj4_1.proj4(proj4_1.mercator).forward([
                                proj_cross_loc,
                                tick
                            ]), lat = _l[1];
                        major.push(lat);
                    }
                }
                for (var _m = 0, _o = proj_ticks.minor; _m < _o.length; _m++) {
                    var tick = _o[_m];
                    if (proj4_1.in_bounds(tick, 'lat')) {
                        var _p = proj4_1.proj4(proj4_1.mercator).forward([
                                proj_cross_loc,
                                tick
                            ]), lat = _p[1];
                        minor.push(lat);
                    }
                }
            }
            return {
                major: major,
                minor: minor
            };
            var _a, _b, _c, _d, _e;
        };
        return MercatorTicker;
    }(basic_ticker_1.BasicTicker);
    exports.MercatorTicker = MercatorTicker;
    MercatorTicker.prototype.type = 'MercatorTicker';
    MercatorTicker.define({ dimension: [p.LatLon] });    
},
/*models/tickers/months_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var single_interval_ticker_1 = require(191    /* ./single_interval_ticker */);
    var util_1 = require(193    /* ./util */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    // Given a start and end time in millis, returns the shortest array of
    // consecutive years (as Dates) that surrounds both times.
    function date_range_by_year(start_time, end_time) {
        var start_date = util_1.last_year_no_later_than(new Date(start_time));
        var end_date = util_1.last_year_no_later_than(new Date(end_time));
        end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);
        var dates = [];
        var date = start_date;
        while (true) {
            dates.push(util_1.copy_date(date));
            date.setUTCFullYear(date.getUTCFullYear() + 1);
            if (date > end_date)
                break;
        }
        return dates;
    }
    // A MonthsTicker produces ticks from a fixed subset of months of the year.
    // E.g., MonthsTicker([0, 3, 6, 9]) produces ticks of the 1st of January,
    // April, July, and October of each year.
    var MonthsTicker = function (_super) {
        tslib_1.__extends(MonthsTicker, _super);
        function MonthsTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MonthsTicker.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            var months = this.months;
            if (months.length > 1)
                this.interval = (months[1] - months[0]) * util_1.ONE_MONTH;
            else
                this.interval = 12 * util_1.ONE_MONTH;
        };
        MonthsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, _cross_loc, _desired_n_ticks) {
            var year_dates = date_range_by_year(data_low, data_high);
            var months = this.months;
            var months_of_year = function (year_date) {
                return months.map(function (month) {
                    var month_date = util_1.copy_date(year_date);
                    month_date.setUTCMonth(month);
                    return month_date;
                });
            };
            var month_dates = array_1.concat(year_dates.map(months_of_year));
            var all_ticks = month_dates.map(function (month_date) {
                return month_date.getTime();
            });
            var ticks_in_range = all_ticks.filter(function (tick) {
                return data_low <= tick && tick <= data_high;
            });
            return {
                major: ticks_in_range,
                minor: []
            };
        };
        return MonthsTicker;
    }(single_interval_ticker_1.SingleIntervalTicker);
    exports.MonthsTicker = MonthsTicker;
    MonthsTicker.prototype.type = 'MonthsTicker';
    MonthsTicker.define({
        months: [
            p.Array,
            []
        ]
    });    
},
/*models/tickers/single_interval_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var continuous_ticker_1 = require(183    /* ./continuous_ticker */);
    var p = require(15    /* core/properties */);
    // The SingleIntervalTicker is a Ticker that always uses the same tick spacing,
    // regardless of the input range.  It's not very useful by itself, but can
    // be used as part of a CompositeTicker below.
    var SingleIntervalTicker = function (_super) {
        tslib_1.__extends(SingleIntervalTicker, _super);
        function SingleIntervalTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SingleIntervalTicker.prototype.get_interval = function (_data_low, _data_high, _n_desired_ticks) {
            return this.interval;
        };
        Object.defineProperty(SingleIntervalTicker.prototype, 'min_interval', {
            get: function () {
                return this.interval;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SingleIntervalTicker.prototype, 'max_interval', {
            get: function () {
                return this.interval;
            },
            enumerable: true,
            configurable: true
        });
        return SingleIntervalTicker;
    }(continuous_ticker_1.ContinuousTicker);
    exports.SingleIntervalTicker = SingleIntervalTicker;
    SingleIntervalTicker.prototype.type = 'SingleIntervalTicker';
    SingleIntervalTicker.define({ interval: [p.Number] });    
},
/*models/tickers/ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    // The base class for all Ticker objects.  It needs to be subclassed before
    // being used.  The simplest subclass is SingleIntervalTicker.
    //
    // The main value of a Ticker is its get_ticks() method, which takes a min and
    // max value and (optionally) a desired number of ticks, and returns an array
    // of approximately that many ticks, evenly spaced, with nice round values,
    // within that range.
    //
    // Different Tickers are suited to different types of data or different
    // magnitudes.  To make it possible to select Tickers programmatically, they
    // also support some additional methods: get_interval(), get_min_interval(),
    // and get_max_interval().
    var Ticker = function (_super) {
        tslib_1.__extends(Ticker, _super);
        function Ticker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Ticker;
    }(model_1.Model);
    exports.Ticker = Ticker;
    Ticker.prototype.type = 'Ticker';    
},
/*models/tickers/util*/
function _(require, module, exports) {
    // Some time constants, in milliseconds.
    exports.ONE_MILLI = 1;
    exports.ONE_SECOND = 1000;
    exports.ONE_MINUTE = 60 * exports.ONE_SECOND;
    exports.ONE_HOUR = 60 * exports.ONE_MINUTE;
    exports.ONE_DAY = 24 * exports.ONE_HOUR;
    exports.ONE_MONTH = 30 * exports.ONE_DAY;
    // An approximation, obviously.
    exports.ONE_YEAR = 365 * exports.ONE_DAY;
    // ---------------------------------------------------------------------------
    // Date/time utility functions
    // ---------------------------------------------------------------------------
    // Makes a copy of a date object.
    function copy_date(date) {
        return new Date(date.getTime());
    }
    exports.copy_date = copy_date;
    // Rounds a date down to the month.
    function last_month_no_later_than(date) {
        var new_date = copy_date(date);
        new_date.setUTCDate(1);
        new_date.setUTCHours(0);
        new_date.setUTCMinutes(0);
        new_date.setUTCSeconds(0);
        new_date.setUTCMilliseconds(0);
        return new_date;
    }
    exports.last_month_no_later_than = last_month_no_later_than;
    // Rounds a date down to the year.
    function last_year_no_later_than(date) {
        var new_date = last_month_no_later_than(date);
        new_date.setUTCMonth(0);
        return new_date;
    }
    exports.last_year_no_later_than = last_year_no_later_than;    
},
/*models/tickers/years_ticker*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var basic_ticker_1 = require(180    /* ./basic_ticker */);
    var single_interval_ticker_1 = require(191    /* ./single_interval_ticker */);
    var util_1 = require(193    /* ./util */);
    var YearsTicker = function (_super) {
        tslib_1.__extends(YearsTicker, _super);
        function YearsTicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        YearsTicker.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this.interval = util_1.ONE_YEAR;
            this.basic_ticker = new basic_ticker_1.BasicTicker({ num_minor_ticks: 0 });
        };
        YearsTicker.prototype.get_ticks_no_defaults = function (data_low, data_high, cross_loc, desired_n_ticks) {
            var start_year = util_1.last_year_no_later_than(new Date(data_low)).getUTCFullYear();
            var end_year = util_1.last_year_no_later_than(new Date(data_high)).getUTCFullYear();
            var years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, cross_loc, desired_n_ticks).major;
            var all_ticks = years.map(function (year) {
                return Date.UTC(year, 0, 1);
            });
            var ticks_in_range = all_ticks.filter(function (tick) {
                return data_low <= tick && tick <= data_high;
            });
            return {
                major: ticks_in_range,
                minor: []
            };
        };
        return YearsTicker;
    }(single_interval_ticker_1.SingleIntervalTicker);
    exports.YearsTicker = YearsTicker;
    YearsTicker.prototype.type = 'YearsTicker';    
},
/*models/tiles/bbox_tile_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var mercator_tile_source_1 = require(200    /* ./mercator_tile_source */);
    var p = require(15    /* core/properties */);
    var BBoxTileSource = function (_super) {
        tslib_1.__extends(BBoxTileSource, _super);
        function BBoxTileSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BBoxTileSource.prototype.get_image_url = function (x, y, z) {
            var image_url, xmax, xmin, ymax, ymin;
            image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
            if (this.use_latlon) {
                _a = this.get_tile_geographic_bounds(x, y, z), xmin = _a[0], ymin = _a[1], xmax = _a[2], ymax = _a[3];
            } else {
                _b = this.get_tile_meter_bounds(x, y, z), xmin = _b[0], ymin = _b[1], xmax = _b[2], ymax = _b[3];
            }
            return image_url.replace('{XMIN}', xmin).replace('{YMIN}', ymin).replace('{XMAX}', xmax).replace('{YMAX}', ymax);
            var _a, _b;
        };
        return BBoxTileSource;
    }(mercator_tile_source_1.MercatorTileSource);
    exports.BBoxTileSource = BBoxTileSource;
    ;
    BBoxTileSource.prototype.type = 'BBoxTileSource';
    BBoxTileSource.define({
        use_latlon: [
            p.Bool,
            false
        ]
    });    
},
/*models/tiles/dynamic_image_renderer*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var boundMethodCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new Error('Bound instance method accessed before binding');
        }
    };
    var renderer_1 = require(165    /* ../renderers/renderer */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    exports.DynamicImageView = function (_super) {
        tslib_1.__extends(DynamicImageView, _super);
        function DynamicImageView() {
            var _this = _super.apply(this, arguments) || this;
            _this._on_image_load = _this._on_image_load.bind(_this);
            _this._on_image_error = _this._on_image_error.bind(_this);
            return _this;
        }
        DynamicImageView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.change, function () {
                return this.request_render();
            });
        };
        DynamicImageView.prototype.get_extent = function () {
            return [
                this.x_range.start,
                this.y_range.start,
                this.x_range.end,
                this.y_range.end
            ];
        };
        DynamicImageView.prototype._set_data = function () {
            this.map_plot = this.plot_view.model.plot;
            this.map_canvas = this.plot_view.canvas_view.ctx;
            this.map_frame = this.plot_view.frame;
            this.x_range = this.map_plot.x_range;
            this.y_range = this.map_plot.y_range;
            this.lastImage = void 0;
            return this.extent = this.get_extent();
        };
        DynamicImageView.prototype._map_data = function () {
            return this.initial_extent = this.get_extent();
        };
        DynamicImageView.prototype._on_image_load = function (e) {
            var image_data;
            boundMethodCheck(this, DynamicImageView);
            image_data = e.target.image_data;
            image_data.img = e.target;
            image_data.loaded = true;
            this.lastImage = image_data;
            if (this.get_extent().join(':') === image_data.cache_key) {
                return this.request_render();
            }
        };
        DynamicImageView.prototype._on_image_error = function (e) {
            var image_data;
            boundMethodCheck(this, DynamicImageView);
            logging_1.logger.error('Error loading image: ' + e.target.src);
            image_data = e.target.image_data;
            return this.model.image_source.remove_image(image_data);
        };
        DynamicImageView.prototype._create_image = function (bounds) {
            var image;
            image = new Image();
            image.onload = this._on_image_load;
            image.onerror = this._on_image_error;
            image.alt = '';
            image.image_data = {
                bounds: bounds,
                loaded: false,
                cache_key: bounds.join(':')
            };
            this.model.image_source.add_image(image.image_data);
            image.src = this.model.image_source.get_image_url(bounds[0], bounds[1], bounds[2], bounds[3], Math.ceil(this.map_frame._height.value), Math.ceil(this.map_frame._width.value));
            return image;
        };
        DynamicImageView.prototype.render = function (ctx, indices, args) {
            var _this = this;
            var extent, image_obj;
            if (this.map_initialized == null) {
                this._set_data();
                this._map_data();
                this.map_initialized = true;
            }
            extent = this.get_extent();
            if (this.render_timer) {
                clearTimeout(this.render_timer);
            }
            image_obj = this.model.image_source.images[extent.join(':')];
            if (image_obj != null && image_obj.loaded) {
                this._draw_image(extent.join(':'));
                return;
            }
            if (this.lastImage != null) {
                this._draw_image(this.lastImage.cache_key);
            }
            if (image_obj == null) {
                return this.render_timer = setTimeout(function () {
                    return _this._create_image(extent);
                }, 125);
            }
        };
        DynamicImageView.prototype._draw_image = function (image_key) {
            var image_obj, sh, sw, sx, sxmax, sxmin, sy, symax, symin;
            image_obj = this.model.image_source.images[image_key];
            if (image_obj != null) {
                this.map_canvas.save();
                this._set_rect();
                this.map_canvas.globalAlpha = this.model.alpha;
                _a = this.plot_view.map_to_screen([image_obj.bounds[0]], [image_obj.bounds[3]]), sxmin = _a[0], symin = _a[1];
                _b = this.plot_view.map_to_screen([image_obj.bounds[2]], [image_obj.bounds[1]]), sxmax = _b[0], symax = _b[1];
                sxmin = sxmin[0];
                symin = symin[0];
                sxmax = sxmax[0];
                symax = symax[0];
                sw = sxmax - sxmin;
                sh = symax - symin;
                sx = sxmin;
                sy = symin;
                this.map_canvas.drawImage(image_obj.img, sx, sy, sw, sh);
                return this.map_canvas.restore();
            }
            var _a, _b;
        };
        DynamicImageView.prototype._set_rect = function () {
            var h, l, outline_width, t, w;
            outline_width = this.plot_model.plot.properties.outline_line_width.value();
            l = this.map_frame._left.value + outline_width / 2;
            t = this.map_frame._top.value + outline_width / 2;
            w = this.map_frame._width.value - outline_width;
            h = this.map_frame._height.value - outline_width;
            this.map_canvas.rect(l, t, w, h);
            return this.map_canvas.clip();
        };
        return DynamicImageView;
    }(renderer_1.RendererView);
    var DynamicImageRenderer = function (_super) {
        tslib_1.__extends(DynamicImageRenderer, _super);
        function DynamicImageRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DynamicImageRenderer;
    }(renderer_1.Renderer);
    exports.DynamicImageRenderer = DynamicImageRenderer;
    ;
    DynamicImageRenderer.prototype.default_view = exports.DynamicImageView;
    DynamicImageRenderer.prototype.type = 'DynamicImageRenderer';
    DynamicImageRenderer.define({
        alpha: [
            p.Number,
            1
        ],
        image_source: [p.Instance],
        render_parents: [
            p.Bool,
            true
        ]
    });
    DynamicImageRenderer.override({ level: 'underlay' });    
},
/*models/tiles/image_pool*/
function _(require, module, exports) {
    exports.ImagePool = function () {
        function ImagePool() {
            this.images = [];
        }
        ImagePool.prototype.pop = function () {
            var img;
            img = this.images.pop();
            if (img != null) {
                return img;
            } else {
                return new Image();
            }
        };
        ImagePool.prototype.push = function (img) {
            if (this.images.length > 50) {
                return;
            }
            if (img.constructor === Array) {
                return Array.prototype.push.apply(this.images, img);
            } else {
                return this.images.push(img);
            }
        };
        return ImagePool;
    }();    
},
/*models/tiles/image_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var p = require(15    /* core/properties */);
    var model_1 = require(50    /* ../../model */);
    var ImageSource = function (_super) {
        tslib_1.__extends(ImageSource, _super);
        function ImageSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ImageSource.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this.images = {};
            return this.normalize_case();
        };
        ImageSource.prototype.normalize_case = function () {
            'Note: should probably be refactored into subclasses.';
            var url;
            url = this.url;
            url = url.replace('{xmin}', '{XMIN}');
            url = url.replace('{ymin}', '{YMIN}');
            url = url.replace('{xmax}', '{XMAX}');
            url = url.replace('{ymax}', '{YMAX}');
            url = url.replace('{height}', '{HEIGHT}');
            url = url.replace('{width}', '{WIDTH}');
            return this.url = url;
        };
        ImageSource.prototype.string_lookup_replace = function (str, lookup) {
            var key, result_str, value;
            result_str = str;
            for (key in lookup) {
                value = lookup[key];
                result_str = result_str.replace('{' + key + '}', value.toString());
            }
            return result_str;
        };
        ImageSource.prototype.add_image = function (image_obj) {
            return this.images[image_obj.cache_key] = image_obj;
        };
        ImageSource.prototype.remove_image = function (image_obj) {
            return delete this.images[image_obj.cache_key];
        };
        ImageSource.prototype.get_image_url = function (xmin, ymin, xmax, ymax, height, width) {
            var image_url;
            image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
            return image_url.replace('{XMIN}', xmin).replace('{YMIN}', ymin).replace('{XMAX}', xmax).replace('{YMAX}', ymax).replace('{WIDTH}', width).replace('{HEIGHT}', height);
        };
        return ImageSource;
    }(model_1.Model);
    exports.ImageSource = ImageSource;
    ;
    ImageSource.prototype.type = 'ImageSource';
    ImageSource.define({
        url: [
            p.String,
            ''
        ],
        extra_url_vars: [
            p.Any,
            {}
        ]
    });    
},
/*models/tiles/index*/
function _(require, module, exports) {
    var bbox_tile_source_1 = require(195    /* ./bbox_tile_source */);
    exports.BBoxTileSource = bbox_tile_source_1.BBoxTileSource;
    var dynamic_image_renderer_1 = require(196    /* ./dynamic_image_renderer */);
    exports.DynamicImageRenderer = dynamic_image_renderer_1.DynamicImageRenderer;
    var image_source_1 = require(198    /* ./image_source */);
    exports.ImageSource = image_source_1.ImageSource;
    var mercator_tile_source_1 = require(200    /* ./mercator_tile_source */);
    exports.MercatorTileSource = mercator_tile_source_1.MercatorTileSource;
    var quadkey_tile_source_1 = require(201    /* ./quadkey_tile_source */);
    exports.QUADKEYTileSource = quadkey_tile_source_1.QUADKEYTileSource;
    var tile_renderer_1 = require(202    /* ./tile_renderer */);
    exports.TileRenderer = tile_renderer_1.TileRenderer;
    var tile_source_1 = require(203    /* ./tile_source */);
    exports.TileSource = tile_source_1.TileSource;
    var tms_tile_source_1 = require(205    /* ./tms_tile_source */);
    exports.TMSTileSource = tms_tile_source_1.TMSTileSource;
    var wmts_tile_source_1 = require(206    /* ./wmts_tile_source */);
    exports.WMTSTileSource = wmts_tile_source_1.WMTSTileSource;    
},
/*models/tiles/mercator_tile_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var indexOf = [].indexOf;
    var tile_source_1 = require(203    /* ./tile_source */);
    var p = require(15    /* core/properties */);
    var MercatorTileSource = function (_super) {
        tslib_1.__extends(MercatorTileSource, _super);
        function MercatorTileSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MercatorTileSource.prototype.initialize = function (options) {
            var z;
            _super.prototype.initialize.call(this, options);
            return this._resolutions = function () {
                var j, ref, ref1, results;
                results = [];
                for (z = j = ref = this.min_zoom, ref1 = this.max_zoom; ref <= ref1 ? j <= ref1 : j >= ref1; z = ref <= ref1 ? ++j : --j) {
                    results.push(this.get_resolution(z));
                }
                return results;
            }.call(this);
        };
        MercatorTileSource.prototype._computed_initial_resolution = function () {
            if (this.initial_resolution != null) {
                return this.initial_resolution;
            } else {
                // TODO testing 2015-11-17, if this codepath is used it seems
                // to use 100% cpu and wedge Chrome
                return 2 * Math.PI * 6378137 / this.tile_size;
            }
        };
        MercatorTileSource.prototype.is_valid_tile = function (x, y, z) {
            if (!this.wrap_around) {
                if (x < 0 || x >= Math.pow(2, z)) {
                    return false;
                }
            }
            if (y < 0 || y >= Math.pow(2, z)) {
                return false;
            }
            return true;
        };
        MercatorTileSource.prototype.retain_children = function (reference_tile) {
            var key, max_zoom, min_zoom, quadkey, ref, results, tile;
            quadkey = reference_tile.quadkey;
            min_zoom = quadkey.length;
            max_zoom = min_zoom + 3;
            ref = this.tiles;
            results = [];
            for (key in ref) {
                tile = ref[key];
                if (tile.quadkey.indexOf(quadkey) === 0 && tile.quadkey.length > min_zoom && tile.quadkey.length <= max_zoom) {
                    results.push(tile.retain = true);
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        MercatorTileSource.prototype.retain_neighbors = function (reference_tile) {
            var key, neighbor_radius, neighbor_x, neighbor_y, ref, ref1, ref2, results, tile, tx, ty, tz, x, y;
            neighbor_radius = 4;
            _a = reference_tile.tile_coords, tx = _a[0], ty = _a[1], tz = _a[2];
            neighbor_x = function () {
                var j, ref, ref1, results;
                results = [];
                for (x = j = ref = tx - neighbor_radius, ref1 = tx + neighbor_radius; ref <= ref1 ? j <= ref1 : j >= ref1; x = ref <= ref1 ? ++j : --j) {
                    results.push(x);
                }
                return results;
            }();
            neighbor_y = function () {
                var j, ref, ref1, results;
                results = [];
                for (y = j = ref = ty - neighbor_radius, ref1 = ty + neighbor_radius; ref <= ref1 ? j <= ref1 : j >= ref1; y = ref <= ref1 ? ++j : --j) {
                    results.push(y);
                }
                return results;
            }();
            ref = this.tiles;
            results = [];
            for (key in ref) {
                tile = ref[key];
                if (tile.tile_coords[2] === tz && (ref1 = tile.tile_coords[0], indexOf.call(neighbor_x, ref1) >= 0) && (ref2 = tile.tile_coords[1], indexOf.call(neighbor_y, ref2) >= 0)) {
                    results.push(tile.retain = true);
                } else {
                    results.push(void 0);
                }
            }
            return results;
            var _a;
        };
        MercatorTileSource.prototype.retain_parents = function (reference_tile) {
            var key, quadkey, ref, results, tile;
            quadkey = reference_tile.quadkey;
            ref = this.tiles;
            results = [];
            for (key in ref) {
                tile = ref[key];
                results.push(tile.retain = quadkey.indexOf(tile.quadkey) === 0);
            }
            return results;
        };
        MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {
            var b, child_tile_xyz, i, j, quad_key, world_x;
            world_x = this.calculate_world_x_by_tile_xyz(x, y, z);
            if (world_x !== 0) {
                _a = this.normalize_xyz(x, y, z), x = _a[0], y = _a[1], z = _a[2];
            }
            quad_key = this.tile_xyz_to_quadkey(x, y, z);
            child_tile_xyz = [];
            for (i = j = 0; j <= 3; i = j += 1) {
                _b = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = _b[0], y = _b[1], z = _b[2];
                if (world_x !== 0) {
                    _c = this.denormalize_xyz(x, y, z, world_x), x = _c[0], y = _c[1], z = _c[2];
                }
                b = this.get_tile_meter_bounds(x, y, z);
                if (b != null) {
                    child_tile_xyz.push([
                        x,
                        y,
                        z,
                        b
                    ]);
                }
            }
            return child_tile_xyz;
            var _a, _b, _c;
        };
        MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {
            var parent_quad_key, quad_key;
            quad_key = this.tile_xyz_to_quadkey(x, y, z);
            parent_quad_key = quad_key.substring(0, quad_key.length - 1);
            return this.quadkey_to_tile_xyz(parent_quad_key);
        };
        MercatorTileSource.prototype.get_resolution = function (level) {
            return this._computed_initial_resolution() / Math.pow(2, level);
        };
        MercatorTileSource.prototype.get_resolution_by_extent = function (extent, height, width) {
            var x_rs, y_rs;
            x_rs = (extent[2] - extent[0]) / width;
            y_rs = (extent[3] - extent[1]) / height;
            return [
                x_rs,
                y_rs
            ];
        };
        MercatorTileSource.prototype.get_level_by_extent = function (extent, height, width) {
            var i, j, len, r, ref, resolution, x_rs, y_rs;
            x_rs = (extent[2] - extent[0]) / width;
            y_rs = (extent[3] - extent[1]) / height;
            resolution = Math.max(x_rs, y_rs);
            i = 0;
            ref = this._resolutions;
            for (j = 0, len = ref.length; j < len; j++) {
                r = ref[j];
                if (resolution > r) {
                    if (i === 0) {
                        return 0;
                    }
                    if (i > 0) {
                        return i - 1;
                    }
                }
                i += 1;
            }
        };
        MercatorTileSource.prototype.get_closest_level_by_extent = function (extent, height, width) {
            var closest, resolution, ress, x_rs, y_rs;
            x_rs = (extent[2] - extent[0]) / width;
            y_rs = (extent[3] - extent[1]) / height;
            resolution = Math.max(x_rs, y_rs);
            ress = this._resolutions;
            closest = this._resolutions.reduce(function (previous, current) {
                if (Math.abs(current - resolution) < Math.abs(previous - resolution)) {
                    return current;
                }
                return previous;
            });
            return this._resolutions.indexOf(closest);
        };
        MercatorTileSource.prototype.snap_to_zoom = function (extent, height, width, level) {
            var desired_res, desired_x_delta, desired_y_delta, x_adjust, xmax, xmin, y_adjust, ymax, ymin;
            desired_res = this._resolutions[level];
            desired_x_delta = width * desired_res;
            desired_y_delta = height * desired_res;
            xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
            x_adjust = (desired_x_delta - (xmax - xmin)) / 2;
            y_adjust = (desired_y_delta - (ymax - ymin)) / 2;
            return [
                xmin - x_adjust,
                ymin - y_adjust,
                xmax + x_adjust,
                ymax + y_adjust
            ];
        };
        MercatorTileSource.prototype.tms_to_wmts = function (x, y, z) {
            'Note this works both ways';
            return [
                x,
                Math.pow(2, z) - 1 - y,
                z
            ];
        };
        MercatorTileSource.prototype.wmts_to_tms = function (x, y, z) {
            'Note this works both ways';
            return [
                x,
                Math.pow(2, z) - 1 - y,
                z
            ];
        };
        MercatorTileSource.prototype.pixels_to_meters = function (px, py, level) {
            var mx, my, res;
            res = this.get_resolution(level);
            mx = px * res - this.x_origin_offset;
            my = py * res - this.y_origin_offset;
            return [
                mx,
                my
            ];
        };
        MercatorTileSource.prototype.meters_to_pixels = function (mx, my, level) {
            var px, py, res;
            res = this.get_resolution(level);
            px = (mx + this.x_origin_offset) / res;
            py = (my + this.y_origin_offset) / res;
            return [
                px,
                py
            ];
        };
        MercatorTileSource.prototype.pixels_to_tile = function (px, py) {
            var tx, ty;
            tx = Math.ceil(px / parseFloat(this.tile_size));
            tx = tx === 0 ? tx : tx - 1;
            ty = Math.max(Math.ceil(py / parseFloat(this.tile_size)) - 1, 0);
            return [
                tx,
                ty
            ];
        };
        MercatorTileSource.prototype.pixels_to_raster = function (px, py, level) {
            var mapSize;
            mapSize = this.tile_size << level;
            return [
                px,
                mapSize - py
            ];
        };
        MercatorTileSource.prototype.meters_to_tile = function (mx, my, level) {
            var px, py;
            _a = this.meters_to_pixels(mx, my, level), px = _a[0], py = _a[1];
            return this.pixels_to_tile(px, py);
            var _a;
        };
        MercatorTileSource.prototype.get_tile_meter_bounds = function (tx, ty, level) {
            var xmax, xmin, ymax, ymin;
            // expects tms styles coordinates (bottom-left origin)
            _a = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level), xmin = _a[0], ymin = _a[1];
            _b = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level), xmax = _b[0], ymax = _b[1];
            if (xmin != null && ymin != null && xmax != null && ymax != null) {
                return [
                    xmin,
                    ymin,
                    xmax,
                    ymax
                ];
            } else {
                return void 0;
            }
            var _a, _b;
        };
        MercatorTileSource.prototype.get_tile_geographic_bounds = function (tx, ty, level) {
            var bounds, maxLat, maxLon, minLat, minLon;
            bounds = this.get_tile_meter_bounds(tx, ty, level);
            _a = this.utils.meters_extent_to_geographic(bounds), minLon = _a[0], minLat = _a[1], maxLon = _a[2], maxLat = _a[3];
            return [
                minLon,
                minLat,
                maxLon,
                maxLat
            ];
            var _a;
        };
        MercatorTileSource.prototype.get_tiles_by_extent = function (extent, level, tile_border) {
            if (tile_border === void 0) {
                tile_border = 1;
            }
            var j, k, ref, ref1, ref2, ref3, tiles, tx, txmax, txmin, ty, tymax, tymin, xmax, xmin, ymax, ymin;
            // unpack extent and convert to tile coordinates
            xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
            _a = this.meters_to_tile(xmin, ymin, level), txmin = _a[0], tymin = _a[1];
            _b = this.meters_to_tile(xmax, ymax, level), txmax = _b[0], tymax = _b[1];
            // add tiles which border
            txmin -= tile_border;
            tymin -= tile_border;
            txmax += tile_border;
            tymax += tile_border;
            tiles = [];
            for (ty = j = ref = tymax, ref1 = tymin; j >= ref1; ty = j += -1) {
                for (tx = k = ref2 = txmin, ref3 = txmax; k <= ref3; tx = k += 1) {
                    if (this.is_valid_tile(tx, ty, level)) {
                        tiles.push([
                            tx,
                            ty,
                            level,
                            this.get_tile_meter_bounds(tx, ty, level)
                        ]);
                    }
                }
            }
            tiles = this.sort_tiles_from_center(tiles, [
                txmin,
                tymin,
                txmax,
                tymax
            ]);
            return tiles;
            var _a, _b;
        };
        MercatorTileSource.prototype.quadkey_to_tile_xyz = function (quadKey) {
            'Computes tile x, y and z values based on quadKey.';
            var i, j, mask, ref, tileX, tileY, tileZ, value;
            tileX = 0;
            tileY = 0;
            tileZ = quadKey.length;
            for (i = j = ref = tileZ; j > 0; i = j += -1) {
                value = quadKey.charAt(tileZ - i);
                mask = 1 << i - 1;
                switch (value) {
                case '0':
                    continue;
                case '1':
                    tileX |= mask;
                    break;
                case '2':
                    tileY |= mask;
                    break;
                case '3':
                    tileX |= mask;
                    tileY |= mask;
                    break;
                default:
                    throw new TypeError('Invalid Quadkey: ' + quadKey);
                }
            }
            return [
                tileX,
                tileY,
                tileZ
            ];
        };
        MercatorTileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {
            'Computes quadkey value based on tile x, y and z values.';
            var digit, i, j, mask, quadKey, ref;
            quadKey = '';
            for (i = j = ref = z; j > 0; i = j += -1) {
                digit = 0;
                mask = 1 << i - 1;
                if ((x & mask) !== 0) {
                    digit += 1;
                }
                if ((y & mask) !== 0) {
                    digit += 2;
                }
                quadKey += digit.toString();
            }
            return quadKey;
        };
        MercatorTileSource.prototype.children_by_tile_xyz = function (x, y, z) {
            var b, child_tile_xyz, i, j, quad_key;
            quad_key = this.tile_xyz_to_quadkey(x, y, z);
            child_tile_xyz = [];
            for (i = j = 0; j <= 3; i = j += 1) {
                _a = this.quadkey_to_tile_xyz(quad_key + i.toString()), x = _a[0], y = _a[1], z = _a[2];
                b = this.get_tile_meter_bounds(x, y, z);
                if (b != null) {
                    child_tile_xyz.push([
                        x,
                        y,
                        z,
                        b
                    ]);
                }
            }
            return child_tile_xyz;
            var _a;
        };
        MercatorTileSource.prototype.parent_by_tile_xyz = function (x, y, z) {
            var parent_quad_key, quad_key;
            quad_key = this.tile_xyz_to_quadkey(x, y, z);
            parent_quad_key = quad_key.substring(0, quad_key.length - 1);
            return this.quadkey_to_tile_xyz(parent_quad_key);
        };
        MercatorTileSource.prototype.get_closest_parent_by_tile_xyz = function (x, y, z) {
            var quad_key, world_x;
            world_x = this.calculate_world_x_by_tile_xyz(x, y, z);
            _a = this.normalize_xyz(x, y, z), x = _a[0], y = _a[1], z = _a[2];
            quad_key = this.tile_xyz_to_quadkey(x, y, z);
            while (quad_key.length > 0) {
                quad_key = quad_key.substring(0, quad_key.length - 1);
                _b = this.quadkey_to_tile_xyz(quad_key), x = _b[0], y = _b[1], z = _b[2];
                _c = this.denormalize_xyz(x, y, z, world_x), x = _c[0], y = _c[1], z = _c[2];
                if (this.tile_xyz_to_key(x, y, z) in this.tiles) {
                    return [
                        x,
                        y,
                        z
                    ];
                }
            }
            return [
                0,
                0,
                0
            ];
            var _a, _b, _c;
        };
        MercatorTileSource.prototype.normalize_xyz = function (x, y, z) {
            var tile_count;
            if (this.wrap_around) {
                tile_count = Math.pow(2, z);
                return [
                    (x % tile_count + tile_count) % tile_count,
                    y,
                    z
                ];
            } else {
                return [
                    x,
                    y,
                    z
                ];
            }
        };
        MercatorTileSource.prototype.denormalize_xyz = function (x, y, z, world_x) {
            return [
                x + world_x * Math.pow(2, z),
                y,
                z
            ];
        };
        MercatorTileSource.prototype.denormalize_meters = function (meters_x, meters_y, level, world_x) {
            return [
                meters_x + world_x * 2 * Math.PI * 6378137,
                meters_y
            ];
        };
        MercatorTileSource.prototype.calculate_world_x_by_tile_xyz = function (x, y, z) {
            return Math.floor(x / Math.pow(2, z));
        };
        return MercatorTileSource;
    }(tile_source_1.TileSource);
    exports.MercatorTileSource = MercatorTileSource;
    ;
    MercatorTileSource.prototype.type = 'MercatorTileSource';
    MercatorTileSource.define({
        wrap_around: [
            p.Bool,
            true
        ]
    });
    MercatorTileSource.override({
        x_origin_offset: 20037508.34,
        y_origin_offset: 20037508.34,
        initial_resolution: 156543.03392804097
    });    
},
/*models/tiles/quadkey_tile_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var mercator_tile_source_1 = require(200    /* ./mercator_tile_source */);
    var QUADKEYTileSource = function (_super) {
        tslib_1.__extends(QUADKEYTileSource, _super);
        function QUADKEYTileSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        QUADKEYTileSource.prototype.get_image_url = function (x, y, z) {
            var image_url, quadKey;
            image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
            _a = this.tms_to_wmts(x, y, z), x = _a[0], y = _a[1], z = _a[2];
            quadKey = this.tile_xyz_to_quadkey(x, y, z);
            return image_url.replace('{Q}', quadKey);
            var _a;
        };
        return QUADKEYTileSource;
    }(mercator_tile_source_1.MercatorTileSource);
    exports.QUADKEYTileSource = QUADKEYTileSource;
    ;
    QUADKEYTileSource.prototype.type = 'QUADKEYTileSource';    
},
/*models/tiles/tile_renderer*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var boundMethodCheck = function (instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new Error('Bound instance method accessed before binding');
            }
        }, indexOf = [].indexOf;
    var image_pool_1 = require(197    /* ./image_pool */);
    var wmts_tile_source_1 = require(206    /* ./wmts_tile_source */);
    var renderer_1 = require(165    /* ../renderers/renderer */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    exports.TileRendererView = function (_super) {
        tslib_1.__extends(TileRendererView, _super);
        function TileRendererView() {
            var _this = _super.apply(this, arguments) || this;
            _this._add_attribution = _this._add_attribution.bind(_this);
            _this._on_tile_load = _this._on_tile_load.bind(_this);
            _this._on_tile_cache_load = _this._on_tile_cache_load.bind(_this);
            _this._on_tile_error = _this._on_tile_error.bind(_this);
            _this._prefetch_tiles = _this._prefetch_tiles.bind(_this);
            _this._update = _this._update.bind(_this);
            return _this;
        }
        TileRendererView.prototype.initialize = function (options) {
            this.attributionEl = null;
            this._tiles = [];
            return _super.prototype.initialize.call(this, options);
        };
        TileRendererView.prototype.connect_signals = function () {
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.change, function () {
                return this.request_render();
            });
        };
        TileRendererView.prototype.get_extent = function () {
            return [
                this.x_range.start,
                this.y_range.start,
                this.x_range.end,
                this.y_range.end
            ];
        };
        TileRendererView.prototype._set_data = function () {
            this.pool = new image_pool_1.ImagePool();
            this.map_plot = this.plot_model.plot;
            this.map_canvas = this.plot_view.canvas_view.ctx;
            this.map_frame = this.plot_model.frame;
            this.x_range = this.map_plot.x_range;
            this.y_range = this.map_plot.y_range;
            this.extent = this.get_extent();
            this._last_height = void 0;
            return this._last_width = void 0;
        };
        TileRendererView.prototype._add_attribution = function () {
            var attribution, bottom, max_width, overlays, right;
            boundMethodCheck(this, TileRendererView);
            attribution = this.model.tile_source.attribution;
            if (types_1.isString(attribution) && attribution.length > 0) {
                if (this.attributionEl == null) {
                    right = this.plot_model.canvas._right.value - this.plot_model.frame._right.value;
                    bottom = this.plot_model.canvas._bottom.value - this.plot_model.frame._bottom.value;
                    max_width = this.map_frame._width.value;
                    this.attributionEl = dom_1.div({
                        class: 'bk-tile-attribution',
                        style: {
                            position: 'absolute',
                            bottom: bottom + 'px',
                            right: right + 'px',
                            'max-width': max_width + 'px',
                            padding: '2px',
                            'background-color': 'rgba(255,255,255,0.8)',
                            'font-size': '9pt',
                            'font-family': 'sans-serif'
                        }
                    });
                    overlays = this.plot_view.canvas_view.events_el;
                    overlays.appendChild(this.attributionEl);
                }
                return this.attributionEl.innerHTML = attribution;
            }
        };
        TileRendererView.prototype._map_data = function () {
            var new_extent, zoom_level;
            this.initial_extent = this.get_extent();
            zoom_level = this.model.tile_source.get_level_by_extent(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value);
            new_extent = this.model.tile_source.snap_to_zoom(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);
            this.x_range.start = new_extent[0];
            this.y_range.start = new_extent[1];
            this.x_range.end = new_extent[2];
            this.y_range.end = new_extent[3];
            return this._add_attribution();
        };
        TileRendererView.prototype._on_tile_load = function (e) {
            var tile_data;
            boundMethodCheck(this, TileRendererView);
            tile_data = e.target.tile_data;
            tile_data.img = e.target;
            tile_data.current = true;
            tile_data.loaded = true;
            return this.request_render();
        };
        TileRendererView.prototype._on_tile_cache_load = function (e) {
            var tile_data;
            boundMethodCheck(this, TileRendererView);
            tile_data = e.target.tile_data;
            tile_data.img = e.target;
            tile_data.loaded = true;
            tile_data.finished = true;
            return this.notify_finished();
        };
        TileRendererView.prototype._on_tile_error = function (e) {
            var tile_data;
            boundMethodCheck(this, TileRendererView);
            tile_data = e.target.tile_data;
            return tile_data.finished = true;
        };
        TileRendererView.prototype._create_tile = function (x, y, z, bounds, cache_only) {
            if (cache_only === void 0) {
                cache_only = false;
            }
            var normalized_coords, tile;
            normalized_coords = this.model.tile_source.normalize_xyz(x, y, z);
            tile = this.pool.pop();
            if (cache_only) {
                tile.onload = this._on_tile_cache_load;
            } else {
                tile.onload = this._on_tile_load;
            }
            tile.onerror = this._on_tile_error;
            tile.alt = '';
            tile.tile_data = {
                tile_coords: [
                    x,
                    y,
                    z
                ],
                normalized_coords: normalized_coords,
                quadkey: this.model.tile_source.tile_xyz_to_quadkey(x, y, z),
                cache_key: this.model.tile_source.tile_xyz_to_key(x, y, z),
                bounds: bounds,
                loaded: false,
                finished: false,
                x_coord: bounds[0],
                y_coord: bounds[3]
            };
            this.model.tile_source.tiles[tile.tile_data.cache_key] = tile.tile_data;
            tile.src = (_a = this.model.tile_source).get_image_url.apply(_a, normalized_coords);
            this._tiles.push(tile);
            return tile;
            var _a;
        };
        TileRendererView.prototype._enforce_aspect_ratio = function () {
            var extent, new_extent, zoom_level;
            // brute force way of handling resize or sizing_mode event -------------------------------------------------------------
            if (this._last_height !== this.map_frame._height.value || this._last_width !== this.map_frame._width.value) {
                extent = this.get_extent();
                zoom_level = this.model.tile_source.get_level_by_extent(extent, this.map_frame._height.value, this.map_frame._width.value);
                new_extent = this.model.tile_source.snap_to_zoom(extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);
                this.x_range.setv({
                    start: new_extent[0],
                    end: new_extent[2]
                });
                this.y_range.setv({
                    start: new_extent[1],
                    end: new_extent[3]
                });
                this.extent = new_extent;
                this._last_height = this.map_frame._height.value;
                this._last_width = this.map_frame._width.value;
                return true;
            }
            return false;
        };
        TileRendererView.prototype.has_finished = function () {
            var i, len, ref, tile;
            if (!_super.prototype.has_finished.call(this)) {
                return false;
            }
            if (this._tiles.length === 0) {
                return false;
            }
            ref = this._tiles;
            for (i = 0, len = ref.length; i < len; i++) {
                tile = ref[i];
                if (!tile.tile_data.finished) {
                    return false;
                }
            }
            return true;
        };
        TileRendererView.prototype.render = function (ctx, indices, args) {
            if (this.map_initialized == null) {
                this._set_data();
                this._map_data();
                this.map_initialized = true;
            }
            if (this._enforce_aspect_ratio()) {
                return;
            }
            this._update();
            if (this.prefetch_timer != null) {
                clearTimeout(this.prefetch_timer);
            }
            this.prefetch_timer = setTimeout(this._prefetch_tiles, 500);
            if (this.has_finished()) {
                return this.notify_finished();
            }
        };
        TileRendererView.prototype._draw_tile = function (tile_key) {
            var sh, sw, sx, sxmax, sxmin, sy, symax, symin, tile_obj;
            tile_obj = this.model.tile_source.tiles[tile_key];
            if (tile_obj != null) {
                _a = this.plot_view.map_to_screen([tile_obj.bounds[0]], [tile_obj.bounds[3]]), sxmin = _a[0], symin = _a[1];
                _b = this.plot_view.map_to_screen([tile_obj.bounds[2]], [tile_obj.bounds[1]]), sxmax = _b[0], symax = _b[1];
                sxmin = sxmin[0];
                symin = symin[0];
                sxmax = sxmax[0];
                symax = symax[0];
                sw = sxmax - sxmin;
                sh = symax - symin;
                sx = sxmin;
                sy = symin;
                return this.map_canvas.drawImage(tile_obj.img, sx, sy, sw, sh);
            }
            var _a, _b;
        };
        TileRendererView.prototype._set_rect = function () {
            var h, l, outline_width, t, w;
            outline_width = this.plot_model.plot.properties.outline_line_width.value();
            l = this.map_frame._left.value + outline_width / 2;
            t = this.map_frame._top.value + outline_width / 2;
            w = this.map_frame._width.value - outline_width;
            h = this.map_frame._height.value - outline_width;
            this.map_canvas.rect(l, t, w, h);
            return this.map_canvas.clip();
        };
        TileRendererView.prototype._render_tiles = function (tile_keys) {
            var i, len, tile_key;
            this.map_canvas.save();
            this._set_rect();
            this.map_canvas.globalAlpha = this.model.alpha;
            for (i = 0, len = tile_keys.length; i < len; i++) {
                tile_key = tile_keys[i];
                this._draw_tile(tile_key);
            }
            return this.map_canvas.restore();
        };
        TileRendererView.prototype._prefetch_tiles = function () {
            var bounds, c, cbounds, children, cx, cy, cz, extent, h, i, ref, results, t, tile_source, tiles, w, x, y, z, zoom_level;
            boundMethodCheck(this, TileRendererView);
            tile_source = this.model.tile_source;
            extent = this.get_extent();
            h = this.map_frame._height.value;
            w = this.map_frame._width.value;
            zoom_level = this.model.tile_source.get_level_by_extent(extent, h, w);
            tiles = this.model.tile_source.get_tiles_by_extent(extent, zoom_level);
            results = [];
            for (t = i = 0, ref = Math.min(10, tiles.length); i <= ref; t = i += 1) {
                x = t[0], y = t[1], z = t[2], bounds = t[3];
                children = this.model.tile_source.children_by_tile_xyz(x, y, z);
                results.push(function () {
                    var j, len, results1;
                    results1 = [];
                    for (j = 0, len = children.length; j < len; j++) {
                        c = children[j];
                        cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];
                        if (tile_source.tile_xyz_to_key(cx, cy, cz) in tile_source.tiles) {
                            continue;
                        } else {
                            results1.push(this._create_tile(cx, cy, cz, cbounds, true));
                        }
                    }
                    return results1;
                }.call(this));
            }
            return results;
        };
        TileRendererView.prototype._fetch_tiles = function (tiles) {
            var bounds, i, len, results, t, x, y, z;
            results = [];
            for (i = 0, len = tiles.length; i < len; i++) {
                t = tiles[i];
                x = t[0], y = t[1], z = t[2], bounds = t[3];
                results.push(this._create_tile(x, y, z, bounds));
            }
            return results;
        };
        TileRendererView.prototype._update = function () {
            var _this = this;
            var bounds, c, cached, cbounds, child_key, children, cx, cy, cz, extent, h, i, j, k, key, len, len1, len2, max_zoom, min_zoom, need_load, parent_key, parent_tile, parents, px, py, pz, snap_back, t, tile, tile_source, tiles, w, x, y, z, zoom_level, zooming_out;
            boundMethodCheck(this, TileRendererView);
            tile_source = this.model.tile_source;
            min_zoom = tile_source.min_zoom;
            max_zoom = tile_source.max_zoom;
            tile_source.update();
            extent = this.get_extent();
            zooming_out = this.extent[2] - this.extent[0] < extent[2] - extent[0];
            h = this.map_frame._height.value;
            w = this.map_frame._width.value;
            zoom_level = tile_source.get_level_by_extent(extent, h, w);
            snap_back = false;
            if (zoom_level < min_zoom) {
                extent = this.extent;
                zoom_level = min_zoom;
                snap_back = true;
            } else if (zoom_level > max_zoom) {
                extent = this.extent;
                zoom_level = max_zoom;
                snap_back = true;
            }
            if (snap_back) {
                this.x_range.setv({
                    x_range: {
                        start: extent[0],
                        end: extent[2]
                    }
                });
                this.y_range.setv({
                    start: extent[1],
                    end: extent[3]
                });
                this.extent = extent;
            }
            this.extent = extent;
            tiles = tile_source.get_tiles_by_extent(extent, zoom_level);
            parents = [];
            need_load = [];
            cached = [];
            children = [];
            for (i = 0, len = tiles.length; i < len; i++) {
                t = tiles[i];
                x = t[0], y = t[1], z = t[2], bounds = t[3];
                key = tile_source.tile_xyz_to_key(x, y, z);
                tile = tile_source.tiles[key];
                if (tile != null && tile.loaded === true) {
                    cached.push(key);
                } else {
                    if (this.model.render_parents) {
                        _a = tile_source.get_closest_parent_by_tile_xyz(x, y, z), px = _a[0], py = _a[1], pz = _a[2];
                        parent_key = tile_source.tile_xyz_to_key(px, py, pz);
                        parent_tile = tile_source.tiles[parent_key];
                        if (parent_tile != null && parent_tile.loaded && indexOf.call(parents, parent_key) < 0) {
                            parents.push(parent_key);
                        }
                        if (zooming_out) {
                            children = tile_source.children_by_tile_xyz(x, y, z);
                            for (j = 0, len1 = children.length; j < len1; j++) {
                                c = children[j];
                                cx = c[0], cy = c[1], cz = c[2], cbounds = c[3];
                                child_key = tile_source.tile_xyz_to_key(cx, cy, cz);
                                if (child_key in tile_source.tiles) {
                                    children.push(child_key);
                                }
                            }
                        }
                    }
                }
                if (tile == null) {
                    need_load.push(t);
                }
            }
            // draw stand-in parents ----------
            this._render_tiles(parents);
            this._render_tiles(children);
            // draw cached ----------
            this._render_tiles(cached);
            for (k = 0, len2 = cached.length; k < len2; k++) {
                t = cached[k];
                tile_source.tiles[t].current = true;
            }
            // fetch missing -------
            if (this.render_timer != null) {
                clearTimeout(this.render_timer);
            }
            return this.render_timer = setTimeout(function () {
                return _this._fetch_tiles(need_load);
            }, 65);
            var _a;
        };
        return TileRendererView;
    }(renderer_1.RendererView);
    var TileRenderer = function (_super) {
        tslib_1.__extends(TileRenderer, _super);
        function TileRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TileRenderer;
    }(renderer_1.Renderer);
    exports.TileRenderer = TileRenderer;
    ;
    TileRenderer.prototype.default_view = exports.TileRendererView;
    TileRenderer.prototype.type = 'TileRenderer';
    TileRenderer.define({
        alpha: [
            p.Number,
            1
        ],
        x_range_name: [
            p.String,
            'default'
        ],
        y_range_name: [
            p.String,
            'default'
        ],
        tile_source: [
            p.Instance,
            function () {
                return new wmts_tile_source_1.WMTSTileSource();
            }
        ],
        render_parents: [
            p.Bool,
            true
        ]
    });
    TileRenderer.override({ level: 'underlay' });    
},
/*models/tiles/tile_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var image_pool_1 = require(197    /* ./image_pool */);
    var tile_utils_1 = require(204    /* ./tile_utils */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var model_1 = require(50    /* ../../model */);
    var TileSource = function (_super) {
        tslib_1.__extends(TileSource, _super);
        function TileSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TileSource.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this.utils = new tile_utils_1.ProjectionUtils();
            this.pool = new image_pool_1.ImagePool();
            this.tiles = {};
            return this.normalize_case();
        };
        TileSource.prototype.string_lookup_replace = function (str, lookup) {
            var key, result_str, value;
            result_str = str;
            for (key in lookup) {
                value = lookup[key];
                result_str = result_str.replace('{' + key + '}', value.toString());
            }
            return result_str;
        };
        TileSource.prototype.normalize_case = function () {
            'Note: should probably be refactored into subclasses.';
            var url;
            url = this.url;
            url = url.replace('{x}', '{X}');
            url = url.replace('{y}', '{Y}');
            url = url.replace('{z}', '{Z}');
            url = url.replace('{q}', '{Q}');
            url = url.replace('{xmin}', '{XMIN}');
            url = url.replace('{ymin}', '{YMIN}');
            url = url.replace('{xmax}', '{XMAX}');
            url = url.replace('{ymax}', '{YMAX}');
            return this.url = url;
        };
        TileSource.prototype.update = function () {
            var key, ref, results, tile;
            logging_1.logger.debug('TileSource: tile cache count: ' + Object.keys(this.tiles).length);
            ref = this.tiles;
            results = [];
            for (key in ref) {
                tile = ref[key];
                tile.current = false;
                results.push(tile.retain = false);
            }
            return results;
        };
        TileSource.prototype.tile_xyz_to_key = function (x, y, z) {
            var key;
            key = x + ':' + y + ':' + z;
            return key;
        };
        TileSource.prototype.key_to_tile_xyz = function (key) {
            var c;
            return function () {
                var i, len, ref, results;
                ref = key.split(':');
                results = [];
                for (i = 0, len = ref.length; i < len; i++) {
                    c = ref[i];
                    results.push(parseInt(c));
                }
                return results;
            }();
        };
        TileSource.prototype.sort_tiles_from_center = function (tiles, tile_extent) {
            var center_x, center_y, txmax, txmin, tymax, tymin;
            txmin = tile_extent[0], tymin = tile_extent[1], txmax = tile_extent[2], tymax = tile_extent[3];
            center_x = (txmax - txmin) / 2 + txmin;
            center_y = (tymax - tymin) / 2 + tymin;
            tiles.sort(function (a, b) {
                var a_distance, b_distance;
                a_distance = Math.sqrt(Math.pow(center_x - a[0], 2) + Math.pow(center_y - a[1], 2));
                b_distance = Math.sqrt(Math.pow(center_x - b[0], 2) + Math.pow(center_y - b[1], 2));
                return a_distance - b_distance;
            });
            return tiles;
        };
        TileSource.prototype.prune_tiles = function () {
            var key, ref, ref1, results, tile;
            ref = this.tiles;
            for (key in ref) {
                tile = ref[key];
                tile.retain = tile.current || tile.tile_coords[2] < 3;
                // save the parents...they are cheap
                if (tile.current) {
                    this.retain_neighbors(tile);
                    this.retain_children(tile);
                    this.retain_parents(tile);
                }
            }
            ref1 = this.tiles;
            results = [];
            for (key in ref1) {
                tile = ref1[key];
                if (!tile.retain) {
                    results.push(this.remove_tile(key));
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        TileSource.prototype.remove_tile = function (key) {
            var tile;
            tile = this.tiles[key];
            if (tile != null) {
                this.pool.push(tile.img);
                return delete this.tiles[key];
            }
        };
        TileSource.prototype.get_image_url = function (x, y, z) {
            var image_url;
            image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
            return image_url.replace('{X}', x).replace('{Y}', y).replace('{Z}', z);
        };
        TileSource.prototype.retain_neighbors = function (reference_tile) {
            throw new Error('Not Implemented');
        };
        TileSource.prototype.retain_parents = function (reference_tile) {
            throw new Error('Not Implemented');
        };
        TileSource.prototype.retain_children = function (reference_tile) {
            throw new Error('Not Implemented');
        };
        TileSource.prototype.tile_xyz_to_quadkey = function (x, y, z) {
            throw new Error('Not Implemented');
        };
        TileSource.prototype.quadkey_to_tile_xyz = function (quadkey) {
            throw new Error('Not Implemented');
        };
        return TileSource;
    }(model_1.Model);
    exports.TileSource = TileSource;
    ;
    TileSource.prototype.type = 'TileSource';
    TileSource.define({
        url: [
            p.String,
            ''
        ],
        tile_size: [
            p.Number,
            256
        ],
        max_zoom: [
            p.Number,
            30
        ],
        min_zoom: [
            p.Number,
            0
        ],
        extra_url_vars: [
            p.Any,
            {}
        ],
        attribution: [
            p.String,
            ''
        ],
        x_origin_offset: [p.Number],
        y_origin_offset: [p.Number],
        initial_resolution: [p.Number]
    });    
},
/*models/tiles/tile_utils*/
function _(require, module, exports) {
    var proj4_1 = require(31    /* core/util/proj4 */);
    exports.ProjectionUtils = function () {
        function ProjectionUtils() {
            this.origin_shift = 2 * Math.PI * 6378137 / 2;
        }
        ProjectionUtils.prototype.geographic_to_meters = function (xLon, yLat) {
            return proj4_1.proj4(proj4_1.wgs84, proj4_1.mercator, [
                xLon,
                yLat
            ]);
        };
        ProjectionUtils.prototype.meters_to_geographic = function (mx, my) {
            return proj4_1.proj4(proj4_1.mercator, proj4_1.wgs84, [
                mx,
                my
            ]);
        };
        ProjectionUtils.prototype.geographic_extent_to_meters = function (extent) {
            var xmax, xmin, ymax, ymin;
            xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
            _a = this.geographic_to_meters(xmin, ymin), xmin = _a[0], ymin = _a[1];
            _b = this.geographic_to_meters(xmax, ymax), xmax = _b[0], ymax = _b[1];
            return [
                xmin,
                ymin,
                xmax,
                ymax
            ];
            var _a, _b;
        };
        ProjectionUtils.prototype.meters_extent_to_geographic = function (extent) {
            var xmax, xmin, ymax, ymin;
            xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
            _a = this.meters_to_geographic(xmin, ymin), xmin = _a[0], ymin = _a[1];
            _b = this.meters_to_geographic(xmax, ymax), xmax = _b[0], ymax = _b[1];
            return [
                xmin,
                ymin,
                xmax,
                ymax
            ];
            var _a, _b;
        };
        return ProjectionUtils;
    }();    
},
/*models/tiles/tms_tile_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var mercator_tile_source_1 = require(200    /* ./mercator_tile_source */);
    var TMSTileSource = function (_super) {
        tslib_1.__extends(TMSTileSource, _super);
        function TMSTileSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TMSTileSource.prototype.get_image_url = function (x, y, z) {
            var image_url;
            image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
            return image_url.replace('{X}', x).replace('{Y}', y).replace('{Z}', z);
        };
        return TMSTileSource;
    }(mercator_tile_source_1.MercatorTileSource);
    exports.TMSTileSource = TMSTileSource;
    ;
    TMSTileSource.prototype.type = 'TMSTileSource';    
},
/*models/tiles/wmts_tile_source*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var mercator_tile_source_1 = require(200    /* ./mercator_tile_source */);
    var WMTSTileSource = function (_super) {
        tslib_1.__extends(WMTSTileSource, _super);
        function WMTSTileSource() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WMTSTileSource.prototype.get_image_url = function (x, y, z) {
            var image_url;
            image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
            _a = this.tms_to_wmts(x, y, z), x = _a[0], y = _a[1], z = _a[2];
            return image_url.replace('{X}', x).replace('{Y}', y).replace('{Z}', z);
            var _a;
        };
        return WMTSTileSource;
    }(mercator_tile_source_1.MercatorTileSource);
    exports.WMTSTileSource = WMTSTileSource;
    ;
    WMTSTileSource.prototype.type = 'WMTSTileSource';    
},
/*models/tools/actions/action_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var button_tool_1 = require(215    /* ../button_tool */);
    var signaling_1 = require(20    /* core/signaling */);
    exports.ActionToolButtonView = function (_super) {
        tslib_1.__extends(ActionToolButtonView, _super);
        function ActionToolButtonView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ActionToolButtonView.prototype._clicked = function () {
            return this.model.do.emit();
        };
        return ActionToolButtonView;
    }(button_tool_1.ButtonToolButtonView);
    exports.ActionToolView = function (_super) {
        tslib_1.__extends(ActionToolView, _super);
        function ActionToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ActionToolView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.connect(this.model.do, function () {
                return this.doit();
            });
        };
        return ActionToolView;
    }(button_tool_1.ButtonToolView);
    var ActionTool = function (_super) {
        tslib_1.__extends(ActionTool, _super);
        function ActionTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ActionTool.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            return this.do = new signaling_1.Signal(this, 'do');
        };
        return ActionTool;
    }(button_tool_1.ButtonTool);
    exports.ActionTool = ActionTool;
    ;
    ActionTool.prototype.button_view = exports.ActionToolButtonView;    
},
/*models/tools/actions/help_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var action_tool_1 = require(207    /* ./action_tool */);
    var p = require(15    /* core/properties */);
    exports.HelpToolView = function (_super) {
        tslib_1.__extends(HelpToolView, _super);
        function HelpToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HelpToolView.prototype.doit = function () {
            return window.open(this.model.redirect);
        };
        return HelpToolView;
    }(action_tool_1.ActionToolView);
    var HelpTool = function (_super) {
        tslib_1.__extends(HelpTool, _super);
        function HelpTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return HelpTool;
    }(action_tool_1.ActionTool);
    exports.HelpTool = HelpTool;
    ;
    HelpTool.prototype.default_view = exports.HelpToolView;
    HelpTool.prototype.type = 'HelpTool';
    HelpTool.prototype.tool_name = 'Help';
    HelpTool.prototype.icon = 'bk-tool-icon-help';
    HelpTool.define({
        help_tooltip: [
            p.String,
            'Click the question mark to learn more about Bokeh plot tools.'
        ],
        redirect: [
            p.String,
            'https://bokeh.pydata.org/en/latest/docs/user_guide/tools.html#built-in-tools'
        ]
    });
    HelpTool.getters({
        tooltip: function () {
            return this.help_tooltip;
        }
    });    
},
/*models/tools/actions/redo_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var action_tool_1 = require(207    /* ./action_tool */);
    exports.RedoToolView = function (_super) {
        tslib_1.__extends(RedoToolView, _super);
        function RedoToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RedoToolView.prototype.initialize = function (options) {
            var _this = this;
            _super.prototype.initialize.call(this, options);
            return this.connect(this.plot_view.state_changed, function () {
                return _this.model.disabled = !_this.plot_view.can_redo();
            });
        };
        RedoToolView.prototype.doit = function () {
            return this.plot_view.redo();
        };
        return RedoToolView;
    }(action_tool_1.ActionToolView);
    var RedoTool = function (_super) {
        tslib_1.__extends(RedoTool, _super);
        function RedoTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RedoTool;
    }(action_tool_1.ActionTool);
    exports.RedoTool = RedoTool;
    ;
    RedoTool.prototype.default_view = exports.RedoToolView;
    RedoTool.prototype.type = 'RedoTool';
    RedoTool.prototype.tool_name = 'Redo';
    RedoTool.prototype.icon = 'bk-tool-icon-redo';
    RedoTool.override({ disabled: true });    
},
/*models/tools/actions/reset_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var action_tool_1 = require(207    /* ./action_tool */);
    var bokeh_events_1 = require(3    /* core/bokeh_events */);
    var p = require(15    /* core/properties */);
    exports.ResetToolView = function (_super) {
        tslib_1.__extends(ResetToolView, _super);
        function ResetToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ResetToolView.prototype.doit = function () {
            this.plot_view.clear_state();
            this.plot_view.reset_range();
            this.plot_view.reset_selection();
            return this.plot_model.plot.trigger_event(new bokeh_events_1.Reset());
        };
        return ResetToolView;
    }(action_tool_1.ActionToolView);
    var ResetTool = function (_super) {
        tslib_1.__extends(ResetTool, _super);
        function ResetTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ResetTool;
    }(action_tool_1.ActionTool);
    exports.ResetTool = ResetTool;
    ;
    ResetTool.prototype.default_view = exports.ResetToolView;
    ResetTool.prototype.type = 'ResetTool';
    ResetTool.prototype.tool_name = 'Reset';
    ResetTool.prototype.icon = 'bk-tool-icon-reset';
    ResetTool.define({
        reset_size: [
            p.Bool,
            true
        ]
    });    
},
/*models/tools/actions/save_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var action_tool_1 = require(207    /* ./action_tool */);
    exports.SaveToolView = function (_super) {
        tslib_1.__extends(SaveToolView, _super);
        function SaveToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SaveToolView.prototype.doit = function () {
            return this.plot_view.save('bokeh_plot');
        };
        return SaveToolView;
    }(action_tool_1.ActionToolView);
    var SaveTool = function (_super) {
        tslib_1.__extends(SaveTool, _super);
        function SaveTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SaveTool;
    }(action_tool_1.ActionTool);
    exports.SaveTool = SaveTool;
    ;
    SaveTool.prototype.default_view = exports.SaveToolView;
    SaveTool.prototype.type = 'SaveTool';
    SaveTool.prototype.tool_name = 'Save';
    SaveTool.prototype.icon = 'bk-tool-icon-save';    
},
/*models/tools/actions/undo_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var action_tool_1 = require(207    /* ./action_tool */);
    exports.UndoToolView = function (_super) {
        tslib_1.__extends(UndoToolView, _super);
        function UndoToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UndoToolView.prototype.initialize = function (options) {
            var _this = this;
            _super.prototype.initialize.call(this, options);
            return this.connect(this.plot_view.state_changed, function () {
                return _this.model.disabled = !_this.plot_view.can_undo();
            });
        };
        UndoToolView.prototype.doit = function () {
            return this.plot_view.undo();
        };
        return UndoToolView;
    }(action_tool_1.ActionToolView);
    var UndoTool = function (_super) {
        tslib_1.__extends(UndoTool, _super);
        function UndoTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return UndoTool;
    }(action_tool_1.ActionTool);
    exports.UndoTool = UndoTool;
    ;
    UndoTool.prototype.default_view = exports.UndoToolView;
    UndoTool.prototype.type = 'UndoTool';
    UndoTool.prototype.tool_name = 'Undo';
    UndoTool.prototype.icon = 'bk-tool-icon-undo';
    UndoTool.override({ disabled: true });    
},
/*models/tools/actions/zoom_in_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var action_tool_1 = require(207    /* ./action_tool */);
    var zoom_1 = require(44    /* core/util/zoom */);
    var p = require(15    /* core/properties */);
    exports.ZoomInToolView = function (_super) {
        tslib_1.__extends(ZoomInToolView, _super);
        function ZoomInToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ZoomInToolView.prototype.doit = function () {
            var dims, frame, h_axis, ref, v_axis, zoom_info;
            frame = this.plot_model.frame;
            dims = this.model.dimensions;
            // restrict to axis configured in tool's dimensions property
            h_axis = dims === 'width' || dims === 'both';
            v_axis = dims === 'height' || dims === 'both';
            zoom_info = zoom_1.scale_range(frame, this.model.factor, h_axis, v_axis);
            this.plot_view.push_state('zoom_out', { range: zoom_info });
            this.plot_view.update_range(zoom_info, false, true);
            if ((ref = this.model.document) != null) {
                ref.interactive_start(this.plot_model.plot);
            }
            return null;
        };
        return ZoomInToolView;
    }(action_tool_1.ActionToolView);
    var ZoomInTool = function (_super) {
        tslib_1.__extends(ZoomInTool, _super);
        function ZoomInTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ZoomInTool;
    }(action_tool_1.ActionTool);
    exports.ZoomInTool = ZoomInTool;
    ;
    ZoomInTool.prototype.default_view = exports.ZoomInToolView;
    ZoomInTool.prototype.type = 'ZoomInTool';
    ZoomInTool.prototype.tool_name = 'Zoom In';
    ZoomInTool.prototype.icon = 'bk-tool-icon-zoom-in';
    ZoomInTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    ZoomInTool.define({
        factor: [
            p.Percent,
            0.1
        ],
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });    
},
/*models/tools/actions/zoom_out_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var action_tool_1 = require(207    /* ./action_tool */);
    var zoom_1 = require(44    /* core/util/zoom */);
    var p = require(15    /* core/properties */);
    exports.ZoomOutToolView = function (_super) {
        tslib_1.__extends(ZoomOutToolView, _super);
        function ZoomOutToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ZoomOutToolView.prototype.doit = function () {
            var dims, frame, h_axis, ref, v_axis, zoom_info;
            frame = this.plot_model.frame;
            dims = this.model.dimensions;
            // restrict to axis configured in tool's dimensions property
            h_axis = dims === 'width' || dims === 'both';
            v_axis = dims === 'height' || dims === 'both';
            // zooming out requires a negative factor to scale_range
            zoom_info = zoom_1.scale_range(frame, -this.model.factor, h_axis, v_axis);
            this.plot_view.push_state('zoom_out', { range: zoom_info });
            this.plot_view.update_range(zoom_info, false, true);
            if ((ref = this.model.document) != null) {
                ref.interactive_start(this.plot_model.plot);
            }
            return null;
        };
        return ZoomOutToolView;
    }(action_tool_1.ActionToolView);
    var ZoomOutTool = function (_super) {
        tslib_1.__extends(ZoomOutTool, _super);
        function ZoomOutTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ZoomOutTool;
    }(action_tool_1.ActionTool);
    exports.ZoomOutTool = ZoomOutTool;
    ;
    ZoomOutTool.prototype.default_view = exports.ZoomOutToolView;
    ZoomOutTool.prototype.type = 'ZoomOutTool';
    ZoomOutTool.prototype.tool_name = 'Zoom Out';
    ZoomOutTool.prototype.icon = 'bk-tool-icon-zoom-out';
    ZoomOutTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    ZoomOutTool.define({
        factor: [
            p.Percent,
            0.1
        ],
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });    
},
/*models/tools/button_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var dom_view_1 = require(6    /* core/dom_view */);
    var tool_1 = require(231    /* ./tool */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var ButtonToolButtonView = function (_super) {
        tslib_1.__extends(ButtonToolButtonView, _super);
        function ButtonToolButtonView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ButtonToolButtonView.prototype.initialize = function (options) {
            var _this = this;
            _super.prototype.initialize.call(this, options);
            this.connect(this.model.change, function () {
                return _this.render();
            });
            this.el.addEventListener('click', function (e) {
                e.stopPropagation();
                e.preventDefault();
                return _this._clicked();
            });
            return this.render();
        };
        ButtonToolButtonView.prototype.render = function () {
            dom_1.empty(this.el);
            this.el.disabled = this.model.disabled;
            this.el.classList.add(this.model.icon);
            return this.el.title = this.model.tooltip;
        };
        ButtonToolButtonView.prototype._clicked = function () {
        };
        return ButtonToolButtonView;
    }(dom_view_1.DOMView);
    exports.ButtonToolButtonView = ButtonToolButtonView;
    ;
    ButtonToolButtonView.prototype.className = 'bk-toolbar-button';
    exports.ButtonToolView = function (_super) {
        tslib_1.__extends(ButtonToolView, _super);
        function ButtonToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ButtonToolView;
    }(tool_1.ToolView);
    var ButtonTool = function (_super) {
        tslib_1.__extends(ButtonTool, _super);
        function ButtonTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ButtonTool;
    }(tool_1.Tool);
    exports.ButtonTool = ButtonTool;
    ;
    ButtonTool.prototype.button_view = ButtonToolButtonView;
    ButtonTool.prototype.icon = null;
    ButtonTool.getters({
        tooltip: function () {
            return this.tool_name;
        }
    });
    ButtonTool.internal({
        disabled: [
            p.Boolean,
            false
        ]
    });    
},
/*models/tools/gestures/box_select_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var DEFAULT_BOX_OVERLAY;
    var select_tool_1 = require(222    /* ./select_tool */);
    var box_annotation_1 = require(55    /* ../../annotations/box_annotation */);
    var p = require(15    /* core/properties */);
    exports.BoxSelectToolView = function (_super) {
        tslib_1.__extends(BoxSelectToolView, _super);
        function BoxSelectToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoxSelectToolView.prototype._pan_start = function (e) {
            var sx, sy;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            this._base_point = [
                sx,
                sy
            ];
            return null;
            var _a;
        };
        BoxSelectToolView.prototype._pan = function (e) {
            var append, curpoint, dims, frame, ref, sx, sxlim, sy, sylim;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            curpoint = [
                sx,
                sy
            ];
            frame = this.plot_model.frame;
            dims = this.model.dimensions;
            _b = this.model._get_dim_limits(this._base_point, curpoint, frame, dims), sxlim = _b[0], sylim = _b[1];
            this.model.overlay.update({
                left: sxlim[0],
                right: sxlim[1],
                top: sylim[0],
                bottom: sylim[1]
            });
            if (this.model.select_every_mousemove) {
                append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
                this._do_select(sxlim, sylim, false, append);
            }
            return null;
            var _a, _b;
        };
        BoxSelectToolView.prototype._pan_end = function (e) {
            var append, curpoint, dims, frame, ref, sx, sxlim, sy, sylim;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            curpoint = [
                sx,
                sy
            ];
            frame = this.plot_model.frame;
            dims = this.model.dimensions;
            _b = this.model._get_dim_limits(this._base_point, curpoint, frame, dims), sxlim = _b[0], sylim = _b[1];
            append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
            this._do_select(sxlim, sylim, true, append);
            this.model.overlay.update({
                left: null,
                right: null,
                top: null,
                bottom: null
            });
            this._base_point = null;
            this.plot_view.push_state('box_select', { selection: this.plot_view.get_selection() });
            return null;
            var _a, _b;
        };
        BoxSelectToolView.prototype._do_select = function (_a, _b, final, append) {
            var sx0 = _a[0], sx1 = _a[1];
            var sy0 = _b[0], sy1 = _b[1];
            if (append === void 0) {
                append = false;
            }
            var geometry;
            geometry = {
                type: 'rect',
                sx0: sx0,
                sx1: sx1,
                sy0: sy0,
                sy1: sy1
            };
            return this._select(geometry, final, append);
        };
        BoxSelectToolView.prototype._emit_callback = function (geometry) {
            var frame, r, sx0, sx1, sy0, sy1, xscale, yscale;
            r = this.computed_renderers[0];
            frame = this.plot_model.frame;
            xscale = frame.xscales[r.x_range_name];
            yscale = frame.yscales[r.y_range_name];
            sx0 = geometry.sx0, sx1 = geometry.sx1, sy0 = geometry.sy0, sy1 = geometry.sy1;
            _a = xscale.r_invert(sx0, sx1), geometry.x0 = _a[0], geometry.x1 = _a[1];
            _b = yscale.r_invert(sy0, sy1), geometry.y0 = _b[0], geometry.y1 = _b[1];
            this.model.callback.execute(this.model, { geometry: geometry });
            var _a, _b;
        };
        return BoxSelectToolView;
    }(select_tool_1.SelectToolView);
    DEFAULT_BOX_OVERLAY = function () {
        return new box_annotation_1.BoxAnnotation({
            level: 'overlay',
            render_mode: 'css',
            top_units: 'screen',
            left_units: 'screen',
            bottom_units: 'screen',
            right_units: 'screen',
            fill_color: { value: 'lightgrey' },
            fill_alpha: { value: 0.5 },
            line_color: { value: 'black' },
            line_alpha: { value: 1 },
            line_width: { value: 2 },
            line_dash: {
                value: [
                    4,
                    4
                ]
            }
        });
    };
    var BoxSelectTool = function (_super) {
        tslib_1.__extends(BoxSelectTool, _super);
        function BoxSelectTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return BoxSelectTool;
    }(select_tool_1.SelectTool);
    exports.BoxSelectTool = BoxSelectTool;
    ;
    BoxSelectTool.prototype.default_view = exports.BoxSelectToolView;
    BoxSelectTool.prototype.type = 'BoxSelectTool';
    BoxSelectTool.prototype.tool_name = 'Box Select';
    BoxSelectTool.prototype.icon = 'bk-tool-icon-box-select';
    BoxSelectTool.prototype.event_type = 'pan';
    BoxSelectTool.prototype.default_order = 30;
    BoxSelectTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ],
        select_every_mousemove: [
            p.Bool,
            false
        ],
        callback: [p.Instance],
        overlay: [
            p.Instance,
            DEFAULT_BOX_OVERLAY
        ]
    });
    BoxSelectTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });    
},
/*models/tools/gestures/box_zoom_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var DEFAULT_BOX_OVERLAY;
    var gesture_tool_1 = require(218    /* ./gesture_tool */);
    var box_annotation_1 = require(55    /* ../../annotations/box_annotation */);
    var p = require(15    /* core/properties */);
    exports.BoxZoomToolView = function (_super) {
        tslib_1.__extends(BoxZoomToolView, _super);
        function BoxZoomToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoxZoomToolView.prototype._match_aspect = function (base_point, curpoint, frame) {
            var a, bottom, left, right, top, va, vh, vw, xmod, ymod;
            // aspect ratio of plot frame
            a = frame.bbox.aspect;
            // current aspect of cursor-defined box
            vw = Math.abs(base_point[0] - curpoint[0]);
            vh = Math.abs(base_point[1] - curpoint[1]);
            if (vh === 0) {
                va = 0;
            } else {
                va = vw / vh;
            }
            if (va >= a) {
                _a = [
                    1,
                    va / a
                ], xmod = _a[0], ymod = _a[1];
            } else {
                _b = [
                    a / va,
                    1
                ], xmod = _b[0], ymod = _b[1];
            }
            // OK the code blocks below merit some explanation. They do:
            // compute left/right, pin to frame if necessary
            // compute top/bottom (based on new left/right), pin to frame if necessary
            // recompute left/right (based on top/bottom), in case top/bottom were pinned
            // base_point[0] is left
            if (base_point[0] <= curpoint[0]) {
                left = base_point[0];
                right = base_point[0] + vw * xmod;
                if (right > hend) {
                    right = hend;
                }
            } else {
                // base_point[0] is right
                right = base_point[0];
                left = base_point[0] - vw * xmod;
                if (left < hstart) {
                    left = hstart;
                }
            }
            vw = Math.abs(right - left);
            // base_point[1] is bottom
            if (base_point[1] <= curpoint[1]) {
                bottom = base_point[1];
                top = base_point[1] + vw / a;
                if (top > vend) {
                    top = vend;
                }
            } else {
                // base_point[1] is top
                top = base_point[1];
                bottom = base_point[1] - vw / a;
                if (bottom < vstart) {
                    bottom = vstart;
                }
            }
            vh = Math.abs(top - bottom);
            // base_point[0] is left
            if (base_point[0] <= curpoint[0]) {
                right = base_point[0] + a * vh;
            } else {
                // base_point[0] is right
                left = base_point[0] - a * vh;
            }
            return [
                [
                    left,
                    right
                ],
                [
                    bottom,
                    top
                ]
            ];
            var _a, _b;
        };
        BoxZoomToolView.prototype._pan_start = function (e) {
            this._base_point = [
                e.bokeh.sx,
                e.bokeh.sy
            ];
            return null;
        };
        BoxZoomToolView.prototype._pan = function (e) {
            var curpoint, dims, frame, sx, sy;
            curpoint = [
                e.bokeh.sx,
                e.bokeh.sy
            ];
            frame = this.plot_model.frame;
            dims = this.model.dimensions;
            if (this.model.match_aspect && dims === 'both') {
                _a = this._match_aspect(this._base_point, curpoint, frame), sx = _a[0], sy = _a[1];
            } else {
                _b = this.model._get_dim_limits(this._base_point, curpoint, frame, dims), sx = _b[0], sy = _b[1];
            }
            this.model.overlay.update({
                left: sx[0],
                right: sx[1],
                top: sy[0],
                bottom: sy[1]
            });
            return null;
            var _a, _b;
        };
        BoxZoomToolView.prototype._pan_end = function (e) {
            var curpoint, dims, frame, sx, sy;
            curpoint = [
                e.bokeh.sx,
                e.bokeh.sy
            ];
            frame = this.plot_model.frame;
            dims = this.model.dimensions;
            if (this.model.match_aspect && dims === 'both') {
                _a = this._match_aspect(this._base_point, curpoint, frame), sx = _a[0], sy = _a[1];
            } else {
                _b = this.model._get_dim_limits(this._base_point, curpoint, frame, dims), sx = _b[0], sy = _b[1];
            }
            this._update(sx, sy);
            this.model.overlay.update({
                left: null,
                right: null,
                top: null,
                bottom: null
            });
            this._base_point = null;
            return null;
            var _a, _b;
        };
        BoxZoomToolView.prototype._update = function (_a, _b) {
            var sx0 = _a[0], sx1 = _a[1];
            var sy0 = _b[0], sy1 = _b[1];
            var end, name, ref, ref1, scale, start, xrs, yrs, zoom_info;
            // If the viewing window is too small, no-op: it is likely that the user did
            // not intend to make this box zoom and instead was trying to cancel out of the
            // zoom, a la matplotlib's ToolZoom. Like matplotlib, set the threshold at 5 pixels.
            if (Math.abs(sx1 - sx0) <= 5 || Math.abs(sy1 - sy0) <= 5) {
                return;
            }
            xrs = {};
            ref = this.plot_view.frame.xscales;
            for (name in ref) {
                scale = ref[name];
                _c = scale.r_invert(sx0, sx1), start = _c[0], end = _c[1];
                xrs[name] = {
                    start: start,
                    end: end
                };
            }
            yrs = {};
            ref1 = this.plot_view.frame.yscales;
            for (name in ref1) {
                scale = ref1[name];
                _d = scale.r_invert(sy0, sy1), start = _d[0], end = _d[1];
                yrs[name] = {
                    start: start,
                    end: end
                };
            }
            zoom_info = {
                xrs: xrs,
                yrs: yrs
            };
            this.plot_view.push_state('box_zoom', { range: zoom_info });
            return this.plot_view.update_range(zoom_info);
            var _c, _d;
        };
        return BoxZoomToolView;
    }(gesture_tool_1.GestureToolView);
    DEFAULT_BOX_OVERLAY = function () {
        return new box_annotation_1.BoxAnnotation({
            level: 'overlay',
            render_mode: 'css',
            top_units: 'screen',
            left_units: 'screen',
            bottom_units: 'screen',
            right_units: 'screen',
            fill_color: { value: 'lightgrey' },
            fill_alpha: { value: 0.5 },
            line_color: { value: 'black' },
            line_alpha: { value: 1 },
            line_width: { value: 2 },
            line_dash: {
                value: [
                    4,
                    4
                ]
            }
        });
    };
    var BoxZoomTool = function (_super) {
        tslib_1.__extends(BoxZoomTool, _super);
        function BoxZoomTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return BoxZoomTool;
    }(gesture_tool_1.GestureTool);
    exports.BoxZoomTool = BoxZoomTool;
    ;
    BoxZoomTool.prototype.default_view = exports.BoxZoomToolView;
    BoxZoomTool.prototype.type = 'BoxZoomTool';
    BoxZoomTool.prototype.tool_name = 'Box Zoom';
    BoxZoomTool.prototype.icon = 'bk-tool-icon-box-zoom';
    BoxZoomTool.prototype.event_type = 'pan';
    BoxZoomTool.prototype.default_order = 20;
    BoxZoomTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    BoxZoomTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ],
        overlay: [
            p.Instance,
            DEFAULT_BOX_OVERLAY
        ],
        match_aspect: [
            p.Bool,
            false
        ]
    });    
},
/*models/tools/gestures/gesture_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var button_tool_1 = require(215    /* ../button_tool */);
    var on_off_button_1 = require(230    /* ../on_off_button */);
    exports.GestureToolView = function (_super) {
        tslib_1.__extends(GestureToolView, _super);
        function GestureToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GestureToolView;
    }(button_tool_1.ButtonToolView);
    var GestureTool = function (_super) {
        tslib_1.__extends(GestureTool, _super);
        function GestureTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GestureTool;
    }(button_tool_1.ButtonTool);
    exports.GestureTool = GestureTool;
    ;
    GestureTool.prototype.button_view = on_off_button_1.OnOffButtonView;
    GestureTool.prototype.event_type = null;
    GestureTool.prototype.default_order = null;    
},
/*models/tools/gestures/lasso_select_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var DEFAULT_POLY_OVERLAY;
    var select_tool_1 = require(222    /* ./select_tool */);
    var poly_annotation_1 = require(62    /* ../../annotations/poly_annotation */);
    var p = require(15    /* core/properties */);
    exports.LassoSelectToolView = function (_super) {
        tslib_1.__extends(LassoSelectToolView, _super);
        function LassoSelectToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LassoSelectToolView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.connect(this.model.properties.active.change, function () {
                return this._active_change();
            });
            return this.data = null;
        };
        LassoSelectToolView.prototype._active_change = function () {
            if (!this.model.active) {
                return this._clear_overlay();
            }
        };
        LassoSelectToolView.prototype._keyup = function (e) {
            if (e.keyCode === 13) {
                return this._clear_overlay();
            }
        };
        LassoSelectToolView.prototype._pan_start = function (e) {
            var sx, sy;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            this.data = {
                sx: [sx],
                sy: [sy]
            };
            return null;
            var _a;
        };
        LassoSelectToolView.prototype._pan = function (e) {
            var append, overlay, ref, sx, sy;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            _b = this.plot_model.frame.bbox.clip(sx, sy), sx = _b[0], sy = _b[1];
            this.data.sx.push(sx);
            this.data.sy.push(sy);
            overlay = this.model.overlay;
            overlay.update({
                xs: this.data.sx,
                ys: this.data.sy
            });
            if (this.model.select_every_mousemove) {
                append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
                return this._do_select(this.data.sx, this.data.sy, false, append);
            }
            var _a, _b;
        };
        LassoSelectToolView.prototype._pan_end = function (e) {
            var append, ref;
            this._clear_overlay();
            append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
            this._do_select(this.data.sx, this.data.sy, true, append);
            return this.plot_view.push_state('lasso_select', { selection: this.plot_view.get_selection() });
        };
        LassoSelectToolView.prototype._clear_overlay = function () {
            return this.model.overlay.update({
                xs: [],
                ys: []
            });
        };
        LassoSelectToolView.prototype._do_select = function (sx, sy, final, append) {
            var geometry;
            geometry = {
                type: 'poly',
                sx: sx,
                sy: sy
            };
            return this._select(geometry, final, append);
        };
        LassoSelectToolView.prototype._emit_callback = function (geometry) {
            var frame, r, xscale, yscale;
            r = this.computed_renderers[0];
            frame = this.plot_model.frame;
            xscale = frame.xscales[r.x_range_name];
            yscale = frame.yscales[r.y_range_name];
            geometry.x = xscale.v_invert(geometry.sx);
            geometry.y = yscale.v_invert(geometry.sy);
            this.model.callback.execute(this.model, { geometry: geometry });
        };
        return LassoSelectToolView;
    }(select_tool_1.SelectToolView);
    DEFAULT_POLY_OVERLAY = function () {
        return new poly_annotation_1.PolyAnnotation({
            level: 'overlay',
            xs_units: 'screen',
            ys_units: 'screen',
            fill_color: { value: 'lightgrey' },
            fill_alpha: { value: 0.5 },
            line_color: { value: 'black' },
            line_alpha: { value: 1 },
            line_width: { value: 2 },
            line_dash: {
                value: [
                    4,
                    4
                ]
            }
        });
    };
    var LassoSelectTool = function (_super) {
        tslib_1.__extends(LassoSelectTool, _super);
        function LassoSelectTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LassoSelectTool;
    }(select_tool_1.SelectTool);
    exports.LassoSelectTool = LassoSelectTool;
    ;
    LassoSelectTool.prototype.default_view = exports.LassoSelectToolView;
    LassoSelectTool.prototype.type = 'LassoSelectTool';
    LassoSelectTool.prototype.tool_name = 'Lasso Select';
    LassoSelectTool.prototype.icon = 'bk-tool-icon-lasso-select';
    LassoSelectTool.prototype.event_type = 'pan';
    LassoSelectTool.prototype.default_order = 12;
    LassoSelectTool.define({
        select_every_mousemove: [
            p.Bool,
            true
        ],
        callback: [p.Instance],
        overlay: [
            p.Instance,
            DEFAULT_POLY_OVERLAY
        ]
    });    
},
/*models/tools/gestures/pan_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var gesture_tool_1 = require(218    /* ./gesture_tool */);
    var p = require(15    /* core/properties */);
    exports.PanToolView = function (_super) {
        tslib_1.__extends(PanToolView, _super);
        function PanToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PanToolView.prototype._pan_start = function (e) {
            var bbox, hr, ref, sx, sy, vr;
            this.last_dx = 0;
            this.last_dy = 0;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            bbox = this.plot_view.frame.bbox;
            if (!bbox.contains(sx, sy)) {
                hr = bbox.h_range;
                vr = bbox.v_range;
                if (sx < hr.start || sx > hr.end) {
                    this.v_axis_only = true;
                }
                if (sy < vr.start || sy > vr.end) {
                    this.h_axis_only = true;
                }
            }
            return (ref = this.model.document) != null ? ref.interactive_start(this.plot_model.plot) : void 0;
            var _a;
        };
        PanToolView.prototype._pan = function (e) {
            var ref;
            this._update(e.deltaX, e.deltaY);
            return (ref = this.model.document) != null ? ref.interactive_start(this.plot_model.plot) : void 0;
        };
        PanToolView.prototype._pan_end = function (e) {
            this.h_axis_only = false;
            this.v_axis_only = false;
            if (this.pan_info != null) {
                return this.plot_view.push_state('pan', { range: this.pan_info });
            }
        };
        PanToolView.prototype._update = function (dx, dy) {
            var dims, end, frame, hr, is_panning, name, new_dx, new_dy, ref, ref1, scale, sdx, sdy, start, sx0, sx1, sx_high, sx_low, sy0, sy1, sy_high, sy_low, vr, xrs, yrs;
            frame = this.plot_view.frame;
            new_dx = dx - this.last_dx;
            new_dy = dy - this.last_dy;
            hr = frame.bbox.h_range;
            sx_low = hr.start - new_dx;
            sx_high = hr.end - new_dx;
            vr = frame.bbox.v_range;
            sy_low = vr.start - new_dy;
            sy_high = vr.end - new_dy;
            dims = this.model.dimensions;
            if ((dims === 'width' || dims === 'both') && !this.v_axis_only) {
                sx0 = sx_low;
                sx1 = sx_high;
                sdx = -new_dx;
            } else {
                sx0 = hr.start;
                sx1 = hr.end;
                sdx = 0;
            }
            if ((dims === 'height' || dims === 'both') && !this.h_axis_only) {
                sy0 = sy_low;
                sy1 = sy_high;
                sdy = -new_dy;
            } else {
                sy0 = vr.start;
                sy1 = vr.end;
                sdy = 0;
            }
            this.last_dx = dx;
            this.last_dy = dy;
            xrs = {};
            ref = frame.xscales;
            for (name in ref) {
                scale = ref[name];
                _a = scale.r_invert(sx0, sx1), start = _a[0], end = _a[1];
                xrs[name] = {
                    start: start,
                    end: end
                };
            }
            yrs = {};
            ref1 = frame.yscales;
            for (name in ref1) {
                scale = ref1[name];
                _b = scale.r_invert(sy0, sy1), start = _b[0], end = _b[1];
                yrs[name] = {
                    start: start,
                    end: end
                };
            }
            this.pan_info = {
                xrs: xrs,
                yrs: yrs,
                sdx: sdx,
                sdy: sdy
            };
            this.plot_view.update_range(this.pan_info, is_panning = true);
            return null;
            var _a, _b;
        };
        return PanToolView;
    }(gesture_tool_1.GestureToolView);
    var PanTool = function (_super) {
        tslib_1.__extends(PanTool, _super);
        function PanTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return PanTool;
    }(gesture_tool_1.GestureTool);
    exports.PanTool = PanTool;
    ;
    PanTool.prototype.default_view = exports.PanToolView;
    PanTool.prototype.type = 'PanTool';
    PanTool.prototype.tool_name = 'Pan';
    PanTool.prototype.event_type = 'pan';
    PanTool.prototype.default_order = 10;
    PanTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });
    PanTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip('Pan', this.dimensions);
        },
        icon: function () {
            var suffix;
            suffix = function () {
                switch (this.dimensions) {
                case 'both':
                    return 'pan';
                case 'width':
                    return 'xpan';
                case 'height':
                    return 'ypan';
                }
            }.call(this);
            return 'bk-tool-icon-' + suffix;
        }
    });    
},
/*models/tools/gestures/poly_select_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var DEFAULT_POLY_OVERLAY;
    var select_tool_1 = require(222    /* ./select_tool */);
    var poly_annotation_1 = require(62    /* ../../annotations/poly_annotation */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    exports.PolySelectToolView = function (_super) {
        tslib_1.__extends(PolySelectToolView, _super);
        function PolySelectToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PolySelectToolView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.connect(this.model.properties.active.change, function () {
                return this._active_change();
            });
            return this.data = {
                sx: [],
                sy: []
            };
        };
        PolySelectToolView.prototype._active_change = function () {
            if (!this.model.active) {
                return this._clear_data();
            }
        };
        PolySelectToolView.prototype._keyup = function (e) {
            if (e.keyCode === 13) {
                return this._clear_data();
            }
        };
        PolySelectToolView.prototype._doubletap = function (e) {
            var append, ref;
            append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
            this._do_select(this.data.sx, this.data.sy, true, append);
            this.plot_view.push_state('poly_select', { selection: this.plot_view.get_selection() });
            return this._clear_data();
        };
        PolySelectToolView.prototype._clear_data = function () {
            this.data = {
                sx: [],
                sy: []
            };
            return this.model.overlay.update({
                xs: [],
                ys: []
            });
        };
        PolySelectToolView.prototype._tap = function (e) {
            var frame, sx, sy;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            frame = this.plot_model.frame;
            if (!frame.bbox.contains(sx, sy)) {
                return;
            }
            this.data.sx.push(sx);
            this.data.sy.push(sy);
            return this.model.overlay.update({
                xs: array_1.copy(this.data.sx),
                ys: array_1.copy(this.data.sy)
            });
            var _a;
        };
        PolySelectToolView.prototype._do_select = function (sx, sy, final, append) {
            var geometry;
            geometry = {
                type: 'poly',
                sx: sx,
                sy: sy
            };
            return this._select(geometry, final, append);
        };
        PolySelectToolView.prototype._emit_callback = function (geometry) {
            var frame, r, xscale, yscale;
            r = this.computed_renderers[0];
            frame = this.plot_model.frame;
            xscale = frame.xscales[r.x_range_name];
            yscale = frame.yscales[r.y_range_name];
            geometry.x = xscale.v_invert(geometry.sx);
            geometry.y = xscale.v_invert(geometry.sy);
            this.model.callback.execute(this.model, { geometry: geometry });
        };
        return PolySelectToolView;
    }(select_tool_1.SelectToolView);
    DEFAULT_POLY_OVERLAY = function () {
        return new poly_annotation_1.PolyAnnotation({
            level: 'overlay',
            xs_units: 'screen',
            ys_units: 'screen',
            fill_color: { value: 'lightgrey' },
            fill_alpha: { value: 0.5 },
            line_color: { value: 'black' },
            line_alpha: { value: 1 },
            line_width: { value: 2 },
            line_dash: {
                value: [
                    4,
                    4
                ]
            }
        });
    };
    var PolySelectTool = function (_super) {
        tslib_1.__extends(PolySelectTool, _super);
        function PolySelectTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return PolySelectTool;
    }(select_tool_1.SelectTool);
    exports.PolySelectTool = PolySelectTool;
    ;
    PolySelectTool.prototype.default_view = exports.PolySelectToolView;
    PolySelectTool.prototype.type = 'PolySelectTool';
    PolySelectTool.prototype.tool_name = 'Poly Select';
    PolySelectTool.prototype.icon = 'bk-tool-icon-polygon-select';
    PolySelectTool.prototype.event_type = 'tap';
    PolySelectTool.prototype.default_order = 11;
    PolySelectTool.define({
        callback: [p.Instance],
        overlay: [
            p.Instance,
            DEFAULT_POLY_OVERLAY
        ]
    });    
},
/*models/tools/gestures/select_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var gesture_tool_1 = require(218    /* ./gesture_tool */);
    var glyph_renderer_1 = require(161    /* ../../renderers/glyph_renderer */);
    var graph_renderer_1 = require(162    /* ../../renderers/graph_renderer */);
    var logging_1 = require(14    /* core/logging */);
    var p = require(15    /* core/properties */);
    var object_1 = require(30    /* core/util/object */);
    var bokeh_events_1 = require(3    /* core/bokeh_events */);
    var SelectToolView = function (_super) {
        tslib_1.__extends(SelectToolView, _super);
        function SelectToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SelectToolView.prototype._computed_renderers_by_data_source = function () {
            var j, len, r, ref, renderers_by_source, source;
            renderers_by_source = {};
            ref = this.computed_renderers;
            for (j = 0, len = ref.length; j < len; j++) {
                r = ref[j];
                if (r instanceof graph_renderer_1.GraphRenderer) {
                    source = r.node_renderer.data_source.id;
                } else if (r instanceof glyph_renderer_1.GlyphRenderer) {
                    source = r.data_source.id;
                }
                if (!(source in renderers_by_source)) {
                    renderers_by_source[source] = [r];
                } else {
                    renderers_by_source[source] = renderers_by_source[source].concat([r]);
                }
            }
            return renderers_by_source;
        };
        SelectToolView.prototype._keyup = function (e) {
            var ds, j, len, r, ref, results, sm;
            if (e.keyCode === 27) {
                ref = this.computed_renderers;
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    r = ref[j];
                    ds = r.data_source;
                    sm = ds.selection_manager;
                    results.push(sm.clear());
                }
                return results;
            }
        };
        SelectToolView.prototype._select = function (geometry, final, append) {
            var _, j, len, r, r_views, renderers, renderers_by_source, sm;
            renderers_by_source = this._computed_renderers_by_data_source();
            for (_ in renderers_by_source) {
                renderers = renderers_by_source[_];
                sm = renderers[0].get_selection_manager();
                r_views = [];
                for (j = 0, len = renderers.length; j < len; j++) {
                    r = renderers[j];
                    if (r.id in this.plot_view.renderer_views) {
                        r_views.push(this.plot_view.renderer_views[r.id]);
                    }
                }
                sm.select(r_views, geometry, final, append);
            }
            if (this.model.callback != null) {
                this._emit_callback(geometry);
            }
            this._emit_selection_event(geometry, final);
            return null;
        };
        SelectToolView.prototype._emit_selection_event = function (geometry, final) {
            if (final === void 0) {
                final = true;
            }
            var g, i, j, ref, xm, ym;
            g = object_1.clone(geometry);
            xm = this.plot_view.frame.xscales['default'];
            ym = this.plot_view.frame.yscales['default'];
            switch (g.type) {
            case 'point':
                g.x = xm.invert(g.sx);
                g.y = ym.invert(g.sy);
                break;
            case 'rect':
                _a = xm.r_invert(g.sx0, g.sx1), g.x0 = _a[0], g.x1 = _a[1];
                _b = ym.r_invert(g.sy0, g.sy1), g.y0 = _b[0], g.y1 = _b[1];
                break;
            case 'poly':
                g.x = new Array(g.sx.length);
                g.y = new Array(g.sy.length);
                for (i = j = 0, ref = g.sx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    g.x[i] = xm.invert(g.sx[i]);
                    g.y[i] = ym.invert(g.sy[i]);
                }
                break;
            default:
                logging_1.logger.debug('Unrecognized selection geometry type: \'' + g.type + '\'');
            }
            return this.plot_model.plot.trigger_event(new bokeh_events_1.SelectionGeometry({
                geometry: g,
                final: final
            }));
            var _a, _b;
        };
        return SelectToolView;
    }(gesture_tool_1.GestureToolView);
    exports.SelectToolView = SelectToolView;
    ;
    SelectToolView.getters({
        computed_renderers: function () {
            var all_renderers, names, r, renderers;
            renderers = this.model.renderers;
            names = this.model.names;
            if (renderers.length === 0) {
                all_renderers = this.plot_model.plot.renderers;
                renderers = function () {
                    var j, len, results;
                    results = [];
                    for (j = 0, len = all_renderers.length; j < len; j++) {
                        r = all_renderers[j];
                        if (r instanceof glyph_renderer_1.GlyphRenderer || r instanceof graph_renderer_1.GraphRenderer) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
            }
            if (names.length > 0) {
                renderers = function () {
                    var j, len, results;
                    results = [];
                    for (j = 0, len = renderers.length; j < len; j++) {
                        r = renderers[j];
                        if (names.indexOf(r.name) >= 0) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
            }
            return renderers;
        }
    });
    var SelectTool = function (_super) {
        tslib_1.__extends(SelectTool, _super);
        function SelectTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SelectTool;
    }(gesture_tool_1.GestureTool);
    exports.SelectTool = SelectTool;
    ;
    SelectTool.define({
        renderers: [
            p.Array,
            []
        ],
        names: [
            p.Array,
            []
        ]
    });
    SelectTool.internal({
        multi_select_modifier: [
            p.String,
            'shift'
        ]
    });    
},
/*models/tools/gestures/tap_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var select_tool_1 = require(222    /* ./select_tool */);
    var p = require(15    /* core/properties */);
    var types_1 = require(42    /* core/util/types */);
    exports.TapToolView = function (_super) {
        tslib_1.__extends(TapToolView, _super);
        function TapToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TapToolView.prototype._tap = function (e) {
            var append, ref, sx, sy;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            append = (ref = e.srcEvent.shiftKey) != null ? ref : false;
            return this._select(sx, sy, true, append);
            var _a;
        };
        TapToolView.prototype._select = function (sx, sy, final, append) {
            var _, callback, cb_data, did_hit, geometry, i, len, r, r_views, ref, renderers, renderers_by_source, sm;
            geometry = {
                type: 'point',
                sx: sx,
                sy: sy
            };
            callback = this.model.callback;
            cb_data = { geometries: geometry };
            if (this.model.behavior === 'select') {
                renderers_by_source = this._computed_renderers_by_data_source();
                for (_ in renderers_by_source) {
                    renderers = renderers_by_source[_];
                    sm = renderers[0].get_selection_manager();
                    r_views = function () {
                        var i, len, results;
                        results = [];
                        for (i = 0, len = renderers.length; i < len; i++) {
                            r = renderers[i];
                            results.push(this.plot_view.renderer_views[r.id]);
                        }
                        return results;
                    }.call(this);
                    did_hit = sm.select(r_views, geometry, final, append);
                    if (did_hit && callback != null) {
                        cb_data.source = sm.source;
                        if (types_1.isFunction(callback)) {
                            callback(this, cb_data);
                        } else {
                            callback.execute(this, cb_data);
                        }
                    }
                }
                this._emit_selection_event(geometry);
                this.plot_view.push_state('tap', {
                    selection: this.plot_view.get_selection()    // @model.behavior == "inspect"
                });
            } else {
                ref = this.computed_renderers;
                for (i = 0, len = ref.length; i < len; i++) {
                    r = ref[i];
                    sm = r.get_selection_manager();
                    did_hit = sm.inspect(this.plot_view.renderer_views[r.id], geometry);
                    if (did_hit && callback != null) {
                        cb_data.source = sm.source;
                        if (types_1.isFunction(callback)) {
                            callback(this, cb_data);
                        } else {
                            callback.execute(this, cb_data);
                        }
                    }
                }
            }
            return null;
        };
        return TapToolView;
    }(select_tool_1.SelectToolView);
    var TapTool = function (_super) {
        tslib_1.__extends(TapTool, _super);
        function TapTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TapTool;
    }(select_tool_1.SelectTool);
    exports.TapTool = TapTool;
    ;
    TapTool.prototype.default_view = exports.TapToolView;
    TapTool.prototype.type = 'TapTool';
    TapTool.prototype.tool_name = 'Tap';
    TapTool.prototype.icon = 'bk-tool-icon-tap-select';
    TapTool.prototype.event_type = 'tap';
    TapTool.prototype.default_order = 10;
    TapTool.define({
        behavior: [
            p.String,
            'select'    // TODO: Enum("select", "inspect")
        ],
        callback: [p.Any]    // TODO: p.Either(p.Instance(Callback), p.Function) ]
    });    
},
/*models/tools/gestures/wheel_pan_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var gesture_tool_1 = require(218    /* ./gesture_tool */);
    var p = require(15    /* core/properties */);
    exports.WheelPanToolView = function (_super) {
        tslib_1.__extends(WheelPanToolView, _super);
        function WheelPanToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WheelPanToolView.prototype._scroll = function (e) {
            var factor;
            factor = this.model.speed * e.bokeh.delta;
            // clamp the magnitude of factor, if it is > 1 bad things happen
            if (factor > 0.9) {
                factor = 0.9;
            } else if (factor < -0.9) {
                factor = -0.9;
            }
            return this._update_ranges(factor);
        };
        WheelPanToolView.prototype._update_ranges = function (factor) {
            var end, frame, hr, name, pan_info, ref, ref1, ref2, scale, start, sx0, sx1, sx_high, sx_low, sx_range, sy0, sy1, sy_high, sy_low, sy_range, vr, xrs, yrs;
            frame = this.plot_model.frame;
            hr = frame.bbox.h_range;
            vr = frame.bbox.v_range;
            _a = [
                hr.start,
                hr.end
            ], sx_low = _a[0], sx_high = _a[1];
            _b = [
                vr.start,
                vr.end
            ], sy_low = _b[0], sy_high = _b[1];
            switch (this.model.dimension) {
            case 'height':
                sy_range = Math.abs(sy_high - sy_low);
                sx0 = sx_low;
                sx1 = sx_high;
                sy0 = sy_low - sy_range * factor;
                sy1 = sy_high - sy_range * factor;
                break;
            case 'width':
                sx_range = Math.abs(sx_high - sx_low);
                sx0 = sx_low - sx_range * factor;
                sx1 = sx_high - sx_range * factor;
                sy0 = sy_low;
                sy1 = sy_high;
            }
            xrs = {};
            ref = frame.xscales;
            for (name in ref) {
                scale = ref[name];
                _c = scale.r_invert(sx0, sx1), start = _c[0], end = _c[1];
                xrs[name] = {
                    start: start,
                    end: end
                };
            }
            yrs = {};
            ref1 = frame.yscales;
            for (name in ref1) {
                scale = ref1[name];
                _d = scale.r_invert(sy0, sy1), start = _d[0], end = _d[1];
                yrs[name] = {
                    start: start,
                    end: end
                };
            }
            // OK this sucks we can't set factor independently in each direction. It is used
            // for GMap plots, and GMap plots always preserve aspect, so effective the value
            // of 'dimensions' is ignored.
            pan_info = {
                xrs: xrs,
                yrs: yrs,
                factor: factor
            };
            this.plot_view.push_state('wheel_pan', { range: pan_info });
            this.plot_view.update_range(pan_info, false, true);
            if ((ref2 = this.model.document) != null) {
                ref2.interactive_start(this.plot_model.plot);
            }
            return null;
            var _a, _b, _c, _d;
        };
        return WheelPanToolView;
    }(gesture_tool_1.GestureToolView);
    var WheelPanTool = function (_super) {
        tslib_1.__extends(WheelPanTool, _super);
        function WheelPanTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return WheelPanTool;
    }(gesture_tool_1.GestureTool);
    exports.WheelPanTool = WheelPanTool;
    ;
    WheelPanTool.prototype.type = 'WheelPanTool';
    WheelPanTool.prototype.default_view = exports.WheelPanToolView;
    WheelPanTool.prototype.tool_name = 'Wheel Pan';
    WheelPanTool.prototype.icon = 'bk-tool-icon-wheel-pan';
    WheelPanTool.prototype.event_type = 'scroll';
    WheelPanTool.prototype.default_order = 12;
    WheelPanTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimension);
        }
    });
    WheelPanTool.define({
        dimension: [
            p.Dimension,
            'width'
        ]
    });
    WheelPanTool.internal({
        speed: [
            p.Number,
            1 / 1000
        ]
    });    
},
/*models/tools/gestures/wheel_zoom_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var gesture_tool_1 = require(218    /* ./gesture_tool */);
    var zoom_1 = require(44    /* core/util/zoom */);
    var p = require(15    /* core/properties */);
    exports.WheelZoomToolView = function (_super) {
        tslib_1.__extends(WheelZoomToolView, _super);
        function WheelZoomToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WheelZoomToolView.prototype._pinch = function (e) {
            var delta;
            // TODO (bev) this can probably be done much better
            if (e.scale >= 1) {
                delta = (e.scale - 1) * 20;
            } else {
                delta = -20 / e.scale;
            }
            e.bokeh.delta = delta;
            return this._scroll(e);
        };
        WheelZoomToolView.prototype._scroll = function (e) {
            var dims, factor, frame, h_axis, hr, ref, sx, sy, v_axis, vr, zoom_info;
            frame = this.plot_model.frame;
            hr = frame.bbox.h_range;
            vr = frame.bbox.v_range;
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            dims = this.model.dimensions;
            // restrict to axis configured in tool's dimensions property and if
            // zoom origin is inside of frame range/domain
            h_axis = (dims === 'width' || dims === 'both') && (hr.start < sx && sx < hr.end);
            v_axis = (dims === 'height' || dims === 'both') && (vr.start < sy && sy < vr.end);
            factor = this.model.speed * e.bokeh.delta;
            zoom_info = zoom_1.scale_range(frame, factor, h_axis, v_axis, {
                x: sx,
                y: sy
            });
            this.plot_view.push_state('wheel_zoom', { range: zoom_info });
            this.plot_view.update_range(zoom_info, false, true);
            if ((ref = this.model.document) != null) {
                ref.interactive_start(this.plot_model.plot);
            }
            return null;
            var _a;
        };
        return WheelZoomToolView;
    }(gesture_tool_1.GestureToolView);
    var WheelZoomTool = function (_super) {
        tslib_1.__extends(WheelZoomTool, _super);
        function WheelZoomTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return WheelZoomTool;
    }(gesture_tool_1.GestureTool);
    exports.WheelZoomTool = WheelZoomTool;
    ;
    WheelZoomTool.prototype.default_view = exports.WheelZoomToolView;
    WheelZoomTool.prototype.type = 'WheelZoomTool';
    WheelZoomTool.prototype.tool_name = 'Wheel Zoom';
    WheelZoomTool.prototype.icon = 'bk-tool-icon-wheel-zoom';
    WheelZoomTool.prototype.event_type = 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? 'pinch' : 'scroll';
    WheelZoomTool.prototype.default_order = 10;
    WheelZoomTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip(this.tool_name, this.dimensions);
        }
    });
    WheelZoomTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ]
    });
    WheelZoomTool.internal({
        speed: [
            p.Number,
            1 / 600
        ]
    });    
},
/*models/tools/index*/
function _(require, module, exports) {
    var action_tool_1 = require(207    /* ./actions/action_tool */);
    exports.ActionTool = action_tool_1.ActionTool;
    var help_tool_1 = require(208    /* ./actions/help_tool */);
    exports.HelpTool = help_tool_1.HelpTool;
    var redo_tool_1 = require(209    /* ./actions/redo_tool */);
    exports.RedoTool = redo_tool_1.RedoTool;
    var reset_tool_1 = require(210    /* ./actions/reset_tool */);
    exports.ResetTool = reset_tool_1.ResetTool;
    var save_tool_1 = require(211    /* ./actions/save_tool */);
    exports.SaveTool = save_tool_1.SaveTool;
    var undo_tool_1 = require(212    /* ./actions/undo_tool */);
    exports.UndoTool = undo_tool_1.UndoTool;
    var zoom_in_tool_1 = require(213    /* ./actions/zoom_in_tool */);
    exports.ZoomInTool = zoom_in_tool_1.ZoomInTool;
    var zoom_out_tool_1 = require(214    /* ./actions/zoom_out_tool */);
    exports.ZoomOutTool = zoom_out_tool_1.ZoomOutTool;
    var button_tool_1 = require(215    /* ./button_tool */);
    exports.ButtonTool = button_tool_1.ButtonTool;
    var box_select_tool_1 = require(216    /* ./gestures/box_select_tool */);
    exports.BoxSelectTool = box_select_tool_1.BoxSelectTool;
    var box_zoom_tool_1 = require(217    /* ./gestures/box_zoom_tool */);
    exports.BoxZoomTool = box_zoom_tool_1.BoxZoomTool;
    var gesture_tool_1 = require(218    /* ./gestures/gesture_tool */);
    exports.GestureTool = gesture_tool_1.GestureTool;
    var lasso_select_tool_1 = require(219    /* ./gestures/lasso_select_tool */);
    exports.LassoSelectTool = lasso_select_tool_1.LassoSelectTool;
    var pan_tool_1 = require(220    /* ./gestures/pan_tool */);
    exports.PanTool = pan_tool_1.PanTool;
    var poly_select_tool_1 = require(221    /* ./gestures/poly_select_tool */);
    exports.PolySelectTool = poly_select_tool_1.PolySelectTool;
    var select_tool_1 = require(222    /* ./gestures/select_tool */);
    exports.SelectTool = select_tool_1.SelectTool;
    var tap_tool_1 = require(223    /* ./gestures/tap_tool */);
    exports.TapTool = tap_tool_1.TapTool;
    var wheel_pan_tool_1 = require(224    /* ./gestures/wheel_pan_tool */);
    exports.WheelPanTool = wheel_pan_tool_1.WheelPanTool;
    var wheel_zoom_tool_1 = require(225    /* ./gestures/wheel_zoom_tool */);
    exports.WheelZoomTool = wheel_zoom_tool_1.WheelZoomTool;
    var crosshair_tool_1 = require(227    /* ./inspectors/crosshair_tool */);
    exports.CrosshairTool = crosshair_tool_1.CrosshairTool;
    var hover_tool_1 = require(228    /* ./inspectors/hover_tool */);
    exports.HoverTool = hover_tool_1.HoverTool;
    var inspect_tool_1 = require(229    /* ./inspectors/inspect_tool */);
    exports.InspectTool = inspect_tool_1.InspectTool;
    var tool_1 = require(231    /* ./tool */);
    exports.Tool = tool_1.Tool;
    var tool_proxy_1 = require(232    /* ./tool_proxy */);
    exports.ToolProxy = tool_proxy_1.ToolProxy;
    var toolbar_1 = require(233    /* ./toolbar */);
    exports.Toolbar = toolbar_1.Toolbar;
    var toolbar_base_1 = require(234    /* ./toolbar_base */);
    exports.ToolbarBase = toolbar_base_1.ToolbarBase;
    var toolbar_box_1 = require(235    /* ./toolbar_box */);
    exports.ProxyToolbar = toolbar_box_1.ProxyToolbar;
    var toolbar_box_2 = require(235    /* ./toolbar_box */);
    exports.ToolbarBox = toolbar_box_2.ToolbarBox;    
},
/*models/tools/inspectors/crosshair_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var inspect_tool_1 = require(229    /* ./inspect_tool */);
    var span_1 = require(63    /* ../../annotations/span */);
    var p = require(15    /* core/properties */);
    var object_1 = require(30    /* core/util/object */);
    exports.CrosshairToolView = function (_super) {
        tslib_1.__extends(CrosshairToolView, _super);
        function CrosshairToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CrosshairToolView.prototype._move = function (e) {
            var sx, sy;
            if (!this.model.active) {
                return;
            }
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            if (!this.plot_model.frame.bbox.contains(sx, sy)) {
                sx = sy = null;
            }
            return this._update_spans(sx, sy);
            var _a;
        };
        CrosshairToolView.prototype._move_exit = function (e) {
            return this._update_spans(null, null);
        };
        CrosshairToolView.prototype._update_spans = function (x, y) {
            var dims;
            dims = this.model.dimensions;
            if (dims === 'width' || dims === 'both') {
                this.model.spans.width.computed_location = y;
            }
            if (dims === 'height' || dims === 'both') {
                return this.model.spans.height.computed_location = x;
            }
        };
        return CrosshairToolView;
    }(inspect_tool_1.InspectToolView);
    var CrosshairTool = function (_super) {
        tslib_1.__extends(CrosshairTool, _super);
        function CrosshairTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CrosshairTool.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            return this.spans = {
                width: new span_1.Span({
                    for_hover: true,
                    dimension: 'width',
                    render_mode: this.render_mode,
                    location_units: this.location_units,
                    line_color: this.line_color,
                    line_width: this.line_width,
                    line_alpha: this.line_alpha
                }),
                height: new span_1.Span({
                    for_hover: true,
                    dimension: 'height',
                    render_mode: this.render_mode,
                    location_units: this.location_units,
                    line_color: this.line_color,
                    line_width: this.line_width,
                    line_alpha: this.line_alpha
                })
            };
        };
        return CrosshairTool;
    }(inspect_tool_1.InspectTool);
    exports.CrosshairTool = CrosshairTool;
    ;
    CrosshairTool.prototype.default_view = exports.CrosshairToolView;
    CrosshairTool.prototype.type = 'CrosshairTool';
    CrosshairTool.prototype.tool_name = 'Crosshair';
    CrosshairTool.prototype.icon = 'bk-tool-icon-crosshair';
    CrosshairTool.define({
        dimensions: [
            p.Dimensions,
            'both'
        ],
        line_color: [
            p.Color,
            'black'
        ],
        line_width: [
            p.Number,
            1
        ],
        line_alpha: [
            p.Number,
            1
        ]
    });
    CrosshairTool.internal({
        location_units: [
            p.SpatialUnits,
            'screen'
        ],
        render_mode: [
            p.RenderMode,
            'css'
        ],
        spans: [p.Any]
    });
    CrosshairTool.getters({
        tooltip: function () {
            return this._get_dim_tooltip('Crosshair', this.dimensions);
        },
        synthetic_renderers: function () {
            return object_1.values(this.spans);
        }
    });    
},
/*models/tools/inspectors/hover_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var inspect_tool_1 = require(229    /* ./inspect_tool */);
    var tooltip_1 = require(67    /* ../../annotations/tooltip */);
    var glyph_renderer_1 = require(161    /* ../../renderers/glyph_renderer */);
    var graph_renderer_1 = require(162    /* ../../renderers/graph_renderer */);
    var hittest = require(9    /* core/hittest */);
    var templating_1 = require(39    /* core/util/templating */);
    var dom_1 = require(5    /* core/dom */);
    var p = require(15    /* core/properties */);
    var color_1 = require(26    /* core/util/color */);
    var object_1 = require(30    /* core/util/object */);
    var types_1 = require(42    /* core/util/types */);
    var build_views_1 = require(4    /* core/build_views */);
    exports._nearest_line_hit = function (i, geometry, sx, sy, dx, dy) {
        var d1x, d1y, d2x, d2y, dist1, dist2;
        d1x = dx[i];
        d1y = dy[i];
        d2x = dx[i + 1];
        d2y = dy[i + 1];
        if (geometry.type === 'span') {
            switch (geometry.direction) {
            case 'h':
                dist1 = Math.abs(d1x - sx);
                dist2 = Math.abs(d2x - sx);
                break;
            case 'v':
                dist1 = Math.abs(d1y - sy);
                dist2 = Math.abs(d2y - sy);
            }
        } else {
            dist1 = hittest.dist_2_pts(d1x, d1y, sx, sy);
            dist2 = hittest.dist_2_pts(d2x, d2y, sx, sy);
        }
        if (dist1 < dist2) {
            return [
                [
                    d1x,
                    d1y
                ],
                i
            ];
        } else {
            return [
                [
                    d2x,
                    d2y
                ],
                i + 1
            ];
        }
    };
    exports._line_hit = function (xs, ys, ind) {
        return [
            [
                xs[ind],
                ys[ind]
            ],
            ind
        ];
    };
    var HoverToolView = function (_super) {
        tslib_1.__extends(HoverToolView, _super);
        function HoverToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HoverToolView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.ttviews = {};
        };
        HoverToolView.prototype.remove = function () {
            build_views_1.remove_views(this.ttviews);
            return _super.prototype.remove.call(this);
        };
        HoverToolView.prototype.connect_signals = function () {
            var k, len, r, ref;
            _super.prototype.connect_signals.call(this);
            ref = this.computed_renderers;
            for (k = 0, len = ref.length; k < len; k++) {
                r = ref[k];
                if (r instanceof glyph_renderer_1.GlyphRenderer) {
                    this.connect(r.data_source.inspect, this._update);
                } else if (r instanceof graph_renderer_1.GraphRenderer) {
                    this.connect(r.node_renderer.data_source.inspect, this._update);
                    this.connect(r.edge_renderer.data_source.inspect, this._update);
                }
            }
            // TODO: @connect(@plot_model.plot.properties.renderers.change, () -> @_computed_renderers = @_ttmodels = null)
            this.connect(this.model.properties.renderers.change, function () {
                return this._computed_renderers = this._ttmodels = null;
            });
            this.connect(this.model.properties.names.change, function () {
                return this._computed_renderers = this._ttmodels = null;
            });
            return this.connect(this.model.properties.tooltips.change, function () {
                return this._ttmodels = null;
            });
        };
        HoverToolView.prototype._compute_renderers = function () {
            var all_renderers, names, r, renderers;
            renderers = this.model.renderers;
            names = this.model.names;
            if (renderers.length === 0) {
                all_renderers = this.plot_model.plot.renderers;
                renderers = function () {
                    var k, len, results;
                    results = [];
                    for (k = 0, len = all_renderers.length; k < len; k++) {
                        r = all_renderers[k];
                        if (r instanceof glyph_renderer_1.GlyphRenderer || r instanceof graph_renderer_1.GraphRenderer) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
            }
            if (names.length > 0) {
                renderers = function () {
                    var k, len, results;
                    results = [];
                    for (k = 0, len = renderers.length; k < len; k++) {
                        r = renderers[k];
                        if (names.indexOf(r.name) >= 0) {
                            results.push(r);
                        }
                    }
                    return results;
                }();
            }
            return renderers;
        };
        HoverToolView.prototype._compute_ttmodels = function () {
            var k, len, r, ref, tooltip, tooltips, ttmodels;
            ttmodels = {};
            tooltips = this.model.tooltips;
            if (tooltips != null) {
                ref = this.computed_renderers;
                for (k = 0, len = ref.length; k < len; k++) {
                    r = ref[k];
                    if (r instanceof glyph_renderer_1.GlyphRenderer) {
                        tooltip = new tooltip_1.Tooltip({
                            custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),
                            attachment: this.model.attachment,
                            show_arrow: this.model.show_arrow
                        });
                        ttmodels[r.id] = tooltip;
                    } else if (r instanceof graph_renderer_1.GraphRenderer) {
                        tooltip = new tooltip_1.Tooltip({
                            custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),
                            attachment: this.model.attachment,
                            show_arrow: this.model.show_arrow
                        });
                        ttmodels[r.node_renderer.id] = tooltip;
                        ttmodels[r.edge_renderer.id] = tooltip;
                    }
                }
            }
            build_views_1.build_views(this.ttviews, object_1.values(ttmodels), {
                parent: this,
                plot_view: this.plot_view
            });
            return ttmodels;
        };
        HoverToolView.prototype._clear = function () {
            var ref, results, rid, tt;
            this._inspect(1e+400, 1e+400);
            ref = this.ttmodels;
            results = [];
            for (rid in ref) {
                tt = ref[rid];
                results.push(tt.clear());
            }
            return results;
        };
        HoverToolView.prototype._move = function (e) {
            var sx, sy;
            if (!this.model.active) {
                return;
            }
            _a = e.bokeh, sx = _a.sx, sy = _a.sy;
            if (!this.plot_view.frame.bbox.contains(sx, sy)) {
                return this._clear();
            } else {
                return this._inspect(sx, sy);
            }
            var _a;
        };
        HoverToolView.prototype._move_exit = function () {
            return this._clear();
        };
        HoverToolView.prototype._inspect = function (sx, sy) {
            var geometry, k, len, r, ref, sm, type;
            type = this.model.mode === 'mouse' ? 'point' : 'span';
            geometry = {
                type: type,
                sx: sx,
                sy: sy
            };
            if (type === 'span') {
                geometry.direction = this.model.mode === 'vline' ? 'h' : 'v';
            }
            ref = this.computed_renderers;
            for (k = 0, len = ref.length; k < len; k++) {
                r = ref[k];
                sm = r.get_selection_manager();
                sm.inspect(this.plot_view.renderer_views[r.id], geometry);
            }
            if (this.model.callback != null) {
                this._emit_callback(geometry);
            }
        };
        HoverToolView.prototype._update = function (_a) {
            var renderer_view = _a[0], geometry = _a[1].geometry;
            var data_x, data_y, ds, frame, glyph, i, ii, index, indices, j, jj, k, l, len, len1, pt, ref, ref1, ref2, ref3, ref4, ref5, rx, ry, sx, sy, tooltip, vars, x, xscale, y, yscale;
            if (!this.model.active) {
                return;
            }
            tooltip = (ref = this.ttmodels[renderer_view.model.id]) != null ? ref : null;
            if (tooltip == null) {
                return;
            }
            tooltip.clear();
            indices = renderer_view.model.get_selection_manager().inspectors[renderer_view.model.id].indices;
            if (renderer_view.model instanceof glyph_renderer_1.GlyphRenderer) {
                indices = renderer_view.model.view.convert_selection_to_subset(indices);
            }
            ds = renderer_view.model.get_selection_manager().source;
            if (indices.is_empty()) {
                return;
            }
            frame = this.plot_model.frame;
            sx = geometry.sx, sy = geometry.sy;
            xscale = frame.xscales[renderer_view.model.x_range_name];
            yscale = frame.yscales[renderer_view.model.y_range_name];
            x = xscale.invert(sx);
            y = yscale.invert(sy);
            glyph = renderer_view.glyph;
            ref1 = indices['0d'].indices;
            for (k = 0, len = ref1.length; k < len; k++) {
                i = ref1[k];
                data_x = glyph._x[i + 1];
                data_y = glyph._y[i + 1];
                ii = i;
                switch (this.model.line_policy) {
                case 'interp':
                    // and renderer.get_interpolation_hit?
                    _b = glyph.get_interpolation_hit(i, geometry), data_x = _b[0], data_y = _b[1];
                    rx = xscale.compute(data_x);
                    ry = yscale.compute(data_y);
                    break;
                case 'prev':
                    _c = exports._line_hit(glyph.sx, glyph.sy, i), _d = _c[0], rx = _d[0], ry = _d[1], ii = _c[1];
                    break;
                case 'next':
                    _e = exports._line_hit(glyph.sx, glyph.sy, i + 1), _f = _e[0], rx = _f[0], ry = _f[1], ii = _e[1];
                    break;
                case 'nearest':
                    _g = exports._nearest_line_hit(i, geometry, sx, sy, glyph.sx, glyph.sy), _h = _g[0], rx = _h[0], ry = _h[1], ii = _g[1];
                    data_x = glyph._x[ii];
                    data_y = glyph._y[ii];
                    break;
                default:
                    _j = [
                        sx,
                        sy
                    ], rx = _j[0], ry = _j[1];
                }
                vars = {
                    index: ii,
                    x: x,
                    y: y,
                    sx: sx,
                    sy: sy,
                    data_x: data_x,
                    data_y: data_y,
                    rx: rx,
                    ry: ry
                };
                tooltip.add(rx, ry, this._render_tooltips(ds, ii, vars));
            }
            ref2 = indices['1d'].indices;
            for (l = 0, len1 = ref2.length; l < len1; l++) {
                i = ref2[l];
                // multiglyphs will set '1d' and '2d' results, but have different tooltips
                if (!object_1.isEmpty(indices['2d'].indices)) {
                    ref3 = indices['2d'].indices;
                    for (i in ref3) {
                        j = ref3[i][0];
                        data_x = glyph._xs[i][j];
                        data_y = glyph._ys[i][j];
                        jj = j;
                        switch (this.model.line_policy) {
                        case 'interp':
                            // and renderer.get_interpolation_hit?
                            _k = glyph.get_interpolation_hit(i, j, geometry), data_x = _k[0], data_y = _k[1];
                            rx = xscale.compute(data_x);
                            ry = yscale.compute(data_y);
                            break;
                        case 'prev':
                            _l = exports._line_hit(glyph.sxs[i], glyph.sys[i], j), _m = _l[0], rx = _m[0], ry = _m[1], jj = _l[1];
                            break;
                        case 'next':
                            _o = exports._line_hit(glyph.sxs[i], glyph.sys[i], j + 1), _p = _o[0], rx = _p[0], ry = _p[1], jj = _o[1];
                            break;
                        case 'nearest':
                            _q = exports._nearest_line_hit(j, geometry, sx, sy, glyph.sxs[i], glyph.sys[i]), _r = _q[0], rx = _r[0], ry = _r[1], jj = _q[1];
                            data_x = glyph._xs[i][jj];
                            data_y = glyph._ys[i][jj];
                        }
                        if (renderer_view.model instanceof glyph_renderer_1.GlyphRenderer) {
                            index = renderer_view.model.view.convert_indices_from_subset([i])[0];
                        } else {
                            index = i;
                        }
                        vars = {
                            index: index,
                            segment_index: jj,
                            x: x,
                            y: y,
                            sx: sx,
                            sy: sy,
                            data_x: data_x,
                            data_y: data_y
                        };
                        tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));
                    }
                } else {
                    // handle non-multiglyphs
                    data_x = (ref4 = glyph._x) != null ? ref4[i] : void 0;
                    data_y = (ref5 = glyph._y) != null ? ref5[i] : void 0;
                    if (this.model.point_policy === 'snap_to_data') {
                        // Pass in our screen position so we can determine
                        // which patch we're over if there are discontinuous
                        // patches.
                        pt = glyph.get_anchor_point(this.model.anchor, i, [
                            sx,
                            sy
                        ]);
                        if (pt == null) {
                            pt = glyph.get_anchor_point('center', i, [
                                sx,
                                sy
                            ]);
                        }
                        rx = pt.x;
                        ry = pt.y;
                    } else {
                        _s = [
                            sx,
                            sy
                        ], rx = _s[0], ry = _s[1];
                    }
                    if (renderer_view.model instanceof glyph_renderer_1.GlyphRenderer) {
                        index = renderer_view.model.view.convert_indices_from_subset([i])[0];
                    } else {
                        index = i;
                    }
                    vars = {
                        index: index,
                        x: x,
                        y: y,
                        sx: sx,
                        sy: sy,
                        data_x: data_x,
                        data_y: data_y
                    };
                    tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));
                }
            }
            return null;
            var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        };
        HoverToolView.prototype._emit_callback = function (geometry) {
            var callback, data, frame, index, k, len, obj, r, ref, xscale, yscale;
            ref = this.computed_renderers;
            for (k = 0, len = ref.length; k < len; k++) {
                r = ref[k];
                index = r.data_source.inspected;
                frame = this.plot_model.frame;
                xscale = frame.xscales[r.x_range_name];
                yscale = frame.yscales[r.y_range_name];
                geometry.x = xscale.invert(geometry.sx);
                geometry.y = yscale.invert(geometry.sy);
                callback = this.model.callback;
                _a = [
                    callback,
                    {
                        index: index,
                        geometry: geometry,
                        renderer: r
                    }
                ], obj = _a[0], data = _a[1];
                if (types_1.isFunction(callback)) {
                    callback(obj, data);
                } else {
                    callback.execute(obj, data);
                }
            }
            var _a;
        };
        HoverToolView.prototype._render_tooltips = function (ds, i, vars) {
            var cell, colname, color, column, el, hex, k, label, len, match, opts, row, rows, swatch, tooltips, value;
            tooltips = this.model.tooltips;
            if (types_1.isString(tooltips)) {
                el = dom_1.div();
                el.innerHTML = templating_1.replace_placeholders(tooltips, ds, i, this.model.formatters, vars);
                return el;
            } else if (types_1.isFunction(tooltips)) {
                return tooltips(ds, vars);
            } else {
                rows = dom_1.div({
                    style: {
                        display: 'table',
                        borderSpacing: '2px'
                    }
                });
                for (k = 0, len = tooltips.length; k < len; k++) {
                    _a = tooltips[k], label = _a[0], value = _a[1];
                    row = dom_1.div({ style: { display: 'table-row' } });
                    rows.appendChild(row);
                    cell = dom_1.div({
                        style: { display: 'table-cell' },
                        class: 'bk-tooltip-row-label'
                    }, label + ': ');
                    row.appendChild(cell);
                    cell = dom_1.div({
                        style: { display: 'table-cell' },
                        class: 'bk-tooltip-row-value'
                    });
                    row.appendChild(cell);
                    if (value.indexOf('$color') >= 0) {
                        _b = value.match(/\$color(\[.*\])?:(\w*)/), match = _b[0], opts = _b[1], colname = _b[2];
                        column = ds.get_column(colname);
                        if (column == null) {
                            el = dom_1.span({}, colname + ' unknown');
                            cell.appendChild(el);
                            continue;
                        }
                        hex = (opts != null ? opts.indexOf('hex') : void 0) >= 0;
                        swatch = (opts != null ? opts.indexOf('swatch') : void 0) >= 0;
                        color = column[i];
                        if (color == null) {
                            el = dom_1.span({}, '(null)');
                            cell.appendChild(el);
                            continue;
                        }
                        if (hex) {
                            color = color_1.color2hex(color);
                        }
                        el = dom_1.span({}, color);
                        cell.appendChild(el);
                        if (swatch) {
                            el = dom_1.span({
                                class: 'bk-tooltip-color-block',
                                style: { backgroundColor: color }
                            }, ' ');
                            cell.appendChild(el);
                        }
                    } else {
                        value = value.replace('$~', '$data_');
                        el = dom_1.span();
                        el.innerHTML = templating_1.replace_placeholders(value, ds, i, this.model.formatters, vars);
                        cell.appendChild(el);
                    }
                }
                return rows;
            }
            var _a, _b;
        };
        return HoverToolView;
    }(inspect_tool_1.InspectToolView);
    exports.HoverToolView = HoverToolView;
    ;
    HoverToolView.getters({
        computed_renderers: function () {
            if (this._computed_renderers == null) {
                this._computed_renderers = this._compute_renderers();
            }
            return this._computed_renderers;
        },
        ttmodels: function () {
            if (this._ttmodels == null) {
                this._ttmodels = this._compute_ttmodels();
            }
            return this._ttmodels;
        }
    });
    var HoverTool = function (_super) {
        tslib_1.__extends(HoverTool, _super);
        function HoverTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return HoverTool;
    }(inspect_tool_1.InspectTool);
    exports.HoverTool = HoverTool;
    ;
    HoverTool.prototype.default_view = HoverToolView;
    HoverTool.prototype.type = 'HoverTool';
    HoverTool.prototype.tool_name = 'Hover';
    HoverTool.prototype.icon = 'bk-tool-icon-hover';
    HoverTool.define({
        tooltips: [
            p.Any,
            [
                [
                    'index',
                    '$index'
                ],
                [
                    'data (x, y)',
                    '($x, $y)'
                ],
                [
                    'screen (x, y)',
                    '($sx, $sy)'
                ]
            ]
        ],
        formatters: [
            p.Any,
            {}
        ],
        renderers: [
            p.Array,
            []
        ],
        names: [
            p.Array,
            []
        ],
        mode: [
            p.String,
            'mouse'    // TODO (bev)
        ],
        point_policy: [
            p.String,
            'snap_to_data'    // TODO (bev) "follow_mouse", "none"
        ],
        line_policy: [
            p.String,
            'nearest'    // TODO (bev) "next", "nearest", "interp", "none"
        ],
        show_arrow: [
            p.Boolean,
            true
        ],
        anchor: [
            p.String,
            'center'    // TODO: enum
        ],
        attachment: [
            p.String,
            'horizontal'    // TODO: enum
        ],
        callback: [p.Any]    // TODO: p.Either(p.Instance(Callback), p.Function) ]
    });    
},
/*models/tools/inspectors/inspect_tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var p = require(15    /* core/properties */);
    var button_tool_1 = require(215    /* ../button_tool */);
    var on_off_button_1 = require(230    /* ../on_off_button */);
    exports.InspectToolView = function (_super) {
        tslib_1.__extends(InspectToolView, _super);
        function InspectToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return InspectToolView;
    }(button_tool_1.ButtonToolView);
    var InspectTool = function (_super) {
        tslib_1.__extends(InspectTool, _super);
        function InspectTool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return InspectTool;
    }(button_tool_1.ButtonTool);
    exports.InspectTool = InspectTool;
    ;
    InspectTool.prototype.button_view = on_off_button_1.OnOffButtonView;
    InspectTool.prototype.event_type = 'move';
    InspectTool.define({
        toggleable: [
            p.Bool,
            true
        ]
    });
    InspectTool.override({ active: true });    
},
/*models/tools/on_off_button*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var button_tool_1 = require(215    /* ./button_tool */);
    exports.OnOffButtonView = function (_super) {
        tslib_1.__extends(OnOffButtonView, _super);
        function OnOffButtonView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OnOffButtonView.prototype.render = function () {
            _super.prototype.render.call(this);
            if (this.model.active) {
                return this.el.classList.add('bk-active');
            } else {
                return this.el.classList.remove('bk-active');
            }
        };
        OnOffButtonView.prototype._clicked = function () {
            var active;
            active = this.model.active;
            return this.model.active = !active;
        };
        return OnOffButtonView;
    }(button_tool_1.ButtonToolButtonView);    
},
/*models/tools/tool*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var p = require(15    /* core/properties */);
    var view_1 = require(45    /* core/view */);
    var array_1 = require(22    /* core/util/array */);
    var model_1 = require(50    /* ../../model */);
    var ToolView = function (_super) {
        tslib_1.__extends(ToolView, _super);
        function ToolView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            return this.plot_view = options.plot_view;
        };
        ToolView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.properties.active.change, function () {
                if (_this.model.active) {
                    return _this.activate();
                } else {
                    return _this.deactivate();
                }
            });
        };
        // activate is triggered by toolbar ui actions
        ToolView.prototype.activate = function () {
        };
        // deactivate is triggered by toolbar ui actions
        ToolView.prototype.deactivate = function () {
        };
        return ToolView;
    }(view_1.View);
    exports.ToolView = ToolView;
    ;
    ToolView.getters({
        plot_model: function () {
            return this.plot_view.model;
        }
    });
    var Tool = function (_super) {
        tslib_1.__extends(Tool, _super);
        function Tool() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // utility function to return a tool name, modified
        // by the active dimenions. Used by tools that have dimensions
        Tool.prototype._get_dim_tooltip = function (name, dims) {
            switch (dims) {
            case 'width':
                return name + ' (x-axis)';
            case 'height':
                return name + ' (y-axis)';
            case 'both':
                return name;
            }
        };
        // utility function to get limits along both dimensions, given
        // optional dimensional constraints
        Tool.prototype._get_dim_limits = function (_a, _b, frame, dims) {
            var sx0 = _a[0], sy0 = _a[1];
            var sx1 = _b[0], sy1 = _b[1];
            var hr, sxlim, sylim, vr;
            hr = frame.bbox.h_range;
            if (dims === 'width' || dims === 'both') {
                sxlim = [
                    array_1.min([
                        sx0,
                        sx1
                    ]),
                    array_1.max([
                        sx0,
                        sx1
                    ])
                ];
                sxlim = [
                    array_1.max([
                        sxlim[0],
                        hr.start
                    ]),
                    array_1.min([
                        sxlim[1],
                        hr.end
                    ])
                ];
            } else {
                sxlim = [
                    hr.start,
                    hr.end
                ];
            }
            vr = frame.bbox.v_range;
            if (dims === 'height' || dims === 'both') {
                sylim = [
                    array_1.min([
                        sy0,
                        sy1
                    ]),
                    array_1.max([
                        sy0,
                        sy1
                    ])
                ];
                sylim = [
                    array_1.max([
                        sylim[0],
                        vr.start
                    ]),
                    array_1.min([
                        sylim[1],
                        vr.end
                    ])
                ];
            } else {
                sylim = [
                    vr.start,
                    vr.end
                ];
            }
            return [
                sxlim,
                sylim
            ];
        };
        return Tool;
    }(model_1.Model);
    exports.Tool = Tool;
    ;
    Tool.getters({
        synthetic_renderers: function () {
            return [];
        }
    });
    Tool.internal({
        active: [
            p.Boolean,
            false
        ]
    });    
},
/*models/tools/tool_proxy*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var p = require(15    /* core/properties */);
    var signaling_1 = require(20    /* core/signaling */);
    var model_1 = require(50    /* ../../model */);
    var ToolProxy = function (_super) {
        tslib_1.__extends(ToolProxy, _super);
        function ToolProxy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Operates all the tools given only one button
        ToolProxy.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.do = new signaling_1.Signal(this, 'do');
            this.connect(this.do, function () {
                return this.doit();
            });
            return this.connect(this.properties.active.change, function () {
                return this.set_active();
            });
        };
        ToolProxy.prototype.doit = function () {
            var i, len, ref, tool;
            ref = this.tools;
            for (i = 0, len = ref.length; i < len; i++) {
                tool = ref[i];
                tool.do.emit();
            }
            return null;
        };
        ToolProxy.prototype.set_active = function () {
            var i, len, ref, tool;
            ref = this.tools;
            for (i = 0, len = ref.length; i < len; i++) {
                tool = ref[i];
                tool.active = this.active;
            }
            return null;
        };
        ToolProxy.prototype._clicked = function () {
            var active;
            active = this.model.active;
            return this.model.active = !active;
        };
        return ToolProxy;
    }(model_1.Model);
    exports.ToolProxy = ToolProxy;
    ;
    ToolProxy.getters({
        button_view: function () {
            return this.tools[0].button_view;
        },
        event_type: function () {
            return this.tools[0].event_type;
        },
        tooltip: function () {
            return this.tools[0].tool_name;
        },
        tool_name: function () {
            return this.tools[0].tool_name;
        },
        icon: function () {
            return this.tools[0].icon;
        }
    });
    ToolProxy.define({
        tools: [
            p.Array,
            []
        ],
        active: [
            p.Bool,
            false
        ],
        disabled: [
            p.Bool,
            false
        ]
    });    
},
/*models/tools/toolbar*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var indexOf = [].indexOf;
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var logging_1 = require(14    /* core/logging */);
    var action_tool_1 = require(207    /* ./actions/action_tool */);
    var help_tool_1 = require(208    /* ./actions/help_tool */);
    var gesture_tool_1 = require(218    /* ./gestures/gesture_tool */);
    var inspect_tool_1 = require(229    /* ./inspectors/inspect_tool */);
    var toolbar_base_1 = require(234    /* ./toolbar_base */);
    var Toolbar = function (_super) {
        tslib_1.__extends(Toolbar, _super);
        function Toolbar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Toolbar.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this.connect(this.properties.tools.change, function () {
                return this._init_tools();
            });
            return this._init_tools();
        };
        Toolbar.prototype._init_tools = function () {
            var _this = this;
            var _activate_gesture, et, event_types, i, j, len, len1, multi, ref, tool, tools;
            ref = this.tools;
            for (i = 0, len = ref.length; i < len; i++) {
                tool = ref[i];
                if (tool instanceof inspect_tool_1.InspectTool) {
                    if (!array_1.any(this.inspectors, function (t) {
                            return t.id === tool.id;
                        })) {
                        this.inspectors = this.inspectors.concat([tool]);
                    }
                } else if (tool instanceof help_tool_1.HelpTool) {
                    if (!array_1.any(this.help, function (t) {
                            return t.id === tool.id;
                        })) {
                        this.help = this.help.concat([tool]);
                    }
                } else if (tool instanceof action_tool_1.ActionTool) {
                    if (!array_1.any(this.actions, function (t) {
                            return t.id === tool.id;
                        })) {
                        this.actions = this.actions.concat([tool]);
                    }
                } else if (tool instanceof gesture_tool_1.GestureTool) {
                    event_types = tool.event_type;
                    multi = true;
                    if (typeof event_types === 'string') {
                        event_types = [event_types];
                        multi = false;
                    }
                    for (j = 0, len1 = event_types.length; j < len1; j++) {
                        et = event_types[j];
                        if (!(et in this.gestures)) {
                            logging_1.logger.warn('Toolbar: unknown event type \'' + et + '\' for tool: ' + tool.type + ' (' + tool.id + ')');
                            continue;
                        }
                        if (multi) {
                            if (!array_1.any(this.gestures['multi'].tools, function (t) {
                                    return t.id === tool.id;
                                })) {
                                this.gestures['multi'].tools = this.gestures['multi'].tools.concat([tool]);
                            }
                        } else if (!array_1.any(this.gestures[et].tools, function (t) {
                                return t.id === tool.id;
                            })) {
                            this.gestures[et].tools = this.gestures[et].tools.concat([tool]);
                        }
                        this.connect(tool.properties.active.change, this._active_change.bind(this, tool));
                    }
                }
            }
            if (this.active_inspect === 'auto') {
            } else if (this.active_inspect instanceof inspect_tool_1.InspectTool) {
                this.inspectors.map(function (inspector) {
                    if (inspector !== _this.active_inspect) {
                        return inspector.active = false;
                    }
                });
            } else if (this.active_inspect instanceof Array) {
                this.inspectors.map(function (inspector) {
                    if (indexOf.call(_this.active_inspect, inspector) < 0) {
                        return inspector.active = false;
                    }
                });
            } else if (this.active_inspect === null) {
                this.inspectors.map(function (inspector) {
                    return inspector.active = false;
                });
            }
            _activate_gesture = function (tool) {
                if (tool.active) {
                    // tool was activated by a proxy, but we need to finish configuration manually
                    return _this._active_change(tool);
                } else {
                    return tool.active = true;
                }
            };
            for (et in this.gestures) {
                tools = this.gestures[et].tools;
                if (tools.length === 0) {
                    continue;
                }
                this.gestures[et].tools = array_1.sortBy(tools, function (tool) {
                    return tool.default_order;
                });
                if (et === 'tap') {
                    if (this.active_tap === null) {
                        continue;
                    }
                    if (this.active_tap === 'auto') {
                        _activate_gesture(this.gestures[et].tools[0]);
                    } else {
                        _activate_gesture(this.active_tap);
                    }
                }
                if (et === 'pan') {
                    if (this.active_drag === null) {
                        continue;
                    }
                    if (this.active_drag === 'auto') {
                        _activate_gesture(this.gestures[et].tools[0]);
                    } else {
                        _activate_gesture(this.active_drag);
                    }
                }
                if (et === 'pinch' || et === 'scroll') {
                    if (this.active_scroll === null || this.active_scroll === 'auto') {
                        continue;
                    }
                    _activate_gesture(this.active_scroll);
                }
            }
            return null;    // XXX
        };
        return Toolbar;
    }(toolbar_base_1.ToolbarBase);
    exports.Toolbar = Toolbar;
    ;
    Toolbar.prototype.type = 'Toolbar';
    Toolbar.prototype.default_view = toolbar_base_1.ToolbarBaseView;
    Toolbar.define({
        active_drag: [
            p.Any,
            'auto'
        ],
        active_inspect: [
            p.Any,
            'auto'
        ],
        active_scroll: [
            p.Any,
            'auto'
        ],
        active_tap: [
            p.Any,
            'auto'
        ]
    });    
},
/*models/tools/toolbar_base*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var logging_1 = require(14    /* core/logging */);
    var dom_1 = require(5    /* core/dom */);
    var build_views_1 = require(4    /* core/build_views */);
    var p = require(15    /* core/properties */);
    var dom_view_1 = require(6    /* core/dom_view */);
    var model_1 = require(50    /* model */);
    exports.ToolbarBaseView = function (_super) {
        tslib_1.__extends(ToolbarBaseView, _super);
        function ToolbarBaseView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolbarBaseView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this._tool_button_views = {};
            return this._build_tool_button_views();
        };
        ToolbarBaseView.prototype.connect_signals = function () {
            var _this = this;
            _super.prototype.connect_signals.call(this);
            return this.connect(this.model.properties.tools.change, function () {
                return _this._build_tool_button_views();
            });
        };
        ToolbarBaseView.prototype.remove = function () {
            build_views_1.remove_views(this._tool_button_views);
            return _super.prototype.remove.call(this);
        };
        ToolbarBaseView.prototype._build_tool_button_views = function () {
            var ref, tools;
            tools = (ref = this.model._proxied_tools) != null ? ref : this.model.tools;
            // XXX
            return build_views_1.build_views(this._tool_button_views, tools, { parent: this }, function (tool) {
                return tool.button_view;
            });
        };
        ToolbarBaseView.prototype.render = function () {
            var bar, bars, buttons, cls, et, gestures, i, j, k, l, len, len1, len2, len3, len4, logo, m, ref, ref1, ref2, ref3, tool;
            dom_1.empty(this.el);
            this.el.classList.add('bk-toolbar');
            this.el.classList.add('bk-toolbar-' + this.model.toolbar_location);
            if (this.model.logo != null) {
                cls = this.model.logo === 'grey' ? 'bk-grey' : null;
                logo = dom_1.a({
                    href: 'https://bokeh.pydata.org/',
                    target: '_blank',
                    class: [
                        'bk-logo',
                        'bk-logo-small',
                        cls
                    ]
                });
                this.el.appendChild(logo);
            }
            bars = [];
            gestures = this.model.gestures;
            for (et in gestures) {
                buttons = [];
                ref = gestures[et].tools;
                for (i = 0, len = ref.length; i < len; i++) {
                    tool = ref[i];
                    buttons.push(this._tool_button_views[tool.id].el);
                }
                bars.push(buttons);
            }
            buttons = [];
            ref1 = this.model.actions;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
                tool = ref1[j];
                buttons.push(this._tool_button_views[tool.id].el);
            }
            bars.push(buttons);
            buttons = [];
            ref2 = this.model.inspectors;
            for (k = 0, len2 = ref2.length; k < len2; k++) {
                tool = ref2[k];
                if (tool.toggleable) {
                    buttons.push(this._tool_button_views[tool.id].el);
                }
            }
            bars.push(buttons);
            buttons = [];
            ref3 = this.model.help;
            for (l = 0, len3 = ref3.length; l < len3; l++) {
                tool = ref3[l];
                buttons.push(this._tool_button_views[tool.id].el);
            }
            bars.push(buttons);
            for (m = 0, len4 = bars.length; m < len4; m++) {
                buttons = bars[m];
                if (buttons.length !== 0) {
                    bar = dom_1.div({ class: 'bk-button-bar' }, buttons);
                    this.el.appendChild(bar);
                }
            }
            return this;
        };
        return ToolbarBaseView;
    }(dom_view_1.DOMView);
    var ToolbarBase = function (_super) {
        tslib_1.__extends(ToolbarBase, _super);
        function ToolbarBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolbarBase.prototype._active_change = function (tool) {
            var currently_active_tool, et, event_types, i, len;
            event_types = tool.event_type;
            if (typeof event_types === 'string') {
                event_types = [event_types];
            }
            for (i = 0, len = event_types.length; i < len; i++) {
                et = event_types[i];
                if (tool.active) {
                    currently_active_tool = this.gestures[et].active;
                    if (currently_active_tool != null && tool !== currently_active_tool) {
                        logging_1.logger.debug('Toolbar: deactivating tool: ' + currently_active_tool.type + ' (' + currently_active_tool.id + ') for event type \'' + et + '\'');
                        currently_active_tool.active = false;
                    }
                    this.gestures[et].active = tool;
                    logging_1.logger.debug('Toolbar: activating tool: ' + tool.type + ' (' + tool.id + ') for event type \'' + et + '\'');
                } else {
                    this.gestures[et].active = null;
                }
            }
            return null;
        };
        return ToolbarBase;
    }(model_1.Model);
    exports.ToolbarBase = ToolbarBase;
    ;
    ToolbarBase.prototype.type = 'ToolbarBase';
    ToolbarBase.prototype.default_view = exports.ToolbarBaseView;
    ToolbarBase.getters({
        horizontal: function () {
            return this.toolbar_location === 'above' || this.toolbar_location === 'below';
        },
        vertical: function () {
            return this.toolbar_location === 'left' || this.toolbar_location === 'right';
        }
    });
    ToolbarBase.define({
        tools: [
            p.Array,
            []
        ],
        logo: [
            p.String,
            'normal'    // TODO (bev)
        ]
    });
    ToolbarBase.internal({
        gestures: [
            p.Any,
            function () {
                return {
                    pan: {
                        tools: [],
                        active: null
                    },
                    scroll: {
                        tools: [],
                        active: null
                    },
                    pinch: {
                        tools: [],
                        active: null
                    },
                    tap: {
                        tools: [],
                        active: null
                    },
                    doubletap: {
                        tools: [],
                        active: null
                    },
                    press: {
                        tools: [],
                        active: null
                    },
                    rotate: {
                        tools: [],
                        active: null
                    },
                    multi: {
                        tools: [],
                        active: null
                    }
                };
            }
        ],
        actions: [
            p.Array,
            []
        ],
        inspectors: [
            p.Array,
            []
        ],
        help: [
            p.Array,
            []
        ],
        toolbar_location: [
            p.Location,
            'right'
        ]
    });    
},
/*models/tools/toolbar_box*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var indexOf = [].indexOf;
    var p = require(15    /* core/properties */);
    var dom_1 = require(5    /* core/dom */);
    var array_1 = require(22    /* core/util/array */);
    var action_tool_1 = require(207    /* ./actions/action_tool */);
    var help_tool_1 = require(208    /* ./actions/help_tool */);
    var gesture_tool_1 = require(218    /* ./gestures/gesture_tool */);
    var inspect_tool_1 = require(229    /* ./inspectors/inspect_tool */);
    var toolbar_base_1 = require(234    /* ./toolbar_base */);
    var tool_proxy_1 = require(232    /* ./tool_proxy */);
    var layout_dom_1 = require(139    /* ../layouts/layout_dom */);
    var build_views_1 = require(4    /* core/build_views */);
    var ProxyToolbar = function (_super) {
        tslib_1.__extends(ProxyToolbar, _super);
        function ProxyToolbar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ProxyToolbar.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this._init_tools();
            return this._merge_tools();
        };
        ProxyToolbar.prototype._init_tools = function () {
            var et, i, len, ref, results, tool;
            ref = this.tools;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
                tool = ref[i];
                if (tool instanceof inspect_tool_1.InspectTool) {
                    if (!array_1.any(this.inspectors, function (t) {
                            return t.id === tool.id;
                        })) {
                        results.push(this.inspectors = this.inspectors.concat([tool]));
                    } else {
                        results.push(void 0);
                    }
                } else if (tool instanceof help_tool_1.HelpTool) {
                    if (!array_1.any(this.help, function (t) {
                            return t.id === tool.id;
                        })) {
                        results.push(this.help = this.help.concat([tool]));
                    } else {
                        results.push(void 0);
                    }
                } else if (tool instanceof action_tool_1.ActionTool) {
                    if (!array_1.any(this.actions, function (t) {
                            return t.id === tool.id;
                        })) {
                        results.push(this.actions = this.actions.concat([tool]));
                    } else {
                        results.push(void 0);
                    }
                } else if (tool instanceof gesture_tool_1.GestureTool) {
                    et = tool.event_type;
                    if (!array_1.any(this.gestures[et].tools, function (t) {
                            return t.id === tool.id;
                        })) {
                        results.push(this.gestures[et].tools = this.gestures[et].tools.concat([tool]));
                    } else {
                        results.push(void 0);
                    }
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        ProxyToolbar.prototype._merge_tools = function () {
            var _this = this;
            var actions, active, et, event_type, gestures, helptool, i, info, inspectors, j, k, l, len, len1, len2, len3, make_proxy, new_help_tools, new_help_urls, proxy, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, tool, tool_type, tools;
            // Go through all the tools on the toolbar and replace them with
            // a proxy e.g. PanTool, BoxSelectTool, etc.
            this._proxied_tools = [];
            inspectors = {};
            actions = {};
            gestures = {};
            new_help_tools = [];
            new_help_urls = [];
            ref = this.help;
            for (i = 0, len = ref.length; i < len; i++) {
                helptool = ref[i];
                if (ref1 = helptool.redirect, indexOf.call(new_help_urls, ref1) < 0) {
                    new_help_tools.push(helptool);
                    new_help_urls.push(helptool.redirect);
                }
            }
            (_a = this._proxied_tools).push.apply(_a, new_help_tools);
            this.help = new_help_tools;
            ref2 = this.gestures;
            for (event_type in ref2) {
                info = ref2[event_type];
                if (!(event_type in gestures)) {
                    gestures[event_type] = {};
                }
                ref3 = info.tools;
                for (j = 0, len1 = ref3.length; j < len1; j++) {
                    tool = ref3[j];
                    if (!(tool.type in gestures[event_type])) {
                        gestures[event_type][tool.type] = [];
                    }
                    gestures[event_type][tool.type].push(tool);
                }
            }
            ref4 = this.inspectors;
            for (k = 0, len2 = ref4.length; k < len2; k++) {
                tool = ref4[k];
                if (!(tool.type in inspectors)) {
                    inspectors[tool.type] = [];
                }
                inspectors[tool.type].push(tool);
            }
            ref5 = this.actions;
            for (l = 0, len3 = ref5.length; l < len3; l++) {
                tool = ref5[l];
                if (!(tool.type in actions)) {
                    actions[tool.type] = [];
                }
                actions[tool.type].push(tool);
            }
            // Add a proxy for each of the groups of tools.
            make_proxy = function (tools, active) {
                if (active === void 0) {
                    active = false;
                }
                var proxy;
                proxy = new tool_proxy_1.ToolProxy({
                    tools: tools,
                    active: active
                });
                _this._proxied_tools.push(proxy);
                return proxy;
            };
            for (event_type in gestures) {
                this.gestures[event_type].tools = [];
                ref6 = gestures[event_type];
                for (tool_type in ref6) {
                    tools = ref6[tool_type];
                    if (tools.length > 0) {
                        proxy = make_proxy(tools);
                        this.gestures[event_type].tools.push(proxy);
                        this.connect(proxy.properties.active.change, this._active_change.bind(this, proxy));
                    }
                }
            }
            this.actions = [];
            for (tool_type in actions) {
                tools = actions[tool_type];
                if (tools.length > 0) {
                    this.actions.push(make_proxy(tools));
                }
            }
            this.inspectors = [];
            for (tool_type in inspectors) {
                tools = inspectors[tool_type];
                if (tools.length > 0) {
                    this.inspectors.push(make_proxy(tools, active = true));
                }
            }
            results = [];
            for (et in this.gestures) {
                tools = this.gestures[et].tools;
                if (tools.length === 0) {
                    continue;
                }
                this.gestures[et].tools = array_1.sortBy(tools, function (tool) {
                    return tool.default_order;
                });
                if (et !== 'pinch' && et !== 'scroll') {
                    results.push(this.gestures[et].tools[0].active = true);
                } else {
                    results.push(void 0);
                }
            }
            return results;
            var _a;
        };
        return ProxyToolbar;
    }(toolbar_base_1.ToolbarBase);
    exports.ProxyToolbar = ProxyToolbar;
    ;
    ProxyToolbar.prototype.type = 'ProxyToolbar';
    var ToolbarBoxView = function (_super) {
        tslib_1.__extends(ToolbarBoxView, _super);
        function ToolbarBoxView() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolbarBoxView.prototype.initialize = function (options) {
            _super.prototype.initialize.call(this, options);
            this.model.toolbar.toolbar_location = this.model.toolbar_location;
            this._toolbar_views = {};
            return build_views_1.build_views(this._toolbar_views, [this.model.toolbar], { parent: this });
        };
        ToolbarBoxView.prototype.remove = function () {
            build_views_1.remove_views(this._toolbar_views);
            return _super.prototype.remove.call(this);
        };
        ToolbarBoxView.prototype.render = function () {
            var toolbar;
            _super.prototype.render.call(this);
            toolbar = this._toolbar_views[this.model.toolbar.id];
            toolbar.render();
            dom_1.empty(this.el);
            return this.el.appendChild(toolbar.el);
        };
        ToolbarBoxView.prototype.get_width = function () {
            if (this.model.toolbar.vertical) {
                return 30;
            } else {
                return null;
            }
        };
        ToolbarBoxView.prototype.get_height = function () {
            if (this.model.toolbar.horizontal) {
                return 30;
            } else {
                return null;
            }
        };
        return ToolbarBoxView;
    }(layout_dom_1.LayoutDOMView);
    exports.ToolbarBoxView = ToolbarBoxView;
    ;
    ToolbarBoxView.prototype.className = 'bk-toolbar-box';
    var ToolbarBox = function (_super) {
        tslib_1.__extends(ToolbarBox, _super);
        function ToolbarBox() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ToolbarBox;
    }(layout_dom_1.LayoutDOM);
    exports.ToolbarBox = ToolbarBox;
    ;
    ToolbarBox.prototype.type = 'ToolbarBox';
    ToolbarBox.prototype.default_view = ToolbarBoxView;
    ToolbarBox.define({
        toolbar: [p.Instance],
        toolbar_location: [
            p.Location,
            'right'
        ]
    });
    ToolbarBox.getters({
        // XXX: we are overriding LayoutDOM.sizing_mode here. That's a bad
        // hack, but currently every layoutable is allowed to have its
        // sizing mode configured, which is wrong. Another example of this
        // is PlotCanvas which only works with strech_both sizing mode.
        sizing_mode: function () {
            switch (this.toolbar_location) {
            case 'above':
            case 'below':
                return 'scale_width';
            case 'left':
            case 'right':
                return 'scale_height';
            }
        }
    });    
},
/*models/transforms/customjs_transform*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var transform_1 = require(243    /* ./transform */);
    var p = require(15    /* core/properties */);
    var object_1 = require(30    /* core/util/object */);
    var CustomJSTransform = function (_super) {
        tslib_1.__extends(CustomJSTransform, _super);
        function CustomJSTransform() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomJSTransform.prototype.compute = function (x) {
            return this.scalar_transform.apply(this, this.values.concat([
                x,
                require,
                exports
            ]));
        };
        CustomJSTransform.prototype.v_compute = function (xs) {
            return this.vector_transform.apply(this, this.values.concat([
                xs,
                require,
                exports
            ]));
        };
        CustomJSTransform.prototype._make_transform = function (val, fn) {
            // this relies on Object.keys(args) and values(args) returning keys and values
            // in the same order
            return new (Function.bind.apply(Function, [void 0].concat(Object.keys(this.args), [
                val,
                'require',
                'exports',
                fn
            ])))();
        };
        CustomJSTransform.prototype._make_values = function () {
            return object_1.values(this.args);
        };
        return CustomJSTransform;
    }(transform_1.Transform);
    exports.CustomJSTransform = CustomJSTransform;
    ;
    CustomJSTransform.prototype.type = 'CustomJSTransform';
    CustomJSTransform.define({
        args: [
            p.Any,
            {}
        ],
        func: [
            p.String,
            ''
        ],
        v_func: [
            p.String,
            ''
        ]
    });
    CustomJSTransform.getters({
        values: function () {
            return this._make_values();
        },
        scalar_transform: function () {
            return this._make_transform('x', this.func);
        },
        vector_transform: function () {
            return this._make_transform('xs', this.v_func);
        }
    });    
},
/*models/transforms/dodge*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var transform_1 = require(243    /* ./transform */);
    var p = require(15    /* core/properties */);
    var Dodge = function (_super) {
        tslib_1.__extends(Dodge, _super);
        function Dodge() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Dodge.prototype.compute = function (x, use_synthetic) {
            if (use_synthetic === void 0) {
                use_synthetic = true;
            }
            var ref;
            if (((ref = this.range) != null ? ref.synthetic : void 0) != null && use_synthetic) {
                x = this.range.synthetic(x);
            }
            return x + this.value;
        };
        return Dodge;
    }(transform_1.Transform);
    exports.Dodge = Dodge;
    ;
    Dodge.define({
        value: [
            p.Number,
            0
        ],
        range: [p.Instance]
    });    
},
/*models/transforms/index*/
function _(require, module, exports) {
    var customjs_transform_1 = require(236    /* ./customjs_transform */);
    exports.CustomJSTransform = customjs_transform_1.CustomJSTransform;
    var dodge_1 = require(237    /* ./dodge */);
    exports.Dodge = dodge_1.Dodge;
    var interpolator_1 = require(239    /* ./interpolator */);
    exports.Interpolator = interpolator_1.Interpolator;
    var jitter_1 = require(240    /* ./jitter */);
    exports.Jitter = jitter_1.Jitter;
    var linear_interpolator_1 = require(241    /* ./linear_interpolator */);
    exports.LinearInterpolator = linear_interpolator_1.LinearInterpolator;
    var step_interpolator_1 = require(242    /* ./step_interpolator */);
    exports.StepInterpolator = step_interpolator_1.StepInterpolator;
    var transform_1 = require(243    /* ./transform */);
    exports.Transform = transform_1.Transform;    
},
/*models/transforms/interpolator*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var indexOf = [].indexOf;
    var transform_1 = require(243    /* ./transform */);
    var p = require(15    /* core/properties */);
    var Interpolator = function (_super) {
        tslib_1.__extends(Interpolator, _super);
        function Interpolator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Interpolator.prototype.initialize = function (attrs, options) {
            _super.prototype.initialize.call(this, attrs, options);
            this._x_sorted = [];
            this._y_sorted = [];
            this._sorted_dirty = true;
            return this.connect(this.change, function () {
                return this._sorted_dirty = true;
            });
        };
        Interpolator.prototype.sort = function (descending) {
            if (descending === void 0) {
                descending = false;
            }
            var column_names, data, i, j, k, list, ref, ref1, ref2, tsx, tsy;
            // Verify that all necessary objects exist...
            if (typeof this.x !== typeof this.y) {
                throw new Error('The parameters for x and y must be of the same type, either both strings which define a column in the data source or both arrays of the same length');
                return;
            } else {
                if (typeof this.x === 'string' && this.data === null) {
                    throw new Error('If the x and y parameters are not specified as an array, the data parameter is reqired.');
                    return;
                }
            }
            // Stop processing this if the dirty flag is not set
            if (this._sorted_dirty === false) {
                return;
            }
            tsx = [];
            tsy = [];
            // Populate the tsx and tsy variables correctly depending on the method by which the user populated the interpolation
            // data.
            if (typeof this.x === 'string') {
                data = this.data;
                column_names = data.columns();
                if (ref = this.x, indexOf.call(column_names, ref) < 0) {
                    throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');
                }
                if (ref1 = this.y, indexOf.call(column_names, ref1) < 0) {
                    throw new Error('The x parameter does not correspond to a valid column name defined in the data parameter');
                }
                tsx = data.get_column(this.x);
                tsy = data.get_column(this.y);
            } else {
                tsx = this.x;
                tsy = this.y;
            }
            if (tsx.length !== tsy.length) {
                throw new Error('The length for x and y do not match');
            }
            if (tsx.length < 2) {
                throw new Error('x and y must have at least two elements to support interpolation');
            }
            // The following sorting code is referenced from:
            // http://stackoverflow.com/questions/11499268/sort-two-arrays-the-same-way
            list = [];
            for (j in tsx) {
                list.push({
                    'x': tsx[j],
                    'y': tsy[j]
                });
            }
            if (descending === true) {
                list.sort(function (a, b) {
                    var ref2, ref3;
                    return (ref2 = a.x < b.x) != null ? ref2 : -{ 1: (ref3 = a.x === b.x) != null ? ref3 : { 0: 1 } };
                });
            } else {
                list.sort(function (a, b) {
                    var ref2, ref3;
                    return (ref2 = a.x > b.x) != null ? ref2 : -{ 1: (ref3 = a.x === b.x) != null ? ref3 : { 0: 1 } };
                });
            }
            for (k = i = 0, ref2 = list.length; 0 <= ref2 ? i < ref2 : i > ref2; k = 0 <= ref2 ? ++i : --i) {
                this._x_sorted[k] = list[k].x;
                this._y_sorted[k] = list[k].y;
            }
            return this._sorted_dirty = false;
        };
        return Interpolator;
    }(transform_1.Transform);
    exports.Interpolator = Interpolator;
    ;
    Interpolator.define({
        x: [p.Any],
        y: [p.Any],
        data: [p.Any],
        clip: [
            p.Bool,
            true
        ]
    });    
},
/*models/transforms/jitter*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var transform_1 = require(243    /* ./transform */);
    var p = require(15    /* core/properties */);
    var bokeh_math = require(29    /* core/util/math */);
    var Jitter = function (_super) {
        tslib_1.__extends(Jitter, _super);
        function Jitter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Jitter.prototype.compute = function (x, use_synthetic) {
            if (use_synthetic === void 0) {
                use_synthetic = true;
            }
            var ref;
            if (((ref = this.range) != null ? ref.synthetic : void 0) != null && use_synthetic) {
                x = this.range.synthetic(x);
            }
            if (this.distribution === 'uniform') {
                return x + this.mean + (bokeh_math.random() - 0.5) * this.width;
            }
            if (this.distribution === 'normal') {
                return x + bokeh_math.rnorm(this.mean, this.width);
            }
        };
        return Jitter;
    }(transform_1.Transform);
    exports.Jitter = Jitter;
    ;
    Jitter.define({
        mean: [
            p.Number,
            0
        ],
        width: [
            p.Number,
            1
        ],
        distribution: [
            p.Distribution,
            'uniform'
        ],
        range: [p.Instance]
    });    
},
/*models/transforms/linear_interpolator*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var array_1 = require(22    /* core/util/array */);
    var interpolator_1 = require(239    /* ./interpolator */);
    exports.LinearInterpolator = function (_super) {
        tslib_1.__extends(LinearInterpolator, _super);
        function LinearInterpolator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LinearInterpolator.prototype.compute = function (x) {
            var descending, ind, ret, x1, x2, y1, y2;
            // Apply the transform to a single value
            this.sort(descending = false);
            if (this.clip === true) {
                if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {
                    return null;
                }
            } else {
                if (x < this._x_sorted[0]) {
                    return this._y_sorted[0];
                }
                if (x > this._x_sorted[this._x_sorted.length - 1]) {
                    return this._y_sorted[this._y_sorted.length - 1];
                }
            }
            if (x === this._x_sorted[0]) {
                return this._y_sorted[0];
            }
            ind = array_1.findLastIndex(this._x_sorted, function (num) {
                return num < x;
            });
            x1 = this._x_sorted[ind];
            x2 = this._x_sorted[ind + 1];
            y1 = this._y_sorted[ind];
            y2 = this._y_sorted[ind + 1];
            ret = y1 + (x - x1) / (x2 - x1) * (y2 - y1);
            return ret;
        };
        LinearInterpolator.prototype.v_compute = function (xs) {
            var i, idx, len, result, x;
            // Apply the tranform to a vector of values
            result = new Float64Array(xs.length);
            for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
                x = xs[idx];
                result[idx] = this.compute(x);
            }
            return result;
        };
        return LinearInterpolator;
    }(interpolator_1.Interpolator);    
},
/*models/transforms/step_interpolator*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var interpolator_1 = require(239    /* ./interpolator */);
    var p = require(15    /* core/properties */);
    var array_1 = require(22    /* core/util/array */);
    var StepInterpolator = function (_super) {
        tslib_1.__extends(StepInterpolator, _super);
        function StepInterpolator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StepInterpolator.prototype.compute = function (x) {
            var descending, diffs, ind, mdiff, ret, tx;
            // Apply the transform to a single value
            this.sort(descending = false);
            if (this.clip === true) {
                if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1]) {
                    return null;
                }
            } else {
                if (x < this._x_sorted[0]) {
                    return this._y_sorted[0];
                }
                if (x > this._x_sorted[this._x_sorted.length - 1]) {
                    return this._y_sorted[this._y_sorted.length - 1];
                }
            }
            ind = -1;
            if (this.mode === 'after') {
                ind = array_1.findLastIndex(this._x_sorted, function (num) {
                    return x >= num;
                });
            }
            if (this.mode === 'before') {
                ind = array_1.findIndex(this._x_sorted, function (num) {
                    return x <= num;
                });
            }
            if (this.mode === 'center') {
                diffs = function () {
                    var i, len, ref, results;
                    ref = this._x_sorted;
                    results = [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        tx = ref[i];
                        results.push(Math.abs(tx - x));
                    }
                    return results;
                }.call(this);
                mdiff = array_1.min(diffs);
                ind = array_1.findIndex(diffs, function (num) {
                    return mdiff === num;
                });
            }
            if (ind !== -1) {
                ret = this._y_sorted[ind];
            } else {
                ret = null;
            }
            return ret;
        };
        StepInterpolator.prototype.v_compute = function (xs) {
            var i, idx, len, result, x;
            // Apply the tranform to a vector of values
            result = new Float64Array(xs.length);
            for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
                x = xs[idx];
                result[idx] = this.compute(x);
            }
            return result;
        };
        return StepInterpolator;
    }(interpolator_1.Interpolator);
    exports.StepInterpolator = StepInterpolator;
    ;
    StepInterpolator.define({
        mode: [
            p.StepMode,
            'after'
        ]
    });    
},
/*models/transforms/transform*/
function _(require, module, exports) {
    var tslib_1 = require(364    /* tslib */);
    var model_1 = require(50    /* ../../model */);
    exports.Transform = function (_super) {
        tslib_1.__extends(Transform, _super);
        function Transform() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // default implementation based on compute
        Transform.prototype.v_compute = function (xs) {
            var i, idx, len, ref, result, x;
            if (((ref = this.range) != null ? ref.v_synthetic : void 0) != null) {
                xs = this.range.v_synthetic(xs);
            }
            result = new Float64Array(xs.length);
            for (idx = i = 0, len = xs.length; i < len; idx = ++i) {
                x = xs[idx];
                result[idx] = this.compute(x, false);
            }
            return result;
        };
        return Transform;
    }(model_1.Model);    
},
/*polyfill*/
function _(require, module, exports) {
    if (typeof WeakMap !== 'function') {
        require(313    /* es6-weak-map/implement */);
    }
    if (typeof Set !== 'function') {
        require(303    /* es6-set/implement */);
    }
    var proto = String.prototype;
    if (!proto.repeat) {
        proto.repeat = function (count) {
            if (this == null) {
                throw new TypeError('can\'t convert ' + this + ' to object');
            }
            var str = '' + this;
            count = +count;
            if (count != count) {
                count = 0;
            }
            if (count < 0) {
                throw new RangeError('repeat count must be non-negative');
            }
            if (count == Infinity) {
                throw new RangeError('repeat count must be less than infinity');
            }
            count = Math.floor(count);
            if (str.length == 0 || count == 0) {
                return '';
            }
            // Ensuring count is a 31-bit integer allows us to heavily optimize the
            // main part. But anyway, most current (August 2014) browsers can't handle
            // strings 1 << 28 chars or longer, so:
            if (str.length * count >= 1 << 28) {
                throw new RangeError('repeat count must not overflow maximum string size');
            }
            var rpt = '';
            for (;;) {
                if ((count & 1) == 1) {
                    rpt += str;
                }
                count >>>= 1;
                if (count == 0) {
                    break;
                }
                str += str;
            }
            // Could we try:
            // return Array(count + 1).join(this);
            return rpt;
        };
    }    
},
/*protocol/message*/
function _(require, module, exports) {
    var string_1 = require(37    /* core/util/string */);
    var Message = function () {
        function Message(header, metadata, content) {
            this.header = header;
            this.metadata = metadata;
            this.content = content;
            this.buffers = [];
        }
        Message.assemble = function (header_json, metadata_json, content_json) {
            var header = JSON.parse(header_json);
            var metadata = JSON.parse(metadata_json);
            var content = JSON.parse(content_json);
            return new Message(header, metadata, content);
        };
        Message.prototype.assemble_buffer = function (buf_header, buf_payload) {
            var nb = this.header.num_buffers != null ? this.header.num_buffers : 0;
            if (nb <= this.buffers.length)
                throw new Error('too many buffers received, expecting #{nb}');
            this.buffers.push([
                buf_header,
                buf_payload
            ]);
        };
        // not defined for BokehJS, only *receiving* buffers is supported
        // add_buffer: (buf_header, buf_payload) ->
        // write_buffers: (socket)
        Message.create = function (msgtype, metadata, content) {
            if (content === void 0) {
                content = {};
            }
            var header = Message.create_header(msgtype);
            return new Message(header, metadata, content);
        };
        Message.create_header = function (msgtype) {
            return {
                msgid: string_1.uniqueId(),
                msgtype: msgtype
            };
        };
        Message.prototype.complete = function () {
            if (this.header != null && this.metadata != null && this.content != null) {
                if ('num_buffers' in this.header)
                    return this.buffers.length === this.header.num_buffers;
                else
                    return true;
            } else
                return false;
        };
        Message.prototype.send = function (socket) {
            var nb = this.header.num_buffers != null ? this.header.num_buffers : 0;
            if (nb > 0)
                throw new Error('BokehJS only supports receiving buffers, not sending');
            var header_json = JSON.stringify(this.header);
            var metadata_json = JSON.stringify(this.metadata);
            var content_json = JSON.stringify(this.content);
            socket.send(header_json);
            socket.send(metadata_json);
            socket.send(content_json);
        };
        Message.prototype.msgid = function () {
            return this.header.msgid;
        };
        Message.prototype.msgtype = function () {
            return this.header.msgtype;
        };
        Message.prototype.reqid = function () {
            return this.header.reqid;
        };
        // return the reason we should close on bad protocol, if there is one
        Message.prototype.problem = function () {
            if (!('msgid' in this.header))
                return 'No msgid in header';
            else if (!('msgtype' in this.header))
                return 'No msgtype in header';
            else
                return null;
        };
        return Message;
    }();
    exports.Message = Message;    
},
/*protocol/receiver*/
function _(require, module, exports) {
    var message_1 = require(245    /* protocol/message */);
    var Receiver = function () {
        function Receiver() {
            this.message = null;
            this._partial = null;
            this._fragments = [];
            this._buf_header = null;
            this._current_consumer = this._HEADER;
        }
        Receiver.prototype.consume = function (fragment) {
            this._current_consumer(fragment);
        };
        Receiver.prototype._HEADER = function (fragment) {
            this._assume_text(fragment);
            this.message = null;
            this._partial = null;
            this._fragments = [fragment];
            this._buf_header = null;
            this._current_consumer = this._METADATA;
        };
        Receiver.prototype._METADATA = function (fragment) {
            this._assume_text(fragment);
            this._fragments.push(fragment);
            this._current_consumer = this._CONTENT;
        };
        Receiver.prototype._CONTENT = function (fragment) {
            this._assume_text(fragment);
            this._fragments.push(fragment);
            var _a = this._fragments.slice(0, 3), header_json = _a[0], metadata_json = _a[1], content_json = _a[2];
            this._partial = message_1.Message.assemble(header_json, metadata_json, content_json);
            this._check_complete();
        };
        Receiver.prototype._BUFFER_HEADER = function (fragment) {
            this._assume_text(fragment);
            this._buf_header = fragment;
            this._current_consumer = this._BUFFER_PAYLOAD;
        };
        Receiver.prototype._BUFFER_PAYLOAD = function (fragment) {
            this._assume_binary(fragment);
            this._partial.assemble_buffer(this._buf_header, fragment);
            this._check_complete();
        };
        Receiver.prototype._assume_text = function (fragment) {
            if (fragment instanceof ArrayBuffer)
                throw new Error('Expected text fragment but received binary fragment');
        };
        Receiver.prototype._assume_binary = function (fragment) {
            if (!(fragment instanceof ArrayBuffer))
                throw new Error('Expected binary fragment but received text fragment');
        };
        Receiver.prototype._check_complete = function () {
            if (this._partial.complete()) {
                this.message = this._partial;
                this._current_consumer = this._HEADER;
            } else
                this._current_consumer = this._BUFFER_HEADER;
        };
        return Receiver;
    }();
    exports.Receiver = Receiver;    
},
/*safely*/
function _(require, module, exports) {
    function _burst_into_flames(error) {
        // Make box
        var box = document.createElement('div');
        box.style.backgroundColor = '#f2dede';
        box.style.border = '1px solid #a94442';
        box.style.borderRadius = '4px';
        box.style.display = 'inline-block';
        box.style.fontFamily = 'sans-serif';
        box.style.marginTop = '5px';
        box.style.minWidth = '200px';
        box.style.padding = '5px 5px 5px 10px';
        // Make button
        var button = document.createElement('span');
        button.style.backgroundColor = '#a94442';
        button.style.borderRadius = '0px 4px 0px 0px';
        button.style.color = 'white';
        button.style.cursor = 'pointer';
        button.style.cssFloat = 'right';
        button.style.fontSize = '0.8em';
        button.style.margin = '-6px -6px 0px 0px';
        button.style.padding = '2px 5px 4px 5px';
        button.title = 'close';
        button.setAttribute('aria-label', 'close');
        button.appendChild(document.createTextNode('x'));
        button.addEventListener('click', function () {
            return body.removeChild(box);
        });
        // Make title
        var title = document.createElement('h3');
        title.style.color = '#a94442';
        title.style.margin = '8px 0px 0px 0px';
        title.style.padding = '0px';
        title.appendChild(document.createTextNode('Bokeh Error'));
        // Make message
        var message = document.createElement('pre');
        message.style.whiteSpace = 'unset';
        message.style.overflowX = 'auto';
        message.appendChild(document.createTextNode(error.message || error));
        // Add pieces to box
        box.appendChild(button);
        box.appendChild(title);
        box.appendChild(message);
        // Put box in doc
        var body = document.getElementsByTagName('body')[0];
        body.insertBefore(box, body.firstChild);
    }
    function safely(fn, silent) {
        if (silent === void 0) {
            silent = false;
        }
        try {
            return fn();
        } catch (error) {
            _burst_into_flames(error);
            if (!silent)
                throw error;
            else
                return;
        }
    }
    exports.safely = safely;    
},
/*version*/
function _(require, module, exports) {
    exports.version = '0.12.13';    
},
/*!!
 *  Canvas 2 Svg v1.0.21
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */
/*canvas2svg/canvas2svg*/
function _(require, module, exports) {
    ;
    (function () {
        'use strict';
        var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;
        //helper function to format a string
        function format(str, args) {
            var keys = Object.keys(args), i;
            for (i = 0; i < keys.length; i++) {
                str = str.replace(new RegExp('\\{' + keys[i] + '\\}', 'gi'), args[keys[i]]);
            }
            return str;
        }
        //helper function that generates a random string
        function randomString(holder) {
            var chars, randomstring, i;
            if (!holder) {
                throw new Error('cannot create a random attribute name for an undefined object');
            }
            chars = 'ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
            randomstring = '';
            do {
                randomstring = '';
                for (i = 0; i < 12; i++) {
                    randomstring += chars[Math.floor(Math.random() * chars.length)];
                }
            } while (holder[randomstring]);
            return randomstring;
        }
        //helper function to map named to numbered entities
        function createNamedToNumberedLookup(items, radix) {
            var i, entity, lookup = {}, base10, base16;
            items = items.split(',');
            radix = radix || 10;
            // Map from named to numbered entities.
            for (i = 0; i < items.length; i += 2) {
                entity = '&' + items[i + 1] + ';';
                base10 = parseInt(items[i], radix);
                lookup[entity] = '&#' + base10 + ';';
            }
            //FF and IE need to create a regex from hex values ie &nbsp; == \xa0
            lookup['\\xa0'] = '&#160;';
            return lookup;
        }
        //helper function to map canvas-textAlign to svg-textAnchor
        function getTextAnchor(textAlign) {
            //TODO: support rtl languages
            var mapping = {
                'left': 'start',
                'right': 'end',
                'center': 'middle',
                'start': 'start',
                'end': 'end'
            };
            return mapping[textAlign] || mapping.start;
        }
        //helper function to map canvas-textBaseline to svg-dominantBaseline
        function getDominantBaseline(textBaseline) {
            //INFO: not supported in all browsers
            var mapping = {
                'alphabetic': 'alphabetic',
                'hanging': 'hanging',
                'top': 'text-before-edge',
                'bottom': 'text-after-edge',
                'middle': 'central'
            };
            return mapping[textBaseline] || mapping.alphabetic;
        }
        // Unpack entities lookup where the numbers are in radix 32 to reduce the size
        // entity mapping courtesy of tinymce
        namedEntities = createNamedToNumberedLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
        //Some basic mappings for attributes and default values.
        STYLES = {
            'strokeStyle': {
                svgAttr: 'stroke',
                //corresponding svg attribute
                canvas: '#000000',
                //canvas default
                svg: 'none',
                //svg default
                apply: 'stroke'    //apply on stroke() or fill()
            },
            'fillStyle': {
                svgAttr: 'fill',
                canvas: '#000000',
                svg: null,
                //svg default is black, but we need to special case this to handle canvas stroke without fill
                apply: 'fill'
            },
            'lineCap': {
                svgAttr: 'stroke-linecap',
                canvas: 'butt',
                svg: 'butt',
                apply: 'stroke'
            },
            'lineJoin': {
                svgAttr: 'stroke-linejoin',
                canvas: 'miter',
                svg: 'miter',
                apply: 'stroke'
            },
            'miterLimit': {
                svgAttr: 'stroke-miterlimit',
                canvas: 10,
                svg: 4,
                apply: 'stroke'
            },
            'lineWidth': {
                svgAttr: 'stroke-width',
                canvas: 1,
                svg: 1,
                apply: 'stroke'
            },
            'globalAlpha': {
                svgAttr: 'opacity',
                canvas: 1,
                svg: 1,
                apply: 'fill stroke'
            },
            'font': {
                //font converts to multiple svg attributes, there is custom logic for this
                canvas: '10px sans-serif'
            },
            'shadowColor': { canvas: '#000000' },
            'shadowOffsetX': { canvas: 0 },
            'shadowOffsetY': { canvas: 0 },
            'shadowBlur': { canvas: 0 },
            'textAlign': { canvas: 'start' },
            'textBaseline': { canvas: 'alphabetic' },
            'lineDash': {
                svgAttr: 'stroke-dasharray',
                canvas: [],
                svg: null,
                apply: 'stroke'
            }
        };
        /**
     *
     * @param gradientNode - reference to the gradient
     * @constructor
     */
        CanvasGradient = function (gradientNode, ctx) {
            this.__root = gradientNode;
            this.__ctx = ctx;
        };
        /**
     * Adds a color stop to the gradient root
     */
        CanvasGradient.prototype.addColorStop = function (offset, color) {
            var stop = this.__ctx.__createElement('stop'), regex, matches;
            stop.setAttribute('offset', offset);
            if (color.indexOf('rgba') !== -1) {
                //separate alpha value, since webkit can't handle it
                regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                matches = regex.exec(color);
                stop.setAttribute('stop-color', format('rgb({r},{g},{b})', {
                    r: matches[1],
                    g: matches[2],
                    b: matches[3]
                }));
                stop.setAttribute('stop-opacity', matches[4]);
            } else {
                stop.setAttribute('stop-color', color);
            }
            this.__root.appendChild(stop);
        };
        CanvasPattern = function (pattern, ctx) {
            this.__root = pattern;
            this.__ctx = ctx;
        };
        /**
     * The mock canvas context
     * @param o - options include:
     * ctx - existing Context2D to wrap around
     * width - width of your canvas (defaults to 500)
     * height - height of your canvas (defaults to 500)
     * enableMirroring - enables canvas mirroring (get image data) (defaults to false)
     * document - the document object (defaults to the current document)
     */
        ctx = function (o) {
            var defaultOptions = {
                    width: 500,
                    height: 500,
                    enableMirroring: false
                }, options;
            //keep support for this way of calling C2S: new C2S(width,height)
            if (arguments.length > 1) {
                options = defaultOptions;
                options.width = arguments[0];
                options.height = arguments[1];
            } else if (!o) {
                options = defaultOptions;
            } else {
                options = o;
            }
            if (!(this instanceof ctx)) {
                //did someone call this without new?
                return new ctx(options);
            }
            //setup options
            this.width = options.width || defaultOptions.width;
            this.height = options.height || defaultOptions.height;
            this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;
            this.canvas = this;
            ///point back to this instance!
            this.__document = options.document || document;
            // allow passing in an existing context to wrap around
            // if a context is passed in, we know a canvas already exist
            if (options.ctx) {
                this.__ctx = options.ctx;
            } else {
                this.__canvas = this.__document.createElement('canvas');
                this.__ctx = this.__canvas.getContext('2d');
            }
            this.__setDefaultStyles();
            this.__stack = [this.__getStyleState()];
            this.__groupStack = [];
            //the root svg element
            this.__root = this.__document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this.__root.setAttribute('version', 1.1);
            this.__root.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            this.__root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
            this.__root.setAttribute('width', this.width);
            this.__root.setAttribute('height', this.height);
            //make sure we don't generate the same ids in defs
            this.__ids = {};
            //defs tag
            this.__defs = this.__document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            this.__root.appendChild(this.__defs);
            //also add a group child. the svg element can't use the transform attribute
            this.__currentElement = this.__document.createElementNS('http://www.w3.org/2000/svg', 'g');
            this.__root.appendChild(this.__currentElement);
        };
        /**
     * Creates the specified svg element
     * @private
     */
        ctx.prototype.__createElement = function (elementName, properties, resetFill) {
            if (typeof properties === 'undefined') {
                properties = {};
            }
            var element = this.__document.createElementNS('http://www.w3.org/2000/svg', elementName), keys = Object.keys(properties), i, key;
            if (resetFill) {
                //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.
                element.setAttribute('fill', 'none');
                element.setAttribute('stroke', 'none');
            }
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                element.setAttribute(key, properties[key]);
            }
            return element;
        };
        /**
     * Applies default canvas styles to the context
     * @private
     */
        ctx.prototype.__setDefaultStyles = function () {
            //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/
            var keys = Object.keys(STYLES), i, key;
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                this[key] = STYLES[key].canvas;
            }
        };
        /**
     * Applies styles on restore
     * @param styleState
     * @private
     */
        ctx.prototype.__applyStyleState = function (styleState) {
            var keys = Object.keys(styleState), i, key;
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                this[key] = styleState[key];
            }
        };
        /**
     * Gets the current style state
     * @return {Object}
     * @private
     */
        ctx.prototype.__getStyleState = function () {
            var i, styleState = {}, keys = Object.keys(STYLES), key;
            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                styleState[key] = this[key];
            }
            return styleState;
        };
        /**
     * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
     * @param type
     * @private
     */
        ctx.prototype.__applyStyleToCurrentElement = function (type) {
            var currentElement = this.__currentElement;
            var currentStyleGroup = this.__currentElementsToStyle;
            if (currentStyleGroup) {
                currentElement.setAttribute(type, '');
                currentElement = currentStyleGroup.element;
                currentStyleGroup.children.forEach(function (node) {
                    node.setAttribute(type, '');
                });
            }
            var keys = Object.keys(STYLES), i, style, value, id, regex, matches;
            for (i = 0; i < keys.length; i++) {
                style = STYLES[keys[i]];
                value = this[keys[i]];
                if (style.apply) {
                    //is this a gradient or pattern?
                    if (value instanceof CanvasPattern) {
                        //pattern
                        if (value.__ctx) {
                            //copy over defs
                            while (value.__ctx.__defs.childNodes.length) {
                                id = value.__ctx.__defs.childNodes[0].getAttribute('id');
                                this.__ids[id] = id;
                                this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
                            }
                        }
                        currentElement.setAttribute(style.apply, format('url(#{id})', { id: value.__root.getAttribute('id') }));
                    } else if (value instanceof CanvasGradient) {
                        //gradient
                        currentElement.setAttribute(style.apply, format('url(#{id})', { id: value.__root.getAttribute('id') }));
                    } else if (style.apply.indexOf(type) !== -1 && style.svg !== value) {
                        if ((style.svgAttr === 'stroke' || style.svgAttr === 'fill') && value.indexOf('rgba') !== -1) {
                            //separate alpha value, since illustrator can't handle it
                            regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                            matches = regex.exec(value);
                            currentElement.setAttribute(style.svgAttr, format('rgb({r},{g},{b})', {
                                r: matches[1],
                                g: matches[2],
                                b: matches[3]
                            }));
                            //should take globalAlpha here
                            var opacity = matches[4];
                            var globalAlpha = this.globalAlpha;
                            if (globalAlpha != null) {
                                opacity *= globalAlpha;
                            }
                            currentElement.setAttribute(style.svgAttr + '-opacity', opacity);
                        } else {
                            var attr = style.svgAttr;
                            if (keys[i] === 'globalAlpha') {
                                attr = type + '-' + style.svgAttr;
                                if (currentElement.getAttribute(attr)) {
                                    //fill-opacity or stroke-opacity has already been set by stroke or fill.
                                    continue;
                                }
                            }
                            //otherwise only update attribute if right type, and not svg default
                            currentElement.setAttribute(attr, value);
                        }
                    }
                }
            }
        };
        /**
     * Will return the closest group or svg node. May return the current element.
     * @private
     */
        ctx.prototype.__closestGroupOrSvg = function (node) {
            node = node || this.__currentElement;
            if (node.nodeName === 'g' || node.nodeName === 'svg') {
                return node;
            } else {
                return this.__closestGroupOrSvg(node.parentNode);
            }
        };
        /**
     * Returns the serialized value of the svg so far
     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.
     *                           If true, we attempt to find all named entities and encode it as a numeric entity.
     * @return serialized svg
     */
        ctx.prototype.getSerializedSvg = function (fixNamedEntities) {
            var serialized = new XMLSerializer().serializeToString(this.__root), keys, i, key, value, regexp, xmlns;
            //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly
            xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
            if (xmlns.test(serialized)) {
                serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
            }
            if (fixNamedEntities) {
                keys = Object.keys(namedEntities);
                //loop over each named entity and replace with the proper equivalent.
                for (i = 0; i < keys.length; i++) {
                    key = keys[i];
                    value = namedEntities[key];
                    regexp = new RegExp(key, 'gi');
                    if (regexp.test(serialized)) {
                        serialized = serialized.replace(regexp, value);
                    }
                }
            }
            return serialized;
        };
        /**
     * Returns the root svg
     * @return
     */
        ctx.prototype.getSvg = function () {
            return this.__root;
        };
        /**
     * Will generate a group tag.
     */
        ctx.prototype.save = function () {
            var group = this.__createElement('g');
            var parent = this.__closestGroupOrSvg();
            this.__groupStack.push(parent);
            parent.appendChild(group);
            this.__currentElement = group;
            this.__stack.push(this.__getStyleState());
        };
        /**
     * Sets current element to parent, or just root if already root
     */
        ctx.prototype.restore = function () {
            this.__currentElement = this.__groupStack.pop();
            this.__currentElementsToStyle = null;
            //Clearing canvas will make the poped group invalid, currentElement is set to the root group node.
            if (!this.__currentElement) {
                this.__currentElement = this.__root.childNodes[1];
            }
            var state = this.__stack.pop();
            this.__applyStyleState(state);
        };
        /**
     * Helper method to add transform
     * @private
     */
        ctx.prototype.__addTransform = function (t) {
            //if the current element has siblings, add another group
            var parent = this.__closestGroupOrSvg();
            if (parent.childNodes.length > 0) {
                if (this.__currentElement.nodeName === 'path') {
                    if (!this.__currentElementsToStyle)
                        this.__currentElementsToStyle = {
                            element: parent,
                            children: []
                        };
                    this.__currentElementsToStyle.children.push(this.__currentElement);
                    this.__applyCurrentDefaultPath();
                }
                var group = this.__createElement('g');
                parent.appendChild(group);
                this.__currentElement = group;
            }
            var transform = this.__currentElement.getAttribute('transform');
            if (transform) {
                transform += ' ';
            } else {
                transform = '';
            }
            transform += t;
            this.__currentElement.setAttribute('transform', transform);
        };
        /**
     *  scales the current element
     */
        ctx.prototype.scale = function (x, y) {
            if (y === undefined) {
                y = x;
            }
            this.__addTransform(format('scale({x},{y})', {
                x: x,
                y: y
            }));
        };
        /**
     * rotates the current element
     */
        ctx.prototype.rotate = function (angle) {
            var degrees = angle * 180 / Math.PI;
            this.__addTransform(format('rotate({angle},{cx},{cy})', {
                angle: degrees,
                cx: 0,
                cy: 0
            }));
        };
        /**
     * translates the current element
     */
        ctx.prototype.translate = function (x, y) {
            this.__addTransform(format('translate({x},{y})', {
                x: x,
                y: y
            }));
        };
        /**
     * applies a transform to the current element
     */
        ctx.prototype.transform = function (a, b, c, d, e, f) {
            this.__addTransform(format('matrix({a},{b},{c},{d},{e},{f})', {
                a: a,
                b: b,
                c: c,
                d: d,
                e: e,
                f: f
            }));
        };
        /**
     * Create a new Path Element
     */
        ctx.prototype.beginPath = function () {
            var path, parent;
            // Note that there is only one current default path, it is not part of the drawing state.
            // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path
            this.__currentDefaultPath = '';
            this.__currentPosition = {};
            path = this.__createElement('path', {}, true);
            parent = this.__closestGroupOrSvg();
            parent.appendChild(path);
            this.__currentElement = path;
        };
        /**
     * Helper function to apply currentDefaultPath to current path element
     * @private
     */
        ctx.prototype.__applyCurrentDefaultPath = function () {
            var currentElement = this.__currentElement;
            if (currentElement.nodeName === 'path') {
                currentElement.setAttribute('d', this.__currentDefaultPath);
            } else {
                console.error('Attempted to apply path command to node', currentElement.nodeName);
            }
        };
        /**
     * Helper function to add path command
     * @private
     */
        ctx.prototype.__addPathCommand = function (command) {
            this.__currentDefaultPath += ' ';
            this.__currentDefaultPath += command;
        };
        /**
     * Adds the move command to the current path element,
     * if the currentPathElement is not empty create a new path element
     */
        ctx.prototype.moveTo = function (x, y) {
            if (this.__currentElement.nodeName !== 'path') {
                this.beginPath();
            }
            // creates a new subpath with the given point
            this.__currentPosition = {
                x: x,
                y: y
            };
            this.__addPathCommand(format('M {x} {y}', {
                x: x,
                y: y
            }));
        };
        /**
     * Closes the current path
     */
        ctx.prototype.closePath = function () {
            if (this.__currentDefaultPath) {
                this.__addPathCommand('Z');
            }
        };
        /**
     * Adds a line to command
     */
        ctx.prototype.lineTo = function (x, y) {
            this.__currentPosition = {
                x: x,
                y: y
            };
            if (this.__currentDefaultPath.indexOf('M') > -1) {
                this.__addPathCommand(format('L {x} {y}', {
                    x: x,
                    y: y
                }));
            } else {
                this.__addPathCommand(format('M {x} {y}', {
                    x: x,
                    y: y
                }));
            }
        };
        /**
     * Add a bezier command
     */
        ctx.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            this.__currentPosition = {
                x: x,
                y: y
            };
            this.__addPathCommand(format('C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}', {
                cp1x: cp1x,
                cp1y: cp1y,
                cp2x: cp2x,
                cp2y: cp2y,
                x: x,
                y: y
            }));
        };
        /**
     * Adds a quadratic curve to command
     */
        ctx.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            this.__currentPosition = {
                x: x,
                y: y
            };
            this.__addPathCommand(format('Q {cpx} {cpy} {x} {y}', {
                cpx: cpx,
                cpy: cpy,
                x: x,
                y: y
            }));
        };
        /**
     * Return a new normalized vector of given vector
     */
        var normalize = function (vector) {
            var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
            return [
                vector[0] / len,
                vector[1] / len
            ];
        };
        /**
     * Adds the arcTo to the current path
     *
     * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto
     */
        ctx.prototype.arcTo = function (x1, y1, x2, y2, radius) {
            // Let the point (x0, y0) be the last point in the subpath.
            var x0 = this.__currentPosition && this.__currentPosition.x;
            var y0 = this.__currentPosition && this.__currentPosition.y;
            // First ensure there is a subpath for (x1, y1).
            if (typeof x0 == 'undefined' || typeof y0 == 'undefined') {
                return;
            }
            // Negative values for radius must cause the implementation to throw an IndexSizeError exception.
            if (radius < 0) {
                throw new Error('IndexSizeError: The radius provided (' + radius + ') is negative.');
            }
            // If the point (x0, y0) is equal to the point (x1, y1),
            // or if the point (x1, y1) is equal to the point (x2, y2),
            // or if the radius radius is zero,
            // then the method must add the point (x1, y1) to the subpath,
            // and connect that point to the previous point (x0, y0) by a straight line.
            if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius === 0) {
                this.lineTo(x1, y1);
                return;
            }
            // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,
            // then the method must add the point (x1, y1) to the subpath,
            // and connect that point to the previous point (x0, y0) by a straight line.
            var unit_vec_p1_p0 = normalize([
                x0 - x1,
                y0 - y1
            ]);
            var unit_vec_p1_p2 = normalize([
                x2 - x1,
                y2 - y1
            ]);
            if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
                this.lineTo(x1, y1);
                return;
            }
            // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,
            // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),
            // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).
            // The points at which this circle touches these two lines are called the start and end tangent points respectively.
            // note that both vectors are unit vectors, so the length is 1
            var cos = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
            var theta = Math.acos(Math.abs(cos));
            // Calculate origin
            var unit_vec_p1_origin = normalize([
                unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
                unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
            ]);
            var len_p1_origin = radius / Math.sin(theta / 2);
            var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
            var y = y1 + len_p1_origin * unit_vec_p1_origin[1];
            // Calculate start angle and end angle
            // rotate 90deg clockwise (note that y axis points to its down)
            var unit_vec_origin_start_tangent = [
                -unit_vec_p1_p0[1],
                unit_vec_p1_p0[0]
            ];
            // rotate 90deg counter clockwise (note that y axis points to its down)
            var unit_vec_origin_end_tangent = [
                unit_vec_p1_p2[1],
                -unit_vec_p1_p2[0]
            ];
            var getAngle = function (vector) {
                // get angle (clockwise) between vector and (1, 0)
                var x = vector[0];
                var y = vector[1];
                if (y >= 0) {
                    // note that y axis points to its down
                    return Math.acos(x);
                } else {
                    return -Math.acos(x);
                }
            };
            var startAngle = getAngle(unit_vec_origin_start_tangent);
            var endAngle = getAngle(unit_vec_origin_end_tangent);
            // Connect the point (x0, y0) to the start tangent point by a straight line
            this.lineTo(x + unit_vec_origin_start_tangent[0] * radius, y + unit_vec_origin_start_tangent[1] * radius);
            // Connect the start tangent point to the end tangent point by arc
            // and adding the end tangent point to the subpath.
            this.arc(x, y, radius, startAngle, endAngle);
        };
        /**
     * Sets the stroke property on the current element
     */
        ctx.prototype.stroke = function () {
            if (this.__currentElement.nodeName === 'path') {
                this.__currentElement.setAttribute('paint-order', 'fill stroke markers');
            }
            this.__applyCurrentDefaultPath();
            this.__applyStyleToCurrentElement('stroke');
        };
        /**
     * Sets fill properties on the current element
     */
        ctx.prototype.fill = function () {
            if (this.__currentElement.nodeName === 'path') {
                this.__currentElement.setAttribute('paint-order', 'stroke fill markers');
            }
            this.__applyCurrentDefaultPath();
            this.__applyStyleToCurrentElement('fill');
        };
        /**
     *  Adds a rectangle to the path.
     */
        ctx.prototype.rect = function (x, y, width, height) {
            if (this.__currentElement.nodeName !== 'path') {
                this.beginPath();
            }
            this.moveTo(x, y);
            this.lineTo(x + width, y);
            this.lineTo(x + width, y + height);
            this.lineTo(x, y + height);
            this.lineTo(x, y);
            this.closePath();
        };
        /**
     * adds a rectangle element
     */
        ctx.prototype.fillRect = function (x, y, width, height) {
            var rect, parent;
            rect = this.__createElement('rect', {
                x: x,
                y: y,
                width: width,
                height: height
            }, true);
            parent = this.__closestGroupOrSvg();
            parent.appendChild(rect);
            this.__currentElement = rect;
            this.__applyStyleToCurrentElement('fill');
        };
        /**
     * Draws a rectangle with no fill
     * @param x
     * @param y
     * @param width
     * @param height
     */
        ctx.prototype.strokeRect = function (x, y, width, height) {
            var rect, parent;
            rect = this.__createElement('rect', {
                x: x,
                y: y,
                width: width,
                height: height
            }, true);
            parent = this.__closestGroupOrSvg();
            parent.appendChild(rect);
            this.__currentElement = rect;
            this.__applyStyleToCurrentElement('stroke');
        };
        /**
     * Clear entire canvas:
     * 1. save current transforms
     * 2. remove all the childNodes of the root g element
     */
        ctx.prototype.__clearCanvas = function () {
            var current = this.__closestGroupOrSvg(), transform = current.getAttribute('transform');
            var rootGroup = this.__root.childNodes[1];
            var childNodes = rootGroup.childNodes;
            for (var i = childNodes.length - 1; i >= 0; i--) {
                if (childNodes[i]) {
                    rootGroup.removeChild(childNodes[i]);
                }
            }
            this.__currentElement = rootGroup;
            //reset __groupStack as all the child group nodes are all removed.
            this.__groupStack = [];
            if (transform) {
                this.__addTransform(transform);
            }
        };
        /**
     * "Clears" a canvas by just drawing a white rectangle in the current group.
     */
        ctx.prototype.clearRect = function (x, y, width, height) {
            //clear entire canvas
            if (x === 0 && y === 0 && width === this.width && height === this.height) {
                this.__clearCanvas();
                return;
            }
            var rect, parent = this.__closestGroupOrSvg();
            rect = this.__createElement('rect', {
                x: x,
                y: y,
                width: width,
                height: height,
                fill: '#FFFFFF'
            }, true);
            parent.appendChild(rect);
        };
        /**
     * Adds a linear gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
        ctx.prototype.createLinearGradient = function (x1, y1, x2, y2) {
            var grad = this.__createElement('linearGradient', {
                id: randomString(this.__ids),
                x1: x1 + 'px',
                x2: x2 + 'px',
                y1: y1 + 'px',
                y2: y2 + 'px',
                'gradientUnits': 'userSpaceOnUse'
            }, false);
            this.__defs.appendChild(grad);
            return new CanvasGradient(grad, this);
        };
        /**
     * Adds a radial gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
        ctx.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
            var grad = this.__createElement('radialGradient', {
                id: randomString(this.__ids),
                cx: x1 + 'px',
                cy: y1 + 'px',
                r: r1 + 'px',
                fx: x0 + 'px',
                fy: y0 + 'px',
                'gradientUnits': 'userSpaceOnUse'
            }, false);
            this.__defs.appendChild(grad);
            return new CanvasGradient(grad, this);
        };
        /**
     * Parses the font string and returns svg mapping
     * @private
     */
        ctx.prototype.__parseFont = function () {
            var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i;
            var fontPart = regex.exec(this.font);
            var data = {
                style: fontPart[1] || 'normal',
                size: fontPart[4] || '10px',
                family: fontPart[6] || 'sans-serif',
                weight: fontPart[3] || 'normal',
                decoration: fontPart[2] || 'normal',
                href: null
            };
            //canvas doesn't support underline natively, but we can pass this attribute
            if (this.__fontUnderline === 'underline') {
                data.decoration = 'underline';
            }
            //canvas also doesn't support linking, but we can pass this as well
            if (this.__fontHref) {
                data.href = this.__fontHref;
            }
            return data;
        };
        /**
     * Helper to link text fragments
     * @param font
     * @param element
     * @return {*}
     * @private
     */
        ctx.prototype.__wrapTextLink = function (font, element) {
            if (font.href) {
                var a = this.__createElement('a');
                a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', font.href);
                a.appendChild(element);
                return a;
            }
            return element;
        };
        /**
     * Fills or strokes text
     * @param text
     * @param x
     * @param y
     * @param action - stroke or fill
     * @private
     */
        ctx.prototype.__applyText = function (text, x, y, action) {
            var font = this.__parseFont(), parent = this.__closestGroupOrSvg(), textElement = this.__createElement('text', {
                    'font-family': font.family,
                    'font-size': font.size,
                    'font-style': font.style,
                    'font-weight': font.weight,
                    'text-decoration': font.decoration,
                    'x': x,
                    'y': y,
                    'text-anchor': getTextAnchor(this.textAlign),
                    'dominant-baseline': getDominantBaseline(this.textBaseline)
                }, true);
            textElement.appendChild(this.__document.createTextNode(text));
            this.__currentElement = textElement;
            this.__applyStyleToCurrentElement(action);
            parent.appendChild(this.__wrapTextLink(font, textElement));
        };
        /**
     * Creates a text element
     * @param text
     * @param x
     * @param y
     */
        ctx.prototype.fillText = function (text, x, y) {
            this.__applyText(text, x, y, 'fill');
        };
        /**
     * Strokes text
     * @param text
     * @param x
     * @param y
     */
        ctx.prototype.strokeText = function (text, x, y) {
            this.__applyText(text, x, y, 'stroke');
        };
        /**
     * No need to implement this for svg.
     * @param text
     * @return {TextMetrics}
     */
        ctx.prototype.measureText = function (text) {
            this.__ctx.font = this.font;
            return this.__ctx.measureText(text);
        };
        /**
     *  Arc command!
     */
        ctx.prototype.arc = function (x, y, radius, startAngle, endAngle, counterClockwise) {
            // in canvas no circle is drawn if no angle is provided.
            if (startAngle === endAngle) {
                return;
            }
            startAngle = startAngle % (2 * Math.PI);
            endAngle = endAngle % (2 * Math.PI);
            if (startAngle === endAngle) {
                //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)
                endAngle = (endAngle + 2 * Math.PI - 0.001 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
            }
            var endX = x + radius * Math.cos(endAngle), endY = y + radius * Math.sin(endAngle), startX = x + radius * Math.cos(startAngle), startY = y + radius * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
            // https://github.com/gliffy/canvas2svg/issues/4
            if (diff < 0) {
                diff += 2 * Math.PI;
            }
            if (counterClockwise) {
                largeArcFlag = diff > Math.PI ? 0 : 1;
            } else {
                largeArcFlag = diff > Math.PI ? 1 : 0;
            }
            this.lineTo(startX, startY);
            this.__addPathCommand(format('A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}', {
                rx: radius,
                ry: radius,
                xAxisRotation: 0,
                largeArcFlag: largeArcFlag,
                sweepFlag: sweepFlag,
                endX: endX,
                endY: endY
            }));
            this.__currentPosition = {
                x: endX,
                y: endY
            };
        };
        /**
     * Generates a ClipPath from the clip command.
     */
        ctx.prototype.clip = function () {
            var group = this.__closestGroupOrSvg(), clipPath = this.__createElement('clipPath'), id = randomString(this.__ids), newGroup = this.__createElement('g');
            this.__applyCurrentDefaultPath();
            group.removeChild(this.__currentElement);
            clipPath.setAttribute('id', id);
            clipPath.appendChild(this.__currentElement);
            this.__defs.appendChild(clipPath);
            //set the clip path to this group
            group.setAttribute('clip-path', format('url(#{id})', { id: id }));
            //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations
            // to this path
            group.appendChild(newGroup);
            this.__currentElement = newGroup;
        };
        /**
     * Draws a canvas, image or mock context to this canvas.
     * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.
     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
     */
        ctx.prototype.drawImage = function () {
            //convert arguments to a real array
            var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent, svg, defs, group, currentElement, svgImage, canvas, context, id;
            if (args.length === 3) {
                dx = args[1];
                dy = args[2];
                sw = image.width;
                sh = image.height;
                dw = sw;
                dh = sh;
            } else if (args.length === 5) {
                dx = args[1];
                dy = args[2];
                dw = args[3];
                dh = args[4];
                sw = image.width;
                sh = image.height;
            } else if (args.length === 9) {
                sx = args[1];
                sy = args[2];
                sw = args[3];
                sh = args[4];
                dx = args[5];
                dy = args[6];
                dw = args[7];
                dh = args[8];
            } else {
                throw new Error('Inavlid number of arguments passed to drawImage: ' + arguments.length);
            }
            parent = this.__closestGroupOrSvg();
            currentElement = this.__currentElement;
            var translateDirective = 'translate(' + dx + ', ' + dy + ')';
            if (image instanceof ctx) {
                //canvas2svg mock canvas context. In the future we may want to clone nodes instead.
                //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.
                svg = image.getSvg().cloneNode(true);
                if (svg.childNodes && svg.childNodes.length > 1) {
                    defs = svg.childNodes[0];
                    while (defs.childNodes.length) {
                        id = defs.childNodes[0].getAttribute('id');
                        this.__ids[id] = id;
                        this.__defs.appendChild(defs.childNodes[0]);
                    }
                    group = svg.childNodes[1];
                    if (group) {
                        //save original transform
                        var originTransform = group.getAttribute('transform');
                        var transformDirective;
                        if (originTransform) {
                            transformDirective = originTransform + ' ' + translateDirective;
                        } else {
                            transformDirective = translateDirective;
                        }
                        group.setAttribute('transform', transformDirective);
                        parent.appendChild(group);
                    }
                }
            } else if (image.nodeName === 'IMG') {
                svgImage = this.__createElement('image');
                svgImage.setAttribute('width', dw);
                svgImage.setAttribute('height', dh);
                svgImage.setAttribute('preserveAspectRatio', 'none');
                if (sx || sy || sw !== image.width || sh !== image.height) {
                    //crop the image using a temporary canvas
                    canvas = this.__document.createElement('canvas');
                    canvas.width = dw;
                    canvas.height = dh;
                    context = canvas.getContext('2d');
                    context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
                    image = canvas;
                }
                svgImage.setAttribute('transform', translateDirective);
                svgImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.nodeName === 'CANVAS' ? image.toDataURL() : image.getAttribute('src'));
                parent.appendChild(svgImage);
            } else if (image.nodeName === 'CANVAS') {
                svgImage = this.__createElement('image');
                svgImage.setAttribute('width', dw);
                svgImage.setAttribute('height', dh);
                svgImage.setAttribute('preserveAspectRatio', 'none');
                // draw canvas onto temporary canvas so that smoothing can be handled
                canvas = this.__document.createElement('canvas');
                canvas.width = dw;
                canvas.height = dh;
                context = canvas.getContext('2d');
                context.imageSmoothingEnabled = false;
                context.mozImageSmoothingEnabled = false;
                context.oImageSmoothingEnabled = false;
                context.webkitImageSmoothingEnabled = false;
                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
                image = canvas;
                svgImage.setAttribute('transform', translateDirective);
                svgImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.toDataURL());
                parent.appendChild(svgImage);
            }
        };
        /**
     * Generates a pattern tag
     */
        ctx.prototype.createPattern = function (image, repetition) {
            var pattern = this.__document.createElementNS('http://www.w3.org/2000/svg', 'pattern'), id = randomString(this.__ids), img;
            pattern.setAttribute('id', id);
            pattern.setAttribute('width', image.width);
            pattern.setAttribute('height', image.height);
            if (image.nodeName === 'CANVAS' || image.nodeName === 'IMG') {
                img = this.__document.createElementNS('http://www.w3.org/2000/svg', 'image');
                img.setAttribute('width', image.width);
                img.setAttribute('height', image.height);
                img.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', image.nodeName === 'CANVAS' ? image.toDataURL() : image.getAttribute('src'));
                pattern.appendChild(img);
                this.__defs.appendChild(pattern);
            } else if (image instanceof ctx) {
                pattern.appendChild(image.__root.childNodes[1]);
                this.__defs.appendChild(pattern);
            }
            return new CanvasPattern(pattern, this);
        };
        ctx.prototype.setLineDash = function (dashArray) {
            if (dashArray && dashArray.length > 0) {
                this.lineDash = dashArray.join(',');
            } else {
                this.lineDash = null;
            }
        };
        /**
     * Not yet implemented
     */
        ctx.prototype.drawFocusRing = function () {
        };
        ctx.prototype.createImageData = function () {
        };
        ctx.prototype.getImageData = function () {
        };
        ctx.prototype.putImageData = function () {
        };
        ctx.prototype.globalCompositeOperation = function () {
        };
        ctx.prototype.setTransform = function () {
        };
        //add options for alternative namespace
        if (typeof window === 'object') {
            window.C2S = ctx;
        }
        // CommonJS/Browserify
        if (typeof module === 'object' && typeof module.exports === 'object') {
            module.exports = ctx;
        }
    }());
},
/*d/auto-bind*/
function _(require, module, exports) {
    var copy = require(273    /* es5-ext/object/copy */), normalizeOptions = require(283    /* es5-ext/object/normalize-options */), ensureCallable = require(287    /* es5-ext/object/valid-callable */), map = require(282    /* es5-ext/object/map */), callable = require(287    /* es5-ext/object/valid-callable */), validValue = require(289    /* es5-ext/object/valid-value */), bind = Function.prototype.bind, defineProperty = Object.defineProperty, hasOwnProperty = Object.prototype.hasOwnProperty, define;
    define = function (name, desc, options) {
        var value = validValue(desc) && callable(desc.value), dgs;
        dgs = copy(desc);
        delete dgs.writable;
        delete dgs.value;
        dgs.get = function () {
            if (!options.overwriteDefinition && hasOwnProperty.call(this, name))
                return value;
            desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
            defineProperty(this, name, desc);
            return this[name];
        };
        return dgs;
    };
    module.exports = function (props) {
        var options = normalizeOptions(arguments[1]);
        if (options.resolveContext != null)
            ensureCallable(options.resolveContext);
        return map(props, function (desc, name) {
            return define(name, desc, options);
        });
    };
},
/*d/index*/
function _(require, module, exports) {
    var assign = require(270    /* es5-ext/object/assign */), normalizeOpts = require(283    /* es5-ext/object/normalize-options */), isCallable = require(276    /* es5-ext/object/is-callable */), contains = require(290    /* es5-ext/string/#/contains */), d;
    d = module.exports = function (dscr, value) {
        var c, e, w, options, desc;
        if (arguments.length < 2 || typeof dscr !== 'string') {
            options = value;
            value = dscr;
            dscr = null;
        } else {
            options = arguments[2];
        }
        if (dscr == null) {
            c = w = true;
            e = false;
        } else {
            c = contains.call(dscr, 'c');
            e = contains.call(dscr, 'e');
            w = contains.call(dscr, 'w');
        }
        desc = {
            value: value,
            configurable: c,
            enumerable: e,
            writable: w
        };
        return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function (dscr, get, set) {
        var c, e, options, desc;
        if (typeof dscr !== 'string') {
            options = set;
            set = get;
            get = dscr;
            dscr = null;
        } else {
            options = arguments[3];
        }
        if (get == null) {
            get = undefined;
        } else if (!isCallable(get)) {
            options = get;
            get = set = undefined;
        } else if (set == null) {
            set = undefined;
        } else if (!isCallable(set)) {
            options = set;
            set = undefined;
        }
        if (dscr == null) {
            c = true;
            e = false;
        } else {
            c = contains.call(dscr, 'c');
            e = contains.call(dscr, 'e');
        }
        desc = {
            get: get,
            set: set,
            configurable: c,
            enumerable: e
        };
        return !options ? desc : assign(normalizeOpts(options), desc);
    };
},
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear
/*es5-ext/array/#/clear*/
function _(require, module, exports) {
    var value = require(289    /* ../../object/valid-value */);
    module.exports = function () {
        value(this).length = 0;
        return this;
    };
},
/*es5-ext/array/#/e-index-of*/
function _(require, module, exports) {
    var numberIsNaN = require(264    /* ../../number/is-nan */), toPosInt = require(268    /* ../../number/to-pos-integer */), value = require(289    /* ../../object/valid-value */), indexOf = Array.prototype.indexOf, objHasOwnProperty = Object.prototype.hasOwnProperty, abs = Math.abs, floor = Math.floor;
    module.exports = function (searchElement) {
        var i, length, fromIndex, val;
        if (!numberIsNaN(searchElement))
            return indexOf.apply(this, arguments);
        length = toPosInt(value(this).length);
        fromIndex = arguments[1];
        if (isNaN(fromIndex))
            fromIndex = 0;
        else if (fromIndex >= 0)
            fromIndex = floor(fromIndex);
        else
            fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
        for (i = fromIndex; i < length; ++i) {
            if (objHasOwnProperty.call(this, i)) {
                val = this[i];
                if (numberIsNaN(val))
                    return i;    // Jslint: ignore
            }
        }
        return -1;
    };
},
/*es5-ext/array/from/index*/
function _(require, module, exports) {
    module.exports = require(255    /* ./is-implemented */)() ? Array.from : require(256    /* ./shim */);
},
/*es5-ext/array/from/is-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        var from = Array.from, arr, result;
        if (typeof from !== 'function')
            return false;
        arr = [
            'raz',
            'dwa'
        ];
        result = from(arr);
        return Boolean(result && result !== arr && result[1] === 'dwa');
    };
},
/*es5-ext/array/from/shim*/
function _(require, module, exports) {
    var iteratorSymbol = require(308    /* es6-symbol */).iterator, isArguments = require(257    /* ../../function/is-arguments */), isFunction = require(258    /* ../../function/is-function */), toPosInt = require(268    /* ../../number/to-pos-integer */), callable = require(287    /* ../../object/valid-callable */), validValue = require(289    /* ../../object/valid-value */), isValue = require(278    /* ../../object/is-value */), isString = require(293    /* ../../string/is-string */), isArray = Array.isArray, call = Function.prototype.call, desc = {
            configurable: true,
            enumerable: true,
            writable: true,
            value: null
        }, defineProperty = Object.defineProperty;
    // eslint-disable-next-line complexity
    module.exports = function (arrayLike) {
        var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
        arrayLike = Object(validValue(arrayLike));
        if (isValue(mapFn))
            callable(mapFn);
        if (!this || this === Array || !isFunction(this)) {
            // Result: Plain array
            if (!mapFn) {
                if (isArguments(arrayLike)) {
                    // Source: Arguments
                    length = arrayLike.length;
                    if (length !== 1)
                        return Array.apply(null, arrayLike);
                    arr = new Array(1);
                    arr[0] = arrayLike[0];
                    return arr;
                }
                if (isArray(arrayLike)) {
                    // Source: Array
                    arr = new Array(length = arrayLike.length);
                    for (i = 0; i < length; ++i)
                        arr[i] = arrayLike[i];
                    return arr;
                }
            }
            arr = [];
        } else {
            // Result: Non plain array
            Context = this;
        }
        if (!isArray(arrayLike)) {
            if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
                // Source: Iterator
                iterator = callable(getIterator).call(arrayLike);
                if (Context)
                    arr = new Context();
                result = iterator.next();
                i = 0;
                while (!result.done) {
                    value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
                    if (Context) {
                        desc.value = value;
                        defineProperty(arr, i, desc);
                    } else {
                        arr[i] = value;
                    }
                    result = iterator.next();
                    ++i;
                }
                length = i;
            } else if (isString(arrayLike)) {
                // Source: String
                length = arrayLike.length;
                if (Context)
                    arr = new Context();
                for (i = 0, j = 0; i < length; ++i) {
                    value = arrayLike[i];
                    if (i + 1 < length) {
                        code = value.charCodeAt(0);
                        // eslint-disable-next-line max-depth
                        if (code >= 55296 && code <= 56319)
                            value += arrayLike[++i];
                    }
                    value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
                    if (Context) {
                        desc.value = value;
                        defineProperty(arr, j, desc);
                    } else {
                        arr[j] = value;
                    }
                    ++j;
                }
                length = j;
            }
        }
        if (length === undefined) {
            // Source: array or array-like
            length = toPosInt(arrayLike.length);
            if (Context)
                arr = new Context(length);
            for (i = 0; i < length; ++i) {
                value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
                if (Context) {
                    desc.value = value;
                    defineProperty(arr, i, desc);
                } else {
                    arr[i] = value;
                }
            }
        }
        if (Context) {
            desc.value = null;
            arr.length = length;
        }
        return arr;
    };
},
/*es5-ext/function/is-arguments*/
function _(require, module, exports) {
    var objToString = Object.prototype.toString, id = objToString.call(function () {
            return arguments;
        }());
    module.exports = function (value) {
        return objToString.call(value) === id;
    };
},
/*es5-ext/function/is-function*/
function _(require, module, exports) {
    var objToString = Object.prototype.toString, id = objToString.call(require(259    /* ./noop */));
    module.exports = function (value) {
        return typeof value === 'function' && objToString.call(value) === id;
    };
},
/*es5-ext/function/noop*/
function _(require, module, exports) {
    // eslint-disable-next-line no-empty-function
    module.exports = function () {
    };
},
/* eslint strict: "off" */
/*es5-ext/global*/
function _(require, module, exports) {
    module.exports = function () {
        return this;
    }();
},
/*es5-ext/math/sign/index*/
function _(require, module, exports) {
    module.exports = require(262    /* ./is-implemented */)() ? Math.sign : require(263    /* ./shim */);
},
/*es5-ext/math/sign/is-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        var sign = Math.sign;
        if (typeof sign !== 'function')
            return false;
        return sign(10) === 1 && sign(-20) === -1;
    };
},
/*es5-ext/math/sign/shim*/
function _(require, module, exports) {
    module.exports = function (value) {
        value = Number(value);
        if (isNaN(value) || value === 0)
            return value;
        return value > 0 ? 1 : -1;
    };
},
/*es5-ext/number/is-nan/index*/
function _(require, module, exports) {
    module.exports = require(265    /* ./is-implemented */)() ? Number.isNaN : require(266    /* ./shim */);
},
/*es5-ext/number/is-nan/is-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        var numberIsNaN = Number.isNaN;
        if (typeof numberIsNaN !== 'function')
            return false;
        return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
    };
},
/*es5-ext/number/is-nan/shim*/
function _(require, module, exports) {
    module.exports = function (value) {
        // eslint-disable-next-line no-self-compare
        return value !== value;
    };
},
/*es5-ext/number/to-integer*/
function _(require, module, exports) {
    var sign = require(261    /* ../math/sign */), abs = Math.abs, floor = Math.floor;
    module.exports = function (value) {
        if (isNaN(value))
            return 0;
        value = Number(value);
        if (value === 0 || !isFinite(value))
            return value;
        return sign(value) * floor(abs(value));
    };
},
/*es5-ext/number/to-pos-integer*/
function _(require, module, exports) {
    var toInteger = require(267    /* ./to-integer */), max = Math.max;
    module.exports = function (value) {
        return max(0, toInteger(value));
    };
},
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order
/*es5-ext/object/_iterate*/
function _(require, module, exports) {
    var callable = require(287    /* ./valid-callable */), value = require(289    /* ./valid-value */), bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys, objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module.exports = function (method, defVal) {
        return function (obj, cb) {
            var list, thisArg = arguments[2], compareFn = arguments[3];
            obj = Object(value(obj));
            callable(cb);
            list = keys(obj);
            if (compareFn) {
                list.sort(typeof compareFn === 'function' ? bind.call(compareFn, obj) : undefined);
            }
            if (typeof method !== 'function')
                method = list[method];
            return call.call(method, list, function (key, index) {
                if (!objPropertyIsEnumerable.call(obj, key))
                    return defVal;
                return call.call(cb, thisArg, obj[key], key, obj, index);
            });
        };
    };
},
/*es5-ext/object/assign/index*/
function _(require, module, exports) {
    module.exports = require(271    /* ./is-implemented */)() ? Object.assign : require(272    /* ./shim */);
},
/*es5-ext/object/assign/is-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        var assign = Object.assign, obj;
        if (typeof assign !== 'function')
            return false;
        obj = { foo: 'raz' };
        assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
        return obj.foo + obj.bar + obj.trzy === 'razdwatrzy';
    };
},
/*es5-ext/object/assign/shim*/
function _(require, module, exports) {
    var keys = require(279    /* ../keys */), value = require(289    /* ../valid-value */), max = Math.max;
    module.exports = function (dest, src) {
        var error, i, length = max(arguments.length, 2), assign;
        dest = Object(value(dest));
        assign = function (key) {
            try {
                dest[key] = src[key];
            } catch (e) {
                if (!error)
                    error = e;
            }
        };
        for (i = 1; i < length; ++i) {
            src = arguments[i];
            keys(src).forEach(assign);
        }
        if (error !== undefined)
            throw error;
        return dest;
    };
},
/*es5-ext/object/copy*/
function _(require, module, exports) {
    var aFrom = require(254    /* ../array/from */), assign = require(270    /* ./assign */), value = require(289    /* ./valid-value */);
    module.exports = function (obj) {
        var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
        if (copy !== obj && !propertyNames)
            return copy;
        var result = {};
        if (propertyNames) {
            aFrom(propertyNames, function (propertyName) {
                if (options.ensure || propertyName in obj)
                    result[propertyName] = obj[propertyName];
            });
        } else {
            assign(result, obj);
        }
        return result;
    };
},
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804
/*es5-ext/object/create*/
function _(require, module, exports) {
    var create = Object.create, shim;
    if (!require(285    /* ./set-prototype-of/is-implemented */)()) {
        shim = require(286    /* ./set-prototype-of/shim */);
    }
    module.exports = function () {
        var nullObject, polyProps, desc;
        if (!shim)
            return create;
        if (shim.level !== 1)
            return create;
        nullObject = {};
        polyProps = {};
        desc = {
            configurable: false,
            enumerable: false,
            writable: true,
            value: undefined
        };
        Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
            if (name === '__proto__') {
                polyProps[name] = {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: undefined
                };
                return;
            }
            polyProps[name] = desc;
        });
        Object.defineProperties(nullObject, polyProps);
        Object.defineProperty(shim, 'nullPolyfill', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: nullObject
        });
        return function (prototype, props) {
            return create(prototype === null ? nullObject : prototype, props);
        };
    }();
},
/*es5-ext/object/for-each*/
function _(require, module, exports) {
    module.exports = require(269    /* ./_iterate */)('forEach');
},
// Deprecated
/*es5-ext/object/is-callable*/
function _(require, module, exports) {
    module.exports = function (obj) {
        return typeof obj === 'function';
    };
},
/*es5-ext/object/is-object*/
function _(require, module, exports) {
    var isValue = require(278    /* ./is-value */);
    var map = {
        function: true,
        object: true
    };
    module.exports = function (value) {
        return isValue(value) && map[typeof value] || false;
    };
},
/*es5-ext/object/is-value*/
function _(require, module, exports) {
    var _undefined = require(259    /* ../function/noop */)();
    // Support ES3 engines
    module.exports = function (val) {
        return val !== _undefined && val !== null;
    };
},
/*es5-ext/object/keys/index*/
function _(require, module, exports) {
    module.exports = require(280    /* ./is-implemented */)() ? Object.keys : require(281    /* ./shim */);
},
/*es5-ext/object/keys/is-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        try {
            Object.keys('primitive');
            return true;
        } catch (e) {
            return false;
        }
    };
},
/*es5-ext/object/keys/shim*/
function _(require, module, exports) {
    var isValue = require(278    /* ../is-value */);
    var keys = Object.keys;
    module.exports = function (object) {
        return keys(isValue(object) ? Object(object) : object);
    };
},
/*es5-ext/object/map*/
function _(require, module, exports) {
    var callable = require(287    /* ./valid-callable */), forEach = require(275    /* ./for-each */), call = Function.prototype.call;
    module.exports = function (obj, cb) {
        var result = {}, thisArg = arguments[2];
        callable(cb);
        forEach(obj, function (value, key, targetObj, index) {
            result[key] = call.call(cb, thisArg, value, key, targetObj, index);
        });
        return result;
    };
},
/*es5-ext/object/normalize-options*/
function _(require, module, exports) {
    var isValue = require(278    /* ./is-value */);
    var forEach = Array.prototype.forEach, create = Object.create;
    var process = function (src, obj) {
        var key;
        for (key in src)
            obj[key] = src[key];
    };
    // eslint-disable-next-line no-unused-vars
    module.exports = function (opts1) {
        var result = create(null);
        forEach.call(arguments, function (options) {
            if (!isValue(options))
                return;
            process(Object(options), result);
        });
        return result;
    };
},
/*es5-ext/object/set-prototype-of/index*/
function _(require, module, exports) {
    module.exports = require(285    /* ./is-implemented */)() ? Object.setPrototypeOf : require(286    /* ./shim */);
},
/*es5-ext/object/set-prototype-of/is-implemented*/
function _(require, module, exports) {
    var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};
    module.exports = function () {
        var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
        if (typeof setPrototypeOf !== 'function')
            return false;
        return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
    };
},
/* eslint no-proto: "off" */
// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554
/*es5-ext/object/set-prototype-of/shim*/
function _(require, module, exports) {
    var isObject = require(277    /* ../is-object */), value = require(289    /* ../valid-value */), objIsPrototypeOf = Object.prototype.isPrototypeOf, defineProperty = Object.defineProperty, nullDesc = {
            configurable: true,
            enumerable: false,
            writable: true,
            value: undefined
        }, validate;
    validate = function (obj, prototype) {
        value(obj);
        if (prototype === null || isObject(prototype))
            return obj;
        throw new TypeError('Prototype must be null or an object');
    };
    module.exports = function (status) {
        var fn, set;
        if (!status)
            return null;
        if (status.level === 2) {
            if (status.set) {
                set = status.set;
                fn = function (obj, prototype) {
                    set.call(validate(obj, prototype), prototype);
                    return obj;
                };
            } else {
                fn = function (obj, prototype) {
                    validate(obj, prototype).__proto__ = prototype;
                    return obj;
                };
            }
        } else {
            fn = function self(obj, prototype) {
                var isNullBase;
                validate(obj, prototype);
                isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);
                if (isNullBase)
                    delete self.nullPolyfill.__proto__;
                if (prototype === null)
                    prototype = self.nullPolyfill;
                obj.__proto__ = prototype;
                if (isNullBase)
                    defineProperty(self.nullPolyfill, '__proto__', nullDesc);
                return obj;
            };
        }
        return Object.defineProperty(fn, 'level', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: status.level
        });
    }(function () {
        var tmpObj1 = Object.create(null), tmpObj2 = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
        if (desc) {
            try {
                set = desc.set;
                // Opera crashes at this point
                set.call(tmpObj1, tmpObj2);
            } catch (ignore) {
            }
            if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
                return {
                    set: set,
                    level: 2
                };
        }
        tmpObj1.__proto__ = tmpObj2;
        if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
            return { level: 2 };
        tmpObj1 = {};
        tmpObj1.__proto__ = tmpObj2;
        if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
            return { level: 1 };
        return false;
    }());
    require(274    /* ../create */);
},
/*es5-ext/object/valid-callable*/
function _(require, module, exports) {
    module.exports = function (fn) {
        if (typeof fn !== 'function')
            throw new TypeError(fn + ' is not a function');
        return fn;
    };
},
/*es5-ext/object/valid-object*/
function _(require, module, exports) {
    var isObject = require(277    /* ./is-object */);
    module.exports = function (value) {
        if (!isObject(value))
            throw new TypeError(value + ' is not an Object');
        return value;
    };
},
/*es5-ext/object/valid-value*/
function _(require, module, exports) {
    var isValue = require(278    /* ./is-value */);
    module.exports = function (value) {
        if (!isValue(value))
            throw new TypeError('Cannot use null or undefined');
        return value;
    };
},
/*es5-ext/string/#/contains/index*/
function _(require, module, exports) {
    module.exports = require(291    /* ./is-implemented */)() ? String.prototype.contains : require(292    /* ./shim */);
},
/*es5-ext/string/#/contains/is-implemented*/
function _(require, module, exports) {
    var str = 'razdwatrzy';
    module.exports = function () {
        if (typeof str.contains !== 'function')
            return false;
        return str.contains('dwa') === true && str.contains('foo') === false;
    };
},
/*es5-ext/string/#/contains/shim*/
function _(require, module, exports) {
    var indexOf = String.prototype.indexOf;
    module.exports = function (searchString) {
        return indexOf.call(this, searchString, arguments[1]) > -1;
    };
},
/*es5-ext/string/is-string*/
function _(require, module, exports) {
    var objToString = Object.prototype.toString, id = objToString.call('');
    module.exports = function (value) {
        return typeof value === 'string' || value && typeof value === 'object' && (value instanceof String || objToString.call(value) === id) || false;
    };
},
/*es5-ext/string/random-uniq*/
function _(require, module, exports) {
    var generated = Object.create(null), random = Math.random;
    module.exports = function () {
        var str;
        do {
            str = random().toString(36).slice(2);
        } while (generated[str]);
        return str;
    };
},
/*es6-iterator/array*/
function _(require, module, exports) {
    var setPrototypeOf = require(284    /* es5-ext/object/set-prototype-of */), contains = require(290    /* es5-ext/string/#/contains */), d = require(251    /* d */), Symbol = require(308    /* es6-symbol */), Iterator = require(298    /* ./ */);
    var defineProperty = Object.defineProperty, ArrayIterator;
    ArrayIterator = module.exports = function (arr, kind) {
        if (!(this instanceof ArrayIterator))
            throw new TypeError('Constructor requires \'new\'');
        Iterator.call(this, arr);
        if (!kind)
            kind = 'value';
        else if (contains.call(kind, 'key+value'))
            kind = 'key+value';
        else if (contains.call(kind, 'key'))
            kind = 'key';
        else
            kind = 'value';
        defineProperty(this, '__kind__', d('', kind));
    };
    if (setPrototypeOf)
        setPrototypeOf(ArrayIterator, Iterator);
    // Internal %ArrayIteratorPrototype% doesn't expose its constructor
    delete ArrayIterator.prototype.constructor;
    ArrayIterator.prototype = Object.create(Iterator.prototype, {
        _resolve: d(function (i) {
            if (this.__kind__ === 'value')
                return this.__list__[i];
            if (this.__kind__ === 'key+value')
                return [
                    i,
                    this.__list__[i]
                ];
            return i;
        })
    });
    defineProperty(ArrayIterator.prototype, Symbol.toStringTag, d('c', 'Array Iterator'));
},
/*es6-iterator/for-of*/
function _(require, module, exports) {
    var isArguments = require(257    /* es5-ext/function/is-arguments */), callable = require(287    /* es5-ext/object/valid-callable */), isString = require(293    /* es5-ext/string/is-string */), get = require(297    /* ./get */);
    var isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;
    module.exports = function (iterable, cb) {
        var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;
        if (isArray(iterable) || isArguments(iterable))
            mode = 'array';
        else if (isString(iterable))
            mode = 'string';
        else
            iterable = get(iterable);
        callable(cb);
        doBreak = function () {
            broken = true;
        };
        if (mode === 'array') {
            some.call(iterable, function (value) {
                call.call(cb, thisArg, value, doBreak);
                return broken;
            });
            return;
        }
        if (mode === 'string') {
            length = iterable.length;
            for (i = 0; i < length; ++i) {
                char = iterable[i];
                if (i + 1 < length) {
                    code = char.charCodeAt(0);
                    if (code >= 55296 && code <= 56319)
                        char += iterable[++i];
                }
                call.call(cb, thisArg, char, doBreak);
                if (broken)
                    break;
            }
            return;
        }
        result = iterable.next();
        while (!result.done) {
            call.call(cb, thisArg, result.value, doBreak);
            if (broken)
                return;
            result = iterable.next();
        }
    };
},
/*es6-iterator/get*/
function _(require, module, exports) {
    var isArguments = require(257    /* es5-ext/function/is-arguments */), isString = require(293    /* es5-ext/string/is-string */), ArrayIterator = require(295    /* ./array */), StringIterator = require(300    /* ./string */), iterable = require(301    /* ./valid-iterable */), iteratorSymbol = require(308    /* es6-symbol */).iterator;
    module.exports = function (obj) {
        if (typeof iterable(obj)[iteratorSymbol] === 'function')
            return obj[iteratorSymbol]();
        if (isArguments(obj))
            return new ArrayIterator(obj);
        if (isString(obj))
            return new StringIterator(obj);
        return new ArrayIterator(obj);
    };
},
/*es6-iterator/index*/
function _(require, module, exports) {
    var clear = require(252    /* es5-ext/array/#/clear */), assign = require(270    /* es5-ext/object/assign */), callable = require(287    /* es5-ext/object/valid-callable */), value = require(289    /* es5-ext/object/valid-value */), d = require(251    /* d */), autoBind = require(250    /* d/auto-bind */), Symbol = require(308    /* es6-symbol */);
    var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;
    module.exports = Iterator = function (list, context) {
        if (!(this instanceof Iterator))
            throw new TypeError('Constructor requires \'new\'');
        defineProperties(this, {
            __list__: d('w', value(list)),
            __context__: d('w', context),
            __nextIndex__: d('w', 0)
        });
        if (!context)
            return;
        callable(context.on);
        context.on('_add', this._onAdd);
        context.on('_delete', this._onDelete);
        context.on('_clear', this._onClear);
    };
    // Internal %IteratorPrototype% doesn't expose its constructor
    delete Iterator.prototype.constructor;
    defineProperties(Iterator.prototype, assign({
        _next: d(function () {
            var i;
            if (!this.__list__)
                return undefined;
            if (this.__redo__) {
                i = this.__redo__.shift();
                if (i !== undefined)
                    return i;
            }
            if (this.__nextIndex__ < this.__list__.length)
                return this.__nextIndex__++;
            this._unBind();
            return undefined;
        }),
        next: d(function () {
            return this._createResult(this._next());
        }),
        _createResult: d(function (i) {
            if (i === undefined)
                return {
                    done: true,
                    value: undefined
                };
            return {
                done: false,
                value: this._resolve(i)
            };
        }),
        _resolve: d(function (i) {
            return this.__list__[i];
        }),
        _unBind: d(function () {
            this.__list__ = null;
            delete this.__redo__;
            if (!this.__context__)
                return;
            this.__context__.off('_add', this._onAdd);
            this.__context__.off('_delete', this._onDelete);
            this.__context__.off('_clear', this._onClear);
            this.__context__ = null;
        }),
        toString: d(function () {
            return '[object ' + (this[Symbol.toStringTag] || 'Object') + ']';
        })
    }, autoBind({
        _onAdd: d(function (index) {
            if (index >= this.__nextIndex__)
                return;
            ++this.__nextIndex__;
            if (!this.__redo__) {
                defineProperty(this, '__redo__', d('c', [index]));
                return;
            }
            this.__redo__.forEach(function (redo, i) {
                if (redo >= index)
                    this.__redo__[i] = ++redo;
            }, this);
            this.__redo__.push(index);
        }),
        _onDelete: d(function (index) {
            var i;
            if (index >= this.__nextIndex__)
                return;
            --this.__nextIndex__;
            if (!this.__redo__)
                return;
            i = this.__redo__.indexOf(index);
            if (i !== -1)
                this.__redo__.splice(i, 1);
            this.__redo__.forEach(function (redo, j) {
                if (redo > index)
                    this.__redo__[j] = --redo;
            }, this);
        }),
        _onClear: d(function () {
            if (this.__redo__)
                clear.call(this.__redo__);
            this.__nextIndex__ = 0;
        })
    })));
    defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
        return this;
    }));
},
/*es6-iterator/is-iterable*/
function _(require, module, exports) {
    var isArguments = require(257    /* es5-ext/function/is-arguments */), isValue = require(278    /* es5-ext/object/is-value */), isString = require(293    /* es5-ext/string/is-string */);
    var iteratorSymbol = require(308    /* es6-symbol */).iterator, isArray = Array.isArray;
    module.exports = function (value) {
        if (!isValue(value))
            return false;
        if (isArray(value))
            return true;
        if (isString(value))
            return true;
        if (isArguments(value))
            return true;
        return typeof value[iteratorSymbol] === 'function';
    };
},
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols
/*es6-iterator/string*/
function _(require, module, exports) {
    var setPrototypeOf = require(284    /* es5-ext/object/set-prototype-of */), d = require(251    /* d */), Symbol = require(308    /* es6-symbol */), Iterator = require(298    /* ./ */);
    var defineProperty = Object.defineProperty, StringIterator;
    StringIterator = module.exports = function (str) {
        if (!(this instanceof StringIterator))
            throw new TypeError('Constructor requires \'new\'');
        str = String(str);
        Iterator.call(this, str);
        defineProperty(this, '__length__', d('', str.length));
    };
    if (setPrototypeOf)
        setPrototypeOf(StringIterator, Iterator);
    // Internal %ArrayIteratorPrototype% doesn't expose its constructor
    delete StringIterator.prototype.constructor;
    StringIterator.prototype = Object.create(Iterator.prototype, {
        _next: d(function () {
            if (!this.__list__)
                return undefined;
            if (this.__nextIndex__ < this.__length__)
                return this.__nextIndex__++;
            this._unBind();
            return undefined;
        }),
        _resolve: d(function (i) {
            var char = this.__list__[i], code;
            if (this.__nextIndex__ === this.__length__)
                return char;
            code = char.charCodeAt(0);
            if (code >= 55296 && code <= 56319)
                return char + this.__list__[this.__nextIndex__++];
            return char;
        })
    });
    defineProperty(StringIterator.prototype, Symbol.toStringTag, d('c', 'String Iterator'));
},
/*es6-iterator/valid-iterable*/
function _(require, module, exports) {
    var isIterable = require(299    /* ./is-iterable */);
    module.exports = function (value) {
        if (!isIterable(value))
            throw new TypeError(value + ' is not iterable');
        return value;
    };
},
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */
/*es6-promise/dist/es6-promise*/
function _(require, module, exports) {
    (function () {
        'use strict';
        function lib$es6$promise$utils$$objectOrFunction(x) {
            return typeof x === 'function' || typeof x === 'object' && x !== null;
        }
        function lib$es6$promise$utils$$isFunction(x) {
            return typeof x === 'function';
        }
        function lib$es6$promise$utils$$isMaybeThenable(x) {
            return typeof x === 'object' && x !== null;
        }
        var lib$es6$promise$utils$$_isArray;
        if (!Array.isArray) {
            lib$es6$promise$utils$$_isArray = function (x) {
                return Object.prototype.toString.call(x) === '[object Array]';
            };
        } else {
            lib$es6$promise$utils$$_isArray = Array.isArray;
        }
        var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
        var lib$es6$promise$asap$$len = 0;
        var lib$es6$promise$asap$$toString = {}.toString;
        var lib$es6$promise$asap$$vertxNext;
        var lib$es6$promise$asap$$customSchedulerFn;
        var lib$es6$promise$asap$$asap = function asap(callback, arg) {
            lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
            lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
            lib$es6$promise$asap$$len += 2;
            if (lib$es6$promise$asap$$len === 2) {
                // If len is 2, that means that we need to schedule an async flush.
                // If additional callbacks are queued before the queue is flushed, they
                // will be processed by this flush that we are scheduling.
                if (lib$es6$promise$asap$$customSchedulerFn) {
                    lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
                } else {
                    lib$es6$promise$asap$$scheduleFlush();
                }
            }
        };
        function lib$es6$promise$asap$$setScheduler(scheduleFn) {
            lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
        }
        function lib$es6$promise$asap$$setAsap(asapFn) {
            lib$es6$promise$asap$$asap = asapFn;
        }
        var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;
        var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
        var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
        var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
        // test for web worker but not in IE10
        var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
        // node
        function lib$es6$promise$asap$$useNextTick() {
            // node version 0.10.x displays a deprecation warning when nextTick is used recursively
            // see https://github.com/cujojs/when/issues/410 for details
            return function () {
                process.nextTick(lib$es6$promise$asap$$flush);
            };
        }
        // vertx
        function lib$es6$promise$asap$$useVertxTimer() {
            return function () {
                lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
            };
        }
        function lib$es6$promise$asap$$useMutationObserver() {
            var iterations = 0;
            var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
            var node = document.createTextNode('');
            observer.observe(node, { characterData: true });
            return function () {
                node.data = iterations = ++iterations % 2;
            };
        }
        // web worker
        function lib$es6$promise$asap$$useMessageChannel() {
            var channel = new MessageChannel();
            channel.port1.onmessage = lib$es6$promise$asap$$flush;
            return function () {
                channel.port2.postMessage(0);
            };
        }
        function lib$es6$promise$asap$$useSetTimeout() {
            return function () {
                setTimeout(lib$es6$promise$asap$$flush, 1);
            };
        }
        var lib$es6$promise$asap$$queue = new Array(1000);
        function lib$es6$promise$asap$$flush() {
            for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {
                var callback = lib$es6$promise$asap$$queue[i];
                var arg = lib$es6$promise$asap$$queue[i + 1];
                callback(arg);
                lib$es6$promise$asap$$queue[i] = undefined;
                lib$es6$promise$asap$$queue[i + 1] = undefined;
            }
            lib$es6$promise$asap$$len = 0;
        }
        function lib$es6$promise$asap$$attemptVertx() {
            try {
                var r = require;
                var vertx = r('vertx');
                lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
                return lib$es6$promise$asap$$useVertxTimer();
            } catch (e) {
                return lib$es6$promise$asap$$useSetTimeout();
            }
        }
        var lib$es6$promise$asap$$scheduleFlush;
        // Decide what async method to use to triggering processing of queued callbacks:
        if (lib$es6$promise$asap$$isNode) {
            lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
        } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
            lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
        } else if (lib$es6$promise$asap$$isWorker) {
            lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
        } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
            lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
        } else {
            lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
        }
        function lib$es6$promise$$internal$$noop() {
        }
        var lib$es6$promise$$internal$$PENDING = void 0;
        var lib$es6$promise$$internal$$FULFILLED = 1;
        var lib$es6$promise$$internal$$REJECTED = 2;
        var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
        function lib$es6$promise$$internal$$selfFulfillment() {
            return new TypeError('You cannot resolve a promise with itself');
        }
        function lib$es6$promise$$internal$$cannotReturnOwn() {
            return new TypeError('A promises callback cannot return that same promise.');
        }
        function lib$es6$promise$$internal$$getThen(promise) {
            try {
                return promise.then;
            } catch (error) {
                lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
                return lib$es6$promise$$internal$$GET_THEN_ERROR;
            }
        }
        function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
            try {
                then.call(value, fulfillmentHandler, rejectionHandler);
            } catch (e) {
                return e;
            }
        }
        function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
            lib$es6$promise$asap$$asap(function (promise) {
                var sealed = false;
                var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {
                    if (sealed) {
                        return;
                    }
                    sealed = true;
                    if (thenable !== value) {
                        lib$es6$promise$$internal$$resolve(promise, value);
                    } else {
                        lib$es6$promise$$internal$$fulfill(promise, value);
                    }
                }, function (reason) {
                    if (sealed) {
                        return;
                    }
                    sealed = true;
                    lib$es6$promise$$internal$$reject(promise, reason);
                }, 'Settle: ' + (promise._label || ' unknown promise'));
                if (!sealed && error) {
                    sealed = true;
                    lib$es6$promise$$internal$$reject(promise, error);
                }
            }, promise);
        }
        function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
            if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
                lib$es6$promise$$internal$$fulfill(promise, thenable._result);
            } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
                lib$es6$promise$$internal$$reject(promise, thenable._result);
            } else {
                lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {
                    lib$es6$promise$$internal$$resolve(promise, value);
                }, function (reason) {
                    lib$es6$promise$$internal$$reject(promise, reason);
                });
            }
        }
        function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
            if (maybeThenable.constructor === promise.constructor) {
                lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
            } else {
                var then = lib$es6$promise$$internal$$getThen(maybeThenable);
                if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
                    lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
                } else if (then === undefined) {
                    lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
                } else if (lib$es6$promise$utils$$isFunction(then)) {
                    lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
                } else {
                    lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
                }
            }
        }
        function lib$es6$promise$$internal$$resolve(promise, value) {
            if (promise === value) {
                lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
            } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
                lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
            } else {
                lib$es6$promise$$internal$$fulfill(promise, value);
            }
        }
        function lib$es6$promise$$internal$$publishRejection(promise) {
            if (promise._onerror) {
                promise._onerror(promise._result);
            }
            lib$es6$promise$$internal$$publish(promise);
        }
        function lib$es6$promise$$internal$$fulfill(promise, value) {
            if (promise._state !== lib$es6$promise$$internal$$PENDING) {
                return;
            }
            promise._result = value;
            promise._state = lib$es6$promise$$internal$$FULFILLED;
            if (promise._subscribers.length !== 0) {
                lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
            }
        }
        function lib$es6$promise$$internal$$reject(promise, reason) {
            if (promise._state !== lib$es6$promise$$internal$$PENDING) {
                return;
            }
            promise._state = lib$es6$promise$$internal$$REJECTED;
            promise._result = reason;
            lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
        }
        function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
            var subscribers = parent._subscribers;
            var length = subscribers.length;
            parent._onerror = null;
            subscribers[length] = child;
            subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
            subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;
            if (length === 0 && parent._state) {
                lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
            }
        }
        function lib$es6$promise$$internal$$publish(promise) {
            var subscribers = promise._subscribers;
            var settled = promise._state;
            if (subscribers.length === 0) {
                return;
            }
            var child, callback, detail = promise._result;
            for (var i = 0; i < subscribers.length; i += 3) {
                child = subscribers[i];
                callback = subscribers[i + settled];
                if (child) {
                    lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
                } else {
                    callback(detail);
                }
            }
            promise._subscribers.length = 0;
        }
        function lib$es6$promise$$internal$$ErrorObject() {
            this.error = null;
        }
        var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
        function lib$es6$promise$$internal$$tryCatch(callback, detail) {
            try {
                return callback(detail);
            } catch (e) {
                lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
                return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
            }
        }
        function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
            var hasCallback = lib$es6$promise$utils$$isFunction(callback), value, error, succeeded, failed;
            if (hasCallback) {
                value = lib$es6$promise$$internal$$tryCatch(callback, detail);
                if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
                    failed = true;
                    error = value.error;
                    value = null;
                } else {
                    succeeded = true;
                }
                if (promise === value) {
                    lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
                    return;
                }
            } else {
                value = detail;
                succeeded = true;
            }
            if (promise._state !== lib$es6$promise$$internal$$PENDING) {
            } else if (hasCallback && succeeded) {
                lib$es6$promise$$internal$$resolve(promise, value);
            } else if (failed) {
                lib$es6$promise$$internal$$reject(promise, error);
            } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
                lib$es6$promise$$internal$$fulfill(promise, value);
            } else if (settled === lib$es6$promise$$internal$$REJECTED) {
                lib$es6$promise$$internal$$reject(promise, value);
            }
        }
        function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
            try {
                resolver(function resolvePromise(value) {
                    lib$es6$promise$$internal$$resolve(promise, value);
                }, function rejectPromise(reason) {
                    lib$es6$promise$$internal$$reject(promise, reason);
                });
            } catch (e) {
                lib$es6$promise$$internal$$reject(promise, e);
            }
        }
        function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
            var enumerator = this;
            enumerator._instanceConstructor = Constructor;
            enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);
            if (enumerator._validateInput(input)) {
                enumerator._input = input;
                enumerator.length = input.length;
                enumerator._remaining = input.length;
                enumerator._init();
                if (enumerator.length === 0) {
                    lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
                } else {
                    enumerator.length = enumerator.length || 0;
                    enumerator._enumerate();
                    if (enumerator._remaining === 0) {
                        lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
                    }
                }
            } else {
                lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
            }
        }
        lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function (input) {
            return lib$es6$promise$utils$$isArray(input);
        };
        lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function () {
            return new Error('Array Methods must be provided an Array');
        };
        lib$es6$promise$enumerator$$Enumerator.prototype._init = function () {
            this._result = new Array(this.length);
        };
        var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
        lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {
            var enumerator = this;
            var length = enumerator.length;
            var promise = enumerator.promise;
            var input = enumerator._input;
            for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
                enumerator._eachEntry(input[i], i);
            }
        };
        lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {
            var enumerator = this;
            var c = enumerator._instanceConstructor;
            if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
                if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
                    entry._onerror = null;
                    enumerator._settledAt(entry._state, i, entry._result);
                } else {
                    enumerator._willSettleAt(c.resolve(entry), i);
                }
            } else {
                enumerator._remaining--;
                enumerator._result[i] = entry;
            }
        };
        lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {
            var enumerator = this;
            var promise = enumerator.promise;
            if (promise._state === lib$es6$promise$$internal$$PENDING) {
                enumerator._remaining--;
                if (state === lib$es6$promise$$internal$$REJECTED) {
                    lib$es6$promise$$internal$$reject(promise, value);
                } else {
                    enumerator._result[i] = value;
                }
            }
            if (enumerator._remaining === 0) {
                lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
            }
        };
        lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {
            var enumerator = this;
            lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {
                enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
            }, function (reason) {
                enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
            });
        };
        function lib$es6$promise$promise$all$$all(entries) {
            return new lib$es6$promise$enumerator$$default(this, entries).promise;
        }
        var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
        function lib$es6$promise$promise$race$$race(entries) {
            /*jshint validthis:true */
            var Constructor = this;
            var promise = new Constructor(lib$es6$promise$$internal$$noop);
            if (!lib$es6$promise$utils$$isArray(entries)) {
                lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
                return promise;
            }
            var length = entries.length;
            function onFulfillment(value) {
                lib$es6$promise$$internal$$resolve(promise, value);
            }
            function onRejection(reason) {
                lib$es6$promise$$internal$$reject(promise, reason);
            }
            for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
                lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
            }
            return promise;
        }
        var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
        function lib$es6$promise$promise$resolve$$resolve(object) {
            /*jshint validthis:true */
            var Constructor = this;
            if (object && typeof object === 'object' && object.constructor === Constructor) {
                return object;
            }
            var promise = new Constructor(lib$es6$promise$$internal$$noop);
            lib$es6$promise$$internal$$resolve(promise, object);
            return promise;
        }
        var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
        function lib$es6$promise$promise$reject$$reject(reason) {
            /*jshint validthis:true */
            var Constructor = this;
            var promise = new Constructor(lib$es6$promise$$internal$$noop);
            lib$es6$promise$$internal$$reject(promise, reason);
            return promise;
        }
        var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
        var lib$es6$promise$promise$$counter = 0;
        function lib$es6$promise$promise$$needsResolver() {
            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
        }
        function lib$es6$promise$promise$$needsNew() {
            throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
        }
        var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
        /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
        function lib$es6$promise$promise$$Promise(resolver) {
            this._id = lib$es6$promise$promise$$counter++;
            this._state = undefined;
            this._result = undefined;
            this._subscribers = [];
            if (lib$es6$promise$$internal$$noop !== resolver) {
                if (!lib$es6$promise$utils$$isFunction(resolver)) {
                    lib$es6$promise$promise$$needsResolver();
                }
                if (!(this instanceof lib$es6$promise$promise$$Promise)) {
                    lib$es6$promise$promise$$needsNew();
                }
                lib$es6$promise$$internal$$initializePromise(this, resolver);
            }
        }
        lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
        lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
        lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
        lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
        lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
        lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
        lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
        lib$es6$promise$promise$$Promise.prototype = {
            constructor: lib$es6$promise$promise$$Promise,
            /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
            then: function (onFulfillment, onRejection) {
                var parent = this;
                var state = parent._state;
                if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
                    return this;
                }
                var child = new this.constructor(lib$es6$promise$$internal$$noop);
                var result = parent._result;
                if (state) {
                    var callback = arguments[state - 1];
                    lib$es6$promise$asap$$asap(function () {
                        lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
                    });
                } else {
                    lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
                }
                return child;
            },
            /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
            'catch': function (onRejection) {
                return this.then(null, onRejection);
            }
        };
        function lib$es6$promise$polyfill$$polyfill() {
            var local;
            if (typeof global !== 'undefined') {
                local = global;
            } else if (typeof self !== 'undefined') {
                local = self;
            } else {
                try {
                    local = Function('return this')();
                } catch (e) {
                    throw new Error('polyfill failed because global object is unavailable in this environment');
                }
            }
            var P = local.Promise;
            if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
                return;
            }
            local.Promise = lib$es6$promise$promise$$default;
        }
        var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
        var lib$es6$promise$umd$$ES6Promise = {
            'Promise': lib$es6$promise$promise$$default,
            'polyfill': lib$es6$promise$polyfill$$default
        };
        /* global define:true module:true window: true */
        if (typeof define === 'function' && define['amd']) {
            define(function () {
                return lib$es6$promise$umd$$ES6Promise;
            });
        } else if (typeof module !== 'undefined' && module['exports']) {
            module['exports'] = lib$es6$promise$umd$$ES6Promise;
        } else if (typeof this !== 'undefined') {
            this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
        }
        lib$es6$promise$polyfill$$default();
    }.call(this));
},
/*es6-set/implement*/
function _(require, module, exports) {
    if (!require(304    /* ./is-implemented */)()) {
        Object.defineProperty(require(260    /* es5-ext/global */), 'Set', {
            value: require(307    /* ./polyfill */),
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
},
/*es6-set/is-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        var set, iterator, result;
        if (typeof Set !== 'function')
            return false;
        set = new Set([
            'raz',
            'dwa',
            'trzy'
        ]);
        if (String(set) !== '[object Set]')
            return false;
        if (set.size !== 3)
            return false;
        if (typeof set.add !== 'function')
            return false;
        if (typeof set.clear !== 'function')
            return false;
        if (typeof set.delete !== 'function')
            return false;
        if (typeof set.entries !== 'function')
            return false;
        if (typeof set.forEach !== 'function')
            return false;
        if (typeof set.has !== 'function')
            return false;
        if (typeof set.keys !== 'function')
            return false;
        if (typeof set.values !== 'function')
            return false;
        iterator = set.values();
        result = iterator.next();
        if (result.done !== false)
            return false;
        if (result.value !== 'raz')
            return false;
        return true;
    };
},
// Exports true if environment provides native `Set` implementation,
// whatever that is.
/*es6-set/is-native-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        if (typeof Set === 'undefined')
            return false;
        return Object.prototype.toString.call(Set.prototype) === '[object Set]';
    }();
},
/*es6-set/lib/iterator*/
function _(require, module, exports) {
    var setPrototypeOf = require(284    /* es5-ext/object/set-prototype-of */), contains = require(290    /* es5-ext/string/#/contains */), d = require(251    /* d */), Iterator = require(298    /* es6-iterator */), toStringTagSymbol = require(308    /* es6-symbol */).toStringTag, defineProperty = Object.defineProperty, SetIterator;
    SetIterator = module.exports = function (set, kind) {
        if (!(this instanceof SetIterator))
            return new SetIterator(set, kind);
        Iterator.call(this, set.__setData__, set);
        if (!kind)
            kind = 'value';
        else if (contains.call(kind, 'key+value'))
            kind = 'key+value';
        else
            kind = 'value';
        defineProperty(this, '__kind__', d('', kind));
    };
    if (setPrototypeOf)
        setPrototypeOf(SetIterator, Iterator);
    SetIterator.prototype = Object.create(Iterator.prototype, {
        constructor: d(SetIterator),
        _resolve: d(function (i) {
            if (this.__kind__ === 'value')
                return this.__list__[i];
            return [
                this.__list__[i],
                this.__list__[i]
            ];
        }),
        toString: d(function () {
            return '[object Set Iterator]';
        })
    });
    defineProperty(SetIterator.prototype, toStringTagSymbol, d('c', 'Set Iterator'));
},
/*es6-set/polyfill*/
function _(require, module, exports) {
    var clear = require(252    /* es5-ext/array/#/clear */), eIndexOf = require(253    /* es5-ext/array/#/e-index-of */), setPrototypeOf = require(284    /* es5-ext/object/set-prototype-of */), callable = require(287    /* es5-ext/object/valid-callable */), d = require(251    /* d */), ee = require(317    /* event-emitter */), Symbol = require(308    /* es6-symbol */), iterator = require(301    /* es6-iterator/valid-iterable */), forOf = require(296    /* es6-iterator/for-of */), Iterator = require(306    /* ./lib/iterator */), isNative = require(305    /* ./is-native-implemented */), call = Function.prototype.call, defineProperty = Object.defineProperty, getPrototypeOf = Object.getPrototypeOf, SetPoly, getValues, NativeSet;
    if (isNative)
        NativeSet = Set;
    module.exports = SetPoly = function Set() {
        var iterable = arguments[0], self;
        if (!(this instanceof SetPoly))
            throw new TypeError('Constructor requires \'new\'');
        if (isNative && setPrototypeOf)
            self = setPrototypeOf(new NativeSet(), getPrototypeOf(this));
        else
            self = this;
        if (iterable != null)
            iterator(iterable);
        defineProperty(self, '__setData__', d('c', []));
        if (!iterable)
            return self;
        forOf(iterable, function (value) {
            if (eIndexOf.call(this, value) !== -1)
                return;
            this.push(value);
        }, self.__setData__);
        return self;
    };
    if (isNative) {
        if (setPrototypeOf)
            setPrototypeOf(SetPoly, NativeSet);
        SetPoly.prototype = Object.create(NativeSet.prototype, { constructor: d(SetPoly) });
    }
    ee(Object.defineProperties(SetPoly.prototype, {
        add: d(function (value) {
            if (this.has(value))
                return this;
            this.emit('_add', this.__setData__.push(value) - 1, value);
            return this;
        }),
        clear: d(function () {
            if (!this.__setData__.length)
                return;
            clear.call(this.__setData__);
            this.emit('_clear');
        }),
        delete: d(function (value) {
            var index = eIndexOf.call(this.__setData__, value);
            if (index === -1)
                return false;
            this.__setData__.splice(index, 1);
            this.emit('_delete', index, value);
            return true;
        }),
        entries: d(function () {
            return new Iterator(this, 'key+value');
        }),
        forEach: d(function (cb) {
            var thisArg = arguments[1], iterator, result, value;
            callable(cb);
            iterator = this.values();
            result = iterator._next();
            while (result !== undefined) {
                value = iterator._resolve(result);
                call.call(cb, thisArg, value, value, this);
                result = iterator._next();
            }
        }),
        has: d(function (value) {
            return eIndexOf.call(this.__setData__, value) !== -1;
        }),
        keys: d(getValues = function () {
            return this.values();
        }),
        size: d.gs(function () {
            return this.__setData__.length;
        }),
        values: d(function () {
            return new Iterator(this);
        }),
        toString: d(function () {
            return '[object Set]';
        })
    }));
    defineProperty(SetPoly.prototype, Symbol.iterator, d(getValues));
    defineProperty(SetPoly.prototype, Symbol.toStringTag, d('c', 'Set'));
},
/*es6-symbol/index*/
function _(require, module, exports) {
    module.exports = require(309    /* ./is-implemented */)() ? Symbol : require(311    /* ./polyfill */);
},
/*es6-symbol/is-implemented*/
function _(require, module, exports) {
    var validTypes = {
        object: true,
        symbol: true
    };
    module.exports = function () {
        var symbol;
        if (typeof Symbol !== 'function')
            return false;
        symbol = Symbol('test symbol');
        try {
            String(symbol);
        } catch (e) {
            return false;
        }
        // Return 'true' also for polyfills
        if (!validTypes[typeof Symbol.iterator])
            return false;
        if (!validTypes[typeof Symbol.toPrimitive])
            return false;
        if (!validTypes[typeof Symbol.toStringTag])
            return false;
        return true;
    };
},
/*es6-symbol/is-symbol*/
function _(require, module, exports) {
    module.exports = function (x) {
        if (!x)
            return false;
        if (typeof x === 'symbol')
            return true;
        if (!x.constructor)
            return false;
        if (x.constructor.name !== 'Symbol')
            return false;
        return x[x.constructor.toStringTag] === 'Symbol';
    };
},
// ES2015 Symbol polyfill for environments that do not (or partially) support it
/*es6-symbol/polyfill*/
function _(require, module, exports) {
    var d = require(251    /* d */), validateSymbol = require(312    /* ./validate-symbol */), create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, objPrototype = Object.prototype, NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null), isNativeSafe;
    if (typeof Symbol === 'function') {
        NativeSymbol = Symbol;
        try {
            String(NativeSymbol());
            isNativeSafe = true;
        } catch (ignore) {
        }
    }
    var generateName = function () {
        var created = create(null);
        return function (desc) {
            var postfix = 0, name, ie11BugWorkaround;
            while (created[desc + (postfix || '')])
                ++postfix;
            desc += postfix || '';
            created[desc] = true;
            name = '@@' + desc;
            defineProperty(objPrototype, name, d.gs(null, function (value) {
                // For IE11 issue see:
                // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
                //    ie11-broken-getters-on-dom-objects
                // https://github.com/medikoo/es6-symbol/issues/12
                if (ie11BugWorkaround)
                    return;
                ie11BugWorkaround = true;
                defineProperty(this, name, d(value));
                ie11BugWorkaround = false;
            }));
            return name;
        };
    }();
    // Internal constructor (not one exposed) for creating Symbol instances.
    // This one is used to ensure that `someSymbol instanceof Symbol` always return false
    HiddenSymbol = function Symbol(description) {
        if (this instanceof HiddenSymbol)
            throw new TypeError('Symbol is not a constructor');
        return SymbolPolyfill(description);
    };
    // Exposed `Symbol` constructor
    // (returns instances of HiddenSymbol)
    module.exports = SymbolPolyfill = function Symbol(description) {
        var symbol;
        if (this instanceof Symbol)
            throw new TypeError('Symbol is not a constructor');
        if (isNativeSafe)
            return NativeSymbol(description);
        symbol = create(HiddenSymbol.prototype);
        description = description === undefined ? '' : String(description);
        return defineProperties(symbol, {
            __description__: d('', description),
            __name__: d('', generateName(description))
        });
    };
    defineProperties(SymbolPolyfill, {
        for: d(function (key) {
            if (globalSymbols[key])
                return globalSymbols[key];
            return globalSymbols[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function (s) {
            var key;
            validateSymbol(s);
            for (key in globalSymbols)
                if (globalSymbols[key] === s)
                    return key;
        }),
        // To ensure proper interoperability with other native functions (e.g. Array.from)
        // fallback to eventual native implementation of given symbol
        hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),
        isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill('isConcatSpreadable')),
        iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),
        match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),
        replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),
        search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),
        species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),
        split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),
        toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),
        toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),
        unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables'))
    });
    // Internal tweaks for real symbol producer
    defineProperties(HiddenSymbol.prototype, {
        constructor: d(SymbolPolyfill),
        toString: d('', function () {
            return this.__name__;
        })
    });
    // Proper implementation of methods exposed on Symbol.prototype
    // They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
    defineProperties(SymbolPolyfill.prototype, {
        toString: d(function () {
            return 'Symbol (' + validateSymbol(this).__description__ + ')';
        }),
        valueOf: d(function () {
            return validateSymbol(this);
        })
    });
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
        var symbol = validateSymbol(this);
        if (typeof symbol === 'symbol')
            return symbol;
        return symbol.toString();
    }));
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));
    // Proper implementaton of toPrimitive and toStringTag for returned symbol instances
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
    // Note: It's important to define `toPrimitive` as last one, as some implementations
    // implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
    // And that may invoke error in definition flow:
    // See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
},
/*es6-symbol/validate-symbol*/
function _(require, module, exports) {
    var isSymbol = require(310    /* ./is-symbol */);
    module.exports = function (value) {
        if (!isSymbol(value))
            throw new TypeError(value + ' is not a symbol');
        return value;
    };
},
/*es6-weak-map/implement*/
function _(require, module, exports) {
    if (!require(314    /* ./is-implemented */)()) {
        Object.defineProperty(require(260    /* es5-ext/global */), 'WeakMap', {
            value: require(316    /* ./polyfill */),
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
},
/*es6-weak-map/is-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        var weakMap, x;
        if (typeof WeakMap !== 'function')
            return false;
        try {
            // WebKit doesn't support arguments and crashes
            weakMap = new WeakMap([
                [
                    x = {},
                    'one'
                ],
                [
                    {},
                    'two'
                ],
                [
                    {},
                    'three'
                ]
            ]);
        } catch (e) {
            return false;
        }
        if (String(weakMap) !== '[object WeakMap]')
            return false;
        if (typeof weakMap.set !== 'function')
            return false;
        if (weakMap.set({}, 1) !== weakMap)
            return false;
        if (typeof weakMap.delete !== 'function')
            return false;
        if (typeof weakMap.has !== 'function')
            return false;
        if (weakMap.get(x) !== 'one')
            return false;
        return true;
    };
},
// Exports true if environment provides native `WeakMap` implementation, whatever that is.
/*es6-weak-map/is-native-implemented*/
function _(require, module, exports) {
    module.exports = function () {
        if (typeof WeakMap !== 'function')
            return false;
        return Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]';
    }();
},
/*es6-weak-map/polyfill*/
function _(require, module, exports) {
    var setPrototypeOf = require(284    /* es5-ext/object/set-prototype-of */), object = require(288    /* es5-ext/object/valid-object */), value = require(289    /* es5-ext/object/valid-value */), randomUniq = require(294    /* es5-ext/string/random-uniq */), d = require(251    /* d */), getIterator = require(297    /* es6-iterator/get */), forOf = require(296    /* es6-iterator/for-of */), toStringTagSymbol = require(308    /* es6-symbol */).toStringTag, isNative = require(315    /* ./is-native-implemented */), isArray = Array.isArray, defineProperty = Object.defineProperty, hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf, WeakMapPoly;
    module.exports = WeakMapPoly = function () {
        var iterable = arguments[0], self;
        if (!(this instanceof WeakMapPoly))
            throw new TypeError('Constructor requires \'new\'');
        if (isNative && setPrototypeOf && WeakMap !== WeakMapPoly) {
            self = setPrototypeOf(new WeakMap(), getPrototypeOf(this));
        } else {
            self = this;
        }
        if (iterable != null) {
            if (!isArray(iterable))
                iterable = getIterator(iterable);
        }
        defineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));
        if (!iterable)
            return self;
        forOf(iterable, function (val) {
            value(val);
            self.set(val[0], val[1]);
        });
        return self;
    };
    if (isNative) {
        if (setPrototypeOf)
            setPrototypeOf(WeakMapPoly, WeakMap);
        WeakMapPoly.prototype = Object.create(WeakMap.prototype, { constructor: d(WeakMapPoly) });
    }
    Object.defineProperties(WeakMapPoly.prototype, {
        delete: d(function (key) {
            if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
                delete key[this.__weakMapData__];
                return true;
            }
            return false;
        }),
        get: d(function (key) {
            if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
                return key[this.__weakMapData__];
            }
        }),
        has: d(function (key) {
            return hasOwnProperty.call(object(key), this.__weakMapData__);
        }),
        set: d(function (key, value) {
            defineProperty(object(key), this.__weakMapData__, d('c', value));
            return this;
        }),
        toString: d(function () {
            return '[object WeakMap]';
        })
    });
    defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));
},
/*event-emitter/index*/
function _(require, module, exports) {
    var d = require(251    /* d */), callable = require(287    /* es5-ext/object/valid-callable */), apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, hasOwnProperty = Object.prototype.hasOwnProperty, descriptor = {
            configurable: true,
            enumerable: false,
            writable: true
        }, on, once, off, emit, methods, descriptors, base;
    on = function (type, listener) {
        var data;
        callable(listener);
        if (!hasOwnProperty.call(this, '__ee__')) {
            data = descriptor.value = create(null);
            defineProperty(this, '__ee__', descriptor);
            descriptor.value = null;
        } else {
            data = this.__ee__;
        }
        if (!data[type])
            data[type] = listener;
        else if (typeof data[type] === 'object')
            data[type].push(listener);
        else
            data[type] = [
                data[type],
                listener
            ];
        return this;
    };
    once = function (type, listener) {
        var once, self;
        callable(listener);
        self = this;
        on.call(this, type, once = function () {
            off.call(self, type, once);
            apply.call(listener, this, arguments);
        });
        once.__eeOnceListener__ = listener;
        return this;
    };
    off = function (type, listener) {
        var data, listeners, candidate, i;
        callable(listener);
        if (!hasOwnProperty.call(this, '__ee__'))
            return this;
        data = this.__ee__;
        if (!data[type])
            return this;
        listeners = data[type];
        if (typeof listeners === 'object') {
            for (i = 0; candidate = listeners[i]; ++i) {
                if (candidate === listener || candidate.__eeOnceListener__ === listener) {
                    if (listeners.length === 2)
                        data[type] = listeners[i ? 0 : 1];
                    else
                        listeners.splice(i, 1);
                }
            }
        } else {
            if (listeners === listener || listeners.__eeOnceListener__ === listener) {
                delete data[type];
            }
        }
        return this;
    };
    emit = function (type) {
        var i, l, listener, listeners, args;
        if (!hasOwnProperty.call(this, '__ee__'))
            return;
        listeners = this.__ee__[type];
        if (!listeners)
            return;
        if (typeof listeners === 'object') {
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i)
                args[i - 1] = arguments[i];
            listeners = listeners.slice();
            for (i = 0; listener = listeners[i]; ++i) {
                apply.call(listener, this, args);
            }
        } else {
            switch (arguments.length) {
            case 1:
                call.call(listeners, this);
                break;
            case 2:
                call.call(listeners, this, arguments[1]);
                break;
            case 3:
                call.call(listeners, this, arguments[1], arguments[2]);
                break;
            default:
                l = arguments.length;
                args = new Array(l - 1);
                for (i = 1; i < l; ++i) {
                    args[i - 1] = arguments[i];
                }
                apply.call(listeners, this, args);
            }
        }
    };
    methods = {
        on: on,
        once: once,
        off: off,
        emit: emit
    };
    descriptors = {
        on: d(on),
        once: d(once),
        off: d(off),
        emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module.exports = exports = function (o) {
        return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports.methods = methods;
},
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
/*hammerjs/hammer*/
function _(require, module, exports) {
    (function (window, document, exportName, undefined) {
        'use strict';
        var VENDOR_PREFIXES = [
            '',
            'webkit',
            'Moz',
            'MS',
            'ms',
            'o'
        ];
        var TEST_ELEMENT = document.createElement('div');
        var TYPE_FUNCTION = 'function';
        var round = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        /**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
        function setTimeoutContext(fn, timeout, context) {
            return setTimeout(bindFn(fn, context), timeout);
        }
        /**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
        function invokeArrayArg(arg, fn, context) {
            if (Array.isArray(arg)) {
                each(arg, context[fn], context);
                return true;
            }
            return false;
        }
        /**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
        function each(obj, iterator, context) {
            var i;
            if (!obj) {
                return;
            }
            if (obj.forEach) {
                obj.forEach(iterator, context);
            } else if (obj.length !== undefined) {
                i = 0;
                while (i < obj.length) {
                    iterator.call(context, obj[i], i, obj);
                    i++;
                }
            } else {
                for (i in obj) {
                    obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
                }
            }
        }
        /**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
        function deprecate(method, name, message) {
            var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
            return function () {
                var e = new Error('get-stack-trace');
                var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
                var log = window.console && (window.console.warn || window.console.log);
                if (log) {
                    log.call(window.console, deprecationMessage, stack);
                }
                return method.apply(this, arguments);
            };
        }
        /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
        var assign;
        if (typeof Object.assign !== 'function') {
            assign = function assign(target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert undefined or null to object');
                }
                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined && source !== null) {
                        for (var nextKey in source) {
                            if (source.hasOwnProperty(nextKey)) {
                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }
                return output;
            };
        } else {
            assign = Object.assign;
        }
        /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
        var extend = deprecate(function extend(dest, src, merge) {
            var keys = Object.keys(src);
            var i = 0;
            while (i < keys.length) {
                if (!merge || merge && dest[keys[i]] === undefined) {
                    dest[keys[i]] = src[keys[i]];
                }
                i++;
            }
            return dest;
        }, 'extend', 'Use `assign`.');
        /**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
        var merge = deprecate(function merge(dest, src) {
            return extend(dest, src, true);
        }, 'merge', 'Use `assign`.');
        /**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
        function inherit(child, base, properties) {
            var baseP = base.prototype, childP;
            childP = child.prototype = Object.create(baseP);
            childP.constructor = child;
            childP._super = baseP;
            if (properties) {
                assign(childP, properties);
            }
        }
        /**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
        function bindFn(fn, context) {
            return function boundFn() {
                return fn.apply(context, arguments);
            };
        }
        /**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
        function boolOrFn(val, args) {
            if (typeof val == TYPE_FUNCTION) {
                return val.apply(args ? args[0] || undefined : undefined, args);
            }
            return val;
        }
        /**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
        function ifUndefined(val1, val2) {
            return val1 === undefined ? val2 : val1;
        }
        /**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
        function addEventListeners(target, types, handler) {
            each(splitStr(types), function (type) {
                target.addEventListener(type, handler, false);
            });
        }
        /**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
        function removeEventListeners(target, types, handler) {
            each(splitStr(types), function (type) {
                target.removeEventListener(type, handler, false);
            });
        }
        /**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
        function hasParent(node, parent) {
            while (node) {
                if (node == parent) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        }
        /**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
        function inStr(str, find) {
            return str.indexOf(find) > -1;
        }
        /**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
        function splitStr(str) {
            return str.trim().split(/\s+/g);
        }
        /**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
        function inArray(src, find, findByKey) {
            if (src.indexOf && !findByKey) {
                return src.indexOf(find);
            } else {
                var i = 0;
                while (i < src.length) {
                    if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                        return i;
                    }
                    i++;
                }
                return -1;
            }
        }
        /**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
        function toArray(obj) {
            return Array.prototype.slice.call(obj, 0);
        }
        /**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
        function uniqueArray(src, key, sort) {
            var results = [];
            var values = [];
            var i = 0;
            while (i < src.length) {
                var val = key ? src[i][key] : src[i];
                if (inArray(values, val) < 0) {
                    results.push(src[i]);
                }
                values[i] = val;
                i++;
            }
            if (sort) {
                if (!key) {
                    results = results.sort();
                } else {
                    results = results.sort(function sortUniqueArray(a, b) {
                        return a[key] > b[key];
                    });
                }
            }
            return results;
        }
        /**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
        function prefixed(obj, property) {
            var prefix, prop;
            var camelProp = property[0].toUpperCase() + property.slice(1);
            var i = 0;
            while (i < VENDOR_PREFIXES.length) {
                prefix = VENDOR_PREFIXES[i];
                prop = prefix ? prefix + camelProp : property;
                if (prop in obj) {
                    return prop;
                }
                i++;
            }
            return undefined;
        }
        /**
 * get a unique id
 * @returns {number} uniqueId
 */
        var _uniqueId = 1;
        function uniqueId() {
            return _uniqueId++;
        }
        /**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
        function getWindowForElement(element) {
            var doc = element.ownerDocument || element;
            return doc.defaultView || doc.parentWindow || window;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = 'ontouchstart' in window;
        var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = 'touch';
        var INPUT_TYPE_PEN = 'pen';
        var INPUT_TYPE_MOUSE = 'mouse';
        var INPUT_TYPE_KINECT = 'kinect';
        var COMPUTE_INTERVAL = 25;
        var INPUT_START = 1;
        var INPUT_MOVE = 2;
        var INPUT_END = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = [
            'x',
            'y'
        ];
        var PROPS_CLIENT_XY = [
            'clientX',
            'clientY'
        ];
        /**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
        function Input(manager, callback) {
            var self = this;
            this.manager = manager;
            this.callback = callback;
            this.element = manager.element;
            this.target = manager.options.inputTarget;
            // smaller wrapper around the handler, for the scope and the enabled state of the manager,
            // so when disabled the input events are completely bypassed.
            this.domHandler = function (ev) {
                if (boolOrFn(manager.options.enable, [manager])) {
                    self.handler(ev);
                }
            };
            this.init();
        }
        Input.prototype = {
            /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
            handler: function () {
            },
            /**
     * bind the events
     */
            init: function () {
                this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
            },
            /**
     * unbind the events
     */
            destroy: function () {
                this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
            }
        };
        /**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
        function createInputInstance(manager) {
            var Type;
            var inputClass = manager.options.inputClass;
            if (inputClass) {
                Type = inputClass;
            } else if (SUPPORT_POINTER_EVENTS) {
                Type = PointerEventInput;
            } else if (SUPPORT_ONLY_TOUCH) {
                Type = TouchInput;
            } else if (!SUPPORT_TOUCH) {
                Type = MouseInput;
            } else {
                Type = TouchMouseInput;
            }
            return new Type(manager, inputHandler);
        }
        /**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
        function inputHandler(manager, eventType, input) {
            var pointersLen = input.pointers.length;
            var changedPointersLen = input.changedPointers.length;
            var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
            var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
            input.isFirst = !!isFirst;
            input.isFinal = !!isFinal;
            if (isFirst) {
                manager.session = {};
            }
            // source event is the normalized value of the domEvents
            // like 'touchstart, mouseup, pointerdown'
            input.eventType = eventType;
            // compute scale, rotation etc
            computeInputData(manager, input);
            // emit secret event
            manager.emit('hammer.input', input);
            manager.recognize(input);
            manager.session.prevInput = input;
        }
        /**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
        function computeInputData(manager, input) {
            var session = manager.session;
            var pointers = input.pointers;
            var pointersLength = pointers.length;
            // store the first input to calculate the distance and direction
            if (!session.firstInput) {
                session.firstInput = simpleCloneInputData(input);
            }
            // to compute scale and rotation we need to store the multiple touches
            if (pointersLength > 1 && !session.firstMultiple) {
                session.firstMultiple = simpleCloneInputData(input);
            } else if (pointersLength === 1) {
                session.firstMultiple = false;
            }
            var firstInput = session.firstInput;
            var firstMultiple = session.firstMultiple;
            var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
            var center = input.center = getCenter(pointers);
            input.timeStamp = now();
            input.deltaTime = input.timeStamp - firstInput.timeStamp;
            input.angle = getAngle(offsetCenter, center);
            input.distance = getDistance(offsetCenter, center);
            computeDeltaXY(session, input);
            input.offsetDirection = getDirection(input.deltaX, input.deltaY);
            var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
            input.overallVelocityX = overallVelocity.x;
            input.overallVelocityY = overallVelocity.y;
            input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
            input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
            input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
            input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
            computeIntervalInputData(session, input);
            // find the correct target
            var target = manager.element;
            if (hasParent(input.srcEvent.target, target)) {
                target = input.srcEvent.target;
            }
            input.target = target;
        }
        function computeDeltaXY(session, input) {
            var center = input.center;
            var offset = session.offsetDelta || {};
            var prevDelta = session.prevDelta || {};
            var prevInput = session.prevInput || {};
            if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
                prevDelta = session.prevDelta = {
                    x: prevInput.deltaX || 0,
                    y: prevInput.deltaY || 0
                };
                offset = session.offsetDelta = {
                    x: center.x,
                    y: center.y
                };
            }
            input.deltaX = prevDelta.x + (center.x - offset.x);
            input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        /**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
        function computeIntervalInputData(session, input) {
            var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
            if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
                var deltaX = input.deltaX - last.deltaX;
                var deltaY = input.deltaY - last.deltaY;
                var v = getVelocity(deltaTime, deltaX, deltaY);
                velocityX = v.x;
                velocityY = v.y;
                velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
                direction = getDirection(deltaX, deltaY);
                session.lastInterval = input;
            } else {
                // use latest velocity info if it doesn't overtake a minimum period
                velocity = last.velocity;
                velocityX = last.velocityX;
                velocityY = last.velocityY;
                direction = last.direction;
            }
            input.velocity = velocity;
            input.velocityX = velocityX;
            input.velocityY = velocityY;
            input.direction = direction;
        }
        /**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
        function simpleCloneInputData(input) {
            // make a simple copy of the pointers because we will get a reference if we don't
            // we only need clientXY for the calculations
            var pointers = [];
            var i = 0;
            while (i < input.pointers.length) {
                pointers[i] = {
                    clientX: round(input.pointers[i].clientX),
                    clientY: round(input.pointers[i].clientY)
                };
                i++;
            }
            return {
                timeStamp: now(),
                pointers: pointers,
                center: getCenter(pointers),
                deltaX: input.deltaX,
                deltaY: input.deltaY
            };
        }
        /**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
        function getCenter(pointers) {
            var pointersLength = pointers.length;
            // no need to loop when only one touch
            if (pointersLength === 1) {
                return {
                    x: round(pointers[0].clientX),
                    y: round(pointers[0].clientY)
                };
            }
            var x = 0, y = 0, i = 0;
            while (i < pointersLength) {
                x += pointers[i].clientX;
                y += pointers[i].clientY;
                i++;
            }
            return {
                x: round(x / pointersLength),
                y: round(y / pointersLength)
            };
        }
        /**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
        function getVelocity(deltaTime, x, y) {
            return {
                x: x / deltaTime || 0,
                y: y / deltaTime || 0
            };
        }
        /**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
        function getDirection(x, y) {
            if (x === y) {
                return DIRECTION_NONE;
            }
            if (abs(x) >= abs(y)) {
                return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        /**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
        function getDistance(p1, p2, props) {
            if (!props) {
                props = PROPS_XY;
            }
            var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
            return Math.sqrt(x * x + y * y);
        }
        /**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
        function getAngle(p1, p2, props) {
            if (!props) {
                props = PROPS_XY;
            }
            var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
            return Math.atan2(y, x) * 180 / Math.PI;
        }
        /**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
        function getRotation(start, end) {
            return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }
        /**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
        function getScale(start, end) {
            return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP = {
            mousedown: INPUT_START,
            mousemove: INPUT_MOVE,
            mouseup: INPUT_END
        };
        var MOUSE_ELEMENT_EVENTS = 'mousedown';
        var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
        /**
 * Mouse events input
 * @constructor
 * @extends Input
 */
        function MouseInput() {
            this.evEl = MOUSE_ELEMENT_EVENTS;
            this.evWin = MOUSE_WINDOW_EVENTS;
            this.pressed = false;
            // mousedown state
            Input.apply(this, arguments);
        }
        inherit(MouseInput, Input, {
            /**
     * handle mouse events
     * @param {Object} ev
     */
            handler: function MEhandler(ev) {
                var eventType = MOUSE_INPUT_MAP[ev.type];
                // on start we want to have the left mouse button down
                if (eventType & INPUT_START && ev.button === 0) {
                    this.pressed = true;
                }
                if (eventType & INPUT_MOVE && ev.which !== 1) {
                    eventType = INPUT_END;
                }
                // mouse must be down
                if (!this.pressed) {
                    return;
                }
                if (eventType & INPUT_END) {
                    this.pressed = false;
                }
                this.callback(this.manager, eventType, {
                    pointers: [ev],
                    changedPointers: [ev],
                    pointerType: INPUT_TYPE_MOUSE,
                    srcEvent: ev
                });
            }
        });
        var POINTER_INPUT_MAP = {
            pointerdown: INPUT_START,
            pointermove: INPUT_MOVE,
            pointerup: INPUT_END,
            pointercancel: INPUT_CANCEL,
            pointerout: INPUT_CANCEL
        };
        // in IE10 the pointer types is defined as an enum
        var IE10_POINTER_TYPE_ENUM = {
            2: INPUT_TYPE_TOUCH,
            3: INPUT_TYPE_PEN,
            4: INPUT_TYPE_MOUSE,
            5: INPUT_TYPE_KINECT    // see https://twitter.com/jacobrossi/status/480596438489890816
        };
        var POINTER_ELEMENT_EVENTS = 'pointerdown';
        var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
        // IE10 has prefixed support, and case-sensitive
        if (window.MSPointerEvent && !window.PointerEvent) {
            POINTER_ELEMENT_EVENTS = 'MSPointerDown';
            POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
        }
        /**
 * Pointer events input
 * @constructor
 * @extends Input
 */
        function PointerEventInput() {
            this.evEl = POINTER_ELEMENT_EVENTS;
            this.evWin = POINTER_WINDOW_EVENTS;
            Input.apply(this, arguments);
            this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput, Input, {
            /**
     * handle mouse events
     * @param {Object} ev
     */
            handler: function PEhandler(ev) {
                var store = this.store;
                var removePointer = false;
                var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                var isTouch = pointerType == INPUT_TYPE_TOUCH;
                // get index of the event in the store
                var storeIndex = inArray(store, ev.pointerId, 'pointerId');
                // start and mouse must be down
                if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                    if (storeIndex < 0) {
                        store.push(ev);
                        storeIndex = store.length - 1;
                    }
                } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                    removePointer = true;
                }
                // it not found, so the pointer hasn't been down (so it's probably a hover)
                if (storeIndex < 0) {
                    return;
                }
                // update the event in the store
                store[storeIndex] = ev;
                this.callback(this.manager, eventType, {
                    pointers: store,
                    changedPointers: [ev],
                    pointerType: pointerType,
                    srcEvent: ev
                });
                if (removePointer) {
                    // remove from the store
                    store.splice(storeIndex, 1);
                }
            }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
            touchstart: INPUT_START,
            touchmove: INPUT_MOVE,
            touchend: INPUT_END,
            touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
        var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
        /**
 * Touch events input
 * @constructor
 * @extends Input
 */
        function SingleTouchInput() {
            this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
            this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
            this.started = false;
            Input.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input, {
            handler: function TEhandler(ev) {
                var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                // should we handle the touch events?
                if (type === INPUT_START) {
                    this.started = true;
                }
                if (!this.started) {
                    return;
                }
                var touches = normalizeSingleTouches.call(this, ev, type);
                // when done, reset the started state
                if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                    this.started = false;
                }
                this.callback(this.manager, type, {
                    pointers: touches[0],
                    changedPointers: touches[1],
                    pointerType: INPUT_TYPE_TOUCH,
                    srcEvent: ev
                });
            }
        });
        /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
        function normalizeSingleTouches(ev, type) {
            var all = toArray(ev.touches);
            var changed = toArray(ev.changedTouches);
            if (type & (INPUT_END | INPUT_CANCEL)) {
                all = uniqueArray(all.concat(changed), 'identifier', true);
            }
            return [
                all,
                changed
            ];
        }
        var TOUCH_INPUT_MAP = {
            touchstart: INPUT_START,
            touchmove: INPUT_MOVE,
            touchend: INPUT_END,
            touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
        /**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
        function TouchInput() {
            this.evTarget = TOUCH_TARGET_EVENTS;
            this.targetIds = {};
            Input.apply(this, arguments);
        }
        inherit(TouchInput, Input, {
            handler: function MTEhandler(ev) {
                var type = TOUCH_INPUT_MAP[ev.type];
                var touches = getTouches.call(this, ev, type);
                if (!touches) {
                    return;
                }
                this.callback(this.manager, type, {
                    pointers: touches[0],
                    changedPointers: touches[1],
                    pointerType: INPUT_TYPE_TOUCH,
                    srcEvent: ev
                });
            }
        });
        /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
        function getTouches(ev, type) {
            var allTouches = toArray(ev.touches);
            var targetIds = this.targetIds;
            // when there is only one touch, the process can be simplified
            if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
                targetIds[allTouches[0].identifier] = true;
                return [
                    allTouches,
                    allTouches
                ];
            }
            var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
            // get target touches from touches
            targetTouches = allTouches.filter(function (touch) {
                return hasParent(touch.target, target);
            });
            // collect touches
            if (type === INPUT_START) {
                i = 0;
                while (i < targetTouches.length) {
                    targetIds[targetTouches[i].identifier] = true;
                    i++;
                }
            }
            // filter changed touches to only contain touches that exist in the collected target ids
            i = 0;
            while (i < changedTouches.length) {
                if (targetIds[changedTouches[i].identifier]) {
                    changedTargetTouches.push(changedTouches[i]);
                }
                // cleanup removed touches
                if (type & (INPUT_END | INPUT_CANCEL)) {
                    delete targetIds[changedTouches[i].identifier];
                }
                i++;
            }
            if (!changedTargetTouches.length) {
                return;
            }
            return [
                // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
                uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
                changedTargetTouches
            ];
        }
        /**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
            Input.apply(this, arguments);
            var handler = bindFn(this.handler, this);
            this.touch = new TouchInput(this.manager, handler);
            this.mouse = new MouseInput(this.manager, handler);
            this.primaryTouch = null;
            this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input, {
            /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
            handler: function TMEhandler(manager, inputEvent, inputData) {
                var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                    return;
                }
                // when we're in a touch event, record touches to  de-dupe synthetic mouse event
                if (isTouch) {
                    recordTouches.call(this, inputEvent, inputData);
                } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                    return;
                }
                this.callback(manager, inputEvent, inputData);
            },
            /**
     * remove the event listeners
     */
            destroy: function destroy() {
                this.touch.destroy();
                this.mouse.destroy();
            }
        });
        function recordTouches(eventType, eventData) {
            if (eventType & INPUT_START) {
                this.primaryTouch = eventData.changedPointers[0].identifier;
                setLastTouch.call(this, eventData);
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                setLastTouch.call(this, eventData);
            }
        }
        function setLastTouch(eventData) {
            var touch = eventData.changedPointers[0];
            if (touch.identifier === this.primaryTouch) {
                var lastTouch = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                this.lastTouches.push(lastTouch);
                var lts = this.lastTouches;
                var removeLastTouch = function () {
                    var i = lts.indexOf(lastTouch);
                    if (i > -1) {
                        lts.splice(i, 1);
                    }
                };
                setTimeout(removeLastTouch, DEDUP_TIMEOUT);
            }
        }
        function isSyntheticEvent(eventData) {
            var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
            for (var i = 0; i < this.lastTouches.length; i++) {
                var t = this.lastTouches[i];
                var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
                if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                    return true;
                }
            }
            return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
        // magical touchAction value
        var TOUCH_ACTION_COMPUTE = 'compute';
        var TOUCH_ACTION_AUTO = 'auto';
        var TOUCH_ACTION_MANIPULATION = 'manipulation';
        // not implemented
        var TOUCH_ACTION_NONE = 'none';
        var TOUCH_ACTION_PAN_X = 'pan-x';
        var TOUCH_ACTION_PAN_Y = 'pan-y';
        var TOUCH_ACTION_MAP = getTouchActionProps();
        /**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
        function TouchAction(manager, value) {
            this.manager = manager;
            this.set(value);
        }
        TouchAction.prototype = {
            /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
            set: function (value) {
                // find out the touch-action by the event handlers
                if (value == TOUCH_ACTION_COMPUTE) {
                    value = this.compute();
                }
                if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                    this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                }
                this.actions = value.toLowerCase().trim();
            },
            /**
     * just re-set the touchAction value
     */
            update: function () {
                this.set(this.manager.options.touchAction);
            },
            /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
            compute: function () {
                var actions = [];
                each(this.manager.recognizers, function (recognizer) {
                    if (boolOrFn(recognizer.options.enable, [recognizer])) {
                        actions = actions.concat(recognizer.getTouchAction());
                    }
                });
                return cleanTouchActions(actions.join(' '));
            },
            /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
            preventDefaults: function (input) {
                var srcEvent = input.srcEvent;
                var direction = input.offsetDirection;
                // if the touch action did prevented once this session
                if (this.manager.session.prevented) {
                    srcEvent.preventDefault();
                    return;
                }
                var actions = this.actions;
                var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
                if (hasNone) {
                    //do not prevent defaults if this is a tap gesture
                    var isTapPointer = input.pointers.length === 1;
                    var isTapMovement = input.distance < 2;
                    var isTapTouchTime = input.deltaTime < 250;
                    if (isTapPointer && isTapMovement && isTapTouchTime) {
                        return;
                    }
                }
                if (hasPanX && hasPanY) {
                    // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                    return;
                }
                if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                    return this.preventSrc(srcEvent);
                }
            },
            /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
            preventSrc: function (srcEvent) {
                this.manager.session.prevented = true;
                srcEvent.preventDefault();
            }
        };
        /**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
        function cleanTouchActions(actions) {
            // none
            if (inStr(actions, TOUCH_ACTION_NONE)) {
                return TOUCH_ACTION_NONE;
            }
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
            // if both pan-x and pan-y are set (different recognizers
            // for different directions, e.g. horizontal pan but vertical swipe?)
            // we need none (as otherwise with pan-x pan-y combined none of these
            // recognizers will work, since the browser would handle all panning
            if (hasPanX && hasPanY) {
                return TOUCH_ACTION_NONE;
            }
            // pan-x OR pan-y
            if (hasPanX || hasPanY) {
                return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
            }
            // manipulation
            if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
                return TOUCH_ACTION_MANIPULATION;
            }
            return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
            if (!NATIVE_TOUCH_ACTION) {
                return false;
            }
            var touchMap = {};
            var cssSupports = window.CSS && window.CSS.supports;
            [
                'auto',
                'manipulation',
                'pan-y',
                'pan-x',
                'pan-x pan-y',
                'none'
            ].forEach(function (val) {
                // If css.supports is not supported but there is native touch-action assume it supports
                // all values. This is the case for IE 10 and 11.
                touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
            });
            return touchMap;
        }
        /**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        /**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
        function Recognizer(options) {
            this.options = assign({}, this.defaults, options || {});
            this.id = uniqueId();
            this.manager = null;
            // default is enable true
            this.options.enable = ifUndefined(this.options.enable, true);
            this.state = STATE_POSSIBLE;
            this.simultaneous = {};
            this.requireFail = [];
        }
        Recognizer.prototype = {
            /**
     * @virtual
     * @type {Object}
     */
            defaults: {},
            /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
            set: function (options) {
                assign(this.options, options);
                // also update the touchAction, in case something changed about the directions/enabled state
                this.manager && this.manager.touchAction.update();
                return this;
            },
            /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
            recognizeWith: function (otherRecognizer) {
                if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                    return this;
                }
                var simultaneous = this.simultaneous;
                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                if (!simultaneous[otherRecognizer.id]) {
                    simultaneous[otherRecognizer.id] = otherRecognizer;
                    otherRecognizer.recognizeWith(this);
                }
                return this;
            },
            /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
            dropRecognizeWith: function (otherRecognizer) {
                if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                    return this;
                }
                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                delete this.simultaneous[otherRecognizer.id];
                return this;
            },
            /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
            requireFailure: function (otherRecognizer) {
                if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                    return this;
                }
                var requireFail = this.requireFail;
                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                if (inArray(requireFail, otherRecognizer) === -1) {
                    requireFail.push(otherRecognizer);
                    otherRecognizer.requireFailure(this);
                }
                return this;
            },
            /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
            dropRequireFailure: function (otherRecognizer) {
                if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                    return this;
                }
                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                var index = inArray(this.requireFail, otherRecognizer);
                if (index > -1) {
                    this.requireFail.splice(index, 1);
                }
                return this;
            },
            /**
     * has require failures boolean
     * @returns {boolean}
     */
            hasRequireFailures: function () {
                return this.requireFail.length > 0;
            },
            /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
            canRecognizeWith: function (otherRecognizer) {
                return !!this.simultaneous[otherRecognizer.id];
            },
            /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
            emit: function (input) {
                var self = this;
                var state = this.state;
                function emit(event) {
                    self.manager.emit(event, input);
                }
                // 'panstart' and 'panmove'
                if (state < STATE_ENDED) {
                    emit(self.options.event + stateStr(state));
                }
                emit(self.options.event);
                // simple 'eventName' events
                if (input.additionalEvent) {
                    // additional event(panleft, panright, pinchin, pinchout...)
                    emit(input.additionalEvent);
                }
                // panend and pancancel
                if (state >= STATE_ENDED) {
                    emit(self.options.event + stateStr(state));
                }
            },
            /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
            tryEmit: function (input) {
                if (this.canEmit()) {
                    return this.emit(input);
                }
                // it's failing anyway
                this.state = STATE_FAILED;
            },
            /**
     * can we emit?
     * @returns {boolean}
     */
            canEmit: function () {
                var i = 0;
                while (i < this.requireFail.length) {
                    if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                        return false;
                    }
                    i++;
                }
                return true;
            },
            /**
     * update the recognizer
     * @param {Object} inputData
     */
            recognize: function (inputData) {
                // make a new copy of the inputData
                // so we can change the inputData without messing up the other recognizers
                var inputDataClone = assign({}, inputData);
                // is is enabled and allow recognizing?
                if (!boolOrFn(this.options.enable, [
                        this,
                        inputDataClone
                    ])) {
                    this.reset();
                    this.state = STATE_FAILED;
                    return;
                }
                // reset when we've reached the end
                if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                    this.state = STATE_POSSIBLE;
                }
                this.state = this.process(inputDataClone);
                // the recognizer has recognized a gesture
                // so trigger an event
                if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                    this.tryEmit(inputDataClone);
                }
            },
            /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
            process: function (inputData) {
            },
            // jshint ignore:line
            /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
            getTouchAction: function () {
            },
            /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
            reset: function () {
            }
        };
        /**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
        function stateStr(state) {
            if (state & STATE_CANCELLED) {
                return 'cancel';
            } else if (state & STATE_ENDED) {
                return 'end';
            } else if (state & STATE_CHANGED) {
                return 'move';
            } else if (state & STATE_BEGAN) {
                return 'start';
            }
            return '';
        }
        /**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
        function directionStr(direction) {
            if (direction == DIRECTION_DOWN) {
                return 'down';
            } else if (direction == DIRECTION_UP) {
                return 'up';
            } else if (direction == DIRECTION_LEFT) {
                return 'left';
            } else if (direction == DIRECTION_RIGHT) {
                return 'right';
            }
            return '';
        }
        /**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
            var manager = recognizer.manager;
            if (manager) {
                return manager.get(otherRecognizer);
            }
            return otherRecognizer;
        }
        /**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
        function AttrRecognizer() {
            Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
            /**
     * @namespace
     * @memberof AttrRecognizer
     */
            defaults: {
                /**
         * @type {Number}
         * @default 1
         */
                pointers: 1
            },
            /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
            attrTest: function (input) {
                var optionPointers = this.options.pointers;
                return optionPointers === 0 || input.pointers.length === optionPointers;
            },
            /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
            process: function (input) {
                var state = this.state;
                var eventType = input.eventType;
                var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                var isValid = this.attrTest(input);
                // on cancel input and we've recognized before, return STATE_CANCELLED
                if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                    return state | STATE_CANCELLED;
                } else if (isRecognized || isValid) {
                    if (eventType & INPUT_END) {
                        return state | STATE_ENDED;
                    } else if (!(state & STATE_BEGAN)) {
                        return STATE_BEGAN;
                    }
                    return state | STATE_CHANGED;
                }
                return STATE_FAILED;
            }
        });
        /**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
        function PanRecognizer() {
            AttrRecognizer.apply(this, arguments);
            this.pX = null;
            this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
            /**
     * @namespace
     * @memberof PanRecognizer
     */
            defaults: {
                event: 'pan',
                threshold: 10,
                pointers: 1,
                direction: DIRECTION_ALL
            },
            getTouchAction: function () {
                var direction = this.options.direction;
                var actions = [];
                if (direction & DIRECTION_HORIZONTAL) {
                    actions.push(TOUCH_ACTION_PAN_Y);
                }
                if (direction & DIRECTION_VERTICAL) {
                    actions.push(TOUCH_ACTION_PAN_X);
                }
                return actions;
            },
            directionTest: function (input) {
                var options = this.options;
                var hasMoved = true;
                var distance = input.distance;
                var direction = input.direction;
                var x = input.deltaX;
                var y = input.deltaY;
                // lock to axis?
                if (!(direction & options.direction)) {
                    if (options.direction & DIRECTION_HORIZONTAL) {
                        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                        hasMoved = x != this.pX;
                        distance = Math.abs(input.deltaX);
                    } else {
                        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                        hasMoved = y != this.pY;
                        distance = Math.abs(input.deltaY);
                    }
                }
                input.direction = direction;
                return hasMoved && distance > options.threshold && direction & options.direction;
            },
            attrTest: function (input) {
                return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
            },
            emit: function (input) {
                this.pX = input.deltaX;
                this.pY = input.deltaY;
                var direction = directionStr(input.direction);
                if (direction) {
                    input.additionalEvent = this.options.event + direction;
                }
                this._super.emit.call(this, input);
            }
        });
        /**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
        function PinchRecognizer() {
            AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
            /**
     * @namespace
     * @memberof PinchRecognizer
     */
            defaults: {
                event: 'pinch',
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function () {
                return [TOUCH_ACTION_NONE];
            },
            attrTest: function (input) {
                return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
            },
            emit: function (input) {
                if (input.scale !== 1) {
                    var inOut = input.scale < 1 ? 'in' : 'out';
                    input.additionalEvent = this.options.event + inOut;
                }
                this._super.emit.call(this, input);
            }
        });
        /**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
        function PressRecognizer() {
            Recognizer.apply(this, arguments);
            this._timer = null;
            this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
            /**
     * @namespace
     * @memberof PressRecognizer
     */
            defaults: {
                event: 'press',
                pointers: 1,
                time: 251,
                // minimal time of the pointer to be pressed
                threshold: 9    // a minimal movement is ok, but keep it low
            },
            getTouchAction: function () {
                return [TOUCH_ACTION_AUTO];
            },
            process: function (input) {
                var options = this.options;
                var validPointers = input.pointers.length === options.pointers;
                var validMovement = input.distance < options.threshold;
                var validTime = input.deltaTime > options.time;
                this._input = input;
                // we only allow little movement
                // and we've reached an end event, so a tap is possible
                if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                    this.reset();
                } else if (input.eventType & INPUT_START) {
                    this.reset();
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.time, this);
                } else if (input.eventType & INPUT_END) {
                    return STATE_RECOGNIZED;
                }
                return STATE_FAILED;
            },
            reset: function () {
                clearTimeout(this._timer);
            },
            emit: function (input) {
                if (this.state !== STATE_RECOGNIZED) {
                    return;
                }
                if (input && input.eventType & INPUT_END) {
                    this.manager.emit(this.options.event + 'up', input);
                } else {
                    this._input.timeStamp = now();
                    this.manager.emit(this.options.event, this._input);
                }
            }
        });
        /**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
        function RotateRecognizer() {
            AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
            /**
     * @namespace
     * @memberof RotateRecognizer
     */
            defaults: {
                event: 'rotate',
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function () {
                return [TOUCH_ACTION_NONE];
            },
            attrTest: function (input) {
                return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
            }
        });
        /**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
        function SwipeRecognizer() {
            AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
            /**
     * @namespace
     * @memberof SwipeRecognizer
     */
            defaults: {
                event: 'swipe',
                threshold: 10,
                velocity: 0.3,
                direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                pointers: 1
            },
            getTouchAction: function () {
                return PanRecognizer.prototype.getTouchAction.call(this);
            },
            attrTest: function (input) {
                var direction = this.options.direction;
                var velocity;
                if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                    velocity = input.overallVelocity;
                } else if (direction & DIRECTION_HORIZONTAL) {
                    velocity = input.overallVelocityX;
                } else if (direction & DIRECTION_VERTICAL) {
                    velocity = input.overallVelocityY;
                }
                return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
            },
            emit: function (input) {
                var direction = directionStr(input.offsetDirection);
                if (direction) {
                    this.manager.emit(this.options.event + direction, input);
                }
                this.manager.emit(this.options.event, input);
            }
        });
        /**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
        function TapRecognizer() {
            Recognizer.apply(this, arguments);
            // previous time and center,
            // used for tap counting
            this.pTime = false;
            this.pCenter = false;
            this._timer = null;
            this._input = null;
            this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
            /**
     * @namespace
     * @memberof PinchRecognizer
     */
            defaults: {
                event: 'tap',
                pointers: 1,
                taps: 1,
                interval: 300,
                // max time between the multi-tap taps
                time: 250,
                // max time of the pointer to be down (like finger on the screen)
                threshold: 9,
                // a minimal movement is ok, but keep it low
                posThreshold: 10    // a multi-tap can be a bit off the initial position
            },
            getTouchAction: function () {
                return [TOUCH_ACTION_MANIPULATION];
            },
            process: function (input) {
                var options = this.options;
                var validPointers = input.pointers.length === options.pointers;
                var validMovement = input.distance < options.threshold;
                var validTouchTime = input.deltaTime < options.time;
                this.reset();
                if (input.eventType & INPUT_START && this.count === 0) {
                    return this.failTimeout();
                }
                // we only allow little movement
                // and we've reached an end event, so a tap is possible
                if (validMovement && validTouchTime && validPointers) {
                    if (input.eventType != INPUT_END) {
                        return this.failTimeout();
                    }
                    var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                    var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                    this.pTime = input.timeStamp;
                    this.pCenter = input.center;
                    if (!validMultiTap || !validInterval) {
                        this.count = 1;
                    } else {
                        this.count += 1;
                    }
                    this._input = input;
                    // if tap count matches we have recognized it,
                    // else it has began recognizing...
                    var tapCount = this.count % options.taps;
                    if (tapCount === 0) {
                        // no failing requirements, immediately trigger the tap event
                        // or wait as long as the multitap interval to trigger
                        if (!this.hasRequireFailures()) {
                            return STATE_RECOGNIZED;
                        } else {
                            this._timer = setTimeoutContext(function () {
                                this.state = STATE_RECOGNIZED;
                                this.tryEmit();
                            }, options.interval, this);
                            return STATE_BEGAN;
                        }
                    }
                }
                return STATE_FAILED;
            },
            failTimeout: function () {
                this._timer = setTimeoutContext(function () {
                    this.state = STATE_FAILED;
                }, this.options.interval, this);
                return STATE_FAILED;
            },
            reset: function () {
                clearTimeout(this._timer);
            },
            emit: function () {
                if (this.state == STATE_RECOGNIZED) {
                    this._input.tapCount = this.count;
                    this.manager.emit(this.options.event, this._input);
                }
            }
        });
        /**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
        function Hammer(element, options) {
            options = options || {};
            options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
            return new Manager(element, options);
        }
        /**
 * @const {string}
 */
        Hammer.VERSION = '2.0.7';
        /**
 * default settings
 * @namespace
 */
        Hammer.defaults = {
            /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
            domEvents: false,
            /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
            touchAction: TOUCH_ACTION_COMPUTE,
            /**
     * @type {Boolean}
     * @default true
     */
            enable: true,
            /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
            inputTarget: null,
            /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
            inputClass: null,
            /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
            preset: [
                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                [
                    RotateRecognizer,
                    { enable: false }
                ],
                [
                    PinchRecognizer,
                    { enable: false },
                    ['rotate']
                ],
                [
                    SwipeRecognizer,
                    { direction: DIRECTION_HORIZONTAL }
                ],
                [
                    PanRecognizer,
                    { direction: DIRECTION_HORIZONTAL },
                    ['swipe']
                ],
                [TapRecognizer],
                [
                    TapRecognizer,
                    {
                        event: 'doubletap',
                        taps: 2
                    },
                    ['tap']
                ],
                [PressRecognizer]
            ],
            /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
            cssProps: {
                /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
                userSelect: 'none',
                /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
                touchSelect: 'none',
                /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
                touchCallout: 'none',
                /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
                contentZooming: 'none',
                /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
                userDrag: 'none',
                /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
                tapHighlightColor: 'rgba(0,0,0,0)'
            }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        /**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
        function Manager(element, options) {
            this.options = assign({}, Hammer.defaults, options || {});
            this.options.inputTarget = this.options.inputTarget || element;
            this.handlers = {};
            this.session = {};
            this.recognizers = [];
            this.oldCssProps = {};
            this.element = element;
            this.input = createInputInstance(this);
            this.touchAction = new TouchAction(this, this.options.touchAction);
            toggleCssProps(this, true);
            each(this.options.recognizers, function (item) {
                var recognizer = this.add(new item[0](item[1]));
                item[2] && recognizer.recognizeWith(item[2]);
                item[3] && recognizer.requireFailure(item[3]);
            }, this);
        }
        Manager.prototype = {
            /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
            set: function (options) {
                assign(this.options, options);
                // Options that need a little more setup
                if (options.touchAction) {
                    this.touchAction.update();
                }
                if (options.inputTarget) {
                    // Clean up existing event listeners and reinitialize
                    this.input.destroy();
                    this.input.target = options.inputTarget;
                    this.input.init();
                }
                return this;
            },
            /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
            stop: function (force) {
                this.session.stopped = force ? FORCED_STOP : STOP;
            },
            /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
            recognize: function (inputData) {
                var session = this.session;
                if (session.stopped) {
                    return;
                }
                // run the touch-action polyfill
                this.touchAction.preventDefaults(inputData);
                var recognizer;
                var recognizers = this.recognizers;
                // this holds the recognizer that is being recognized.
                // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                // if no recognizer is detecting a thing, it is set to `null`
                var curRecognizer = session.curRecognizer;
                // reset when the last recognizer is recognized
                // or when we're in a new session
                if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                    curRecognizer = session.curRecognizer = null;
                }
                var i = 0;
                while (i < recognizers.length) {
                    recognizer = recognizers[i];
                    // find out if we are allowed try to recognize the input for this one.
                    // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                    // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                    //      that is being recognized.
                    // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                    //      this can be setup with the `recognizeWith()` method on the recognizer.
                    if (session.stopped !== FORCED_STOP && // 1
                        (!curRecognizer || recognizer == curRecognizer || // 2
                        recognizer.canRecognizeWith(curRecognizer))) {
                        // 3
                        recognizer.recognize(inputData);
                    } else {
                        recognizer.reset();
                    }
                    // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                    // current active recognizer. but only if we don't already have an active recognizer
                    if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                        curRecognizer = session.curRecognizer = recognizer;
                    }
                    i++;
                }
            },
            /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
            get: function (recognizer) {
                if (recognizer instanceof Recognizer) {
                    return recognizer;
                }
                var recognizers = this.recognizers;
                for (var i = 0; i < recognizers.length; i++) {
                    if (recognizers[i].options.event == recognizer) {
                        return recognizers[i];
                    }
                }
                return null;
            },
            /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
            add: function (recognizer) {
                if (invokeArrayArg(recognizer, 'add', this)) {
                    return this;
                }
                // remove existing
                var existing = this.get(recognizer.options.event);
                if (existing) {
                    this.remove(existing);
                }
                this.recognizers.push(recognizer);
                recognizer.manager = this;
                this.touchAction.update();
                return recognizer;
            },
            /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
            remove: function (recognizer) {
                if (invokeArrayArg(recognizer, 'remove', this)) {
                    return this;
                }
                recognizer = this.get(recognizer);
                // let's make sure this recognizer exists
                if (recognizer) {
                    var recognizers = this.recognizers;
                    var index = inArray(recognizers, recognizer);
                    if (index !== -1) {
                        recognizers.splice(index, 1);
                        this.touchAction.update();
                    }
                }
                return this;
            },
            /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
            on: function (events, handler) {
                if (events === undefined) {
                    return;
                }
                if (handler === undefined) {
                    return;
                }
                var handlers = this.handlers;
                each(splitStr(events), function (event) {
                    handlers[event] = handlers[event] || [];
                    handlers[event].push(handler);
                });
                return this;
            },
            /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
            off: function (events, handler) {
                if (events === undefined) {
                    return;
                }
                var handlers = this.handlers;
                each(splitStr(events), function (event) {
                    if (!handler) {
                        delete handlers[event];
                    } else {
                        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                    }
                });
                return this;
            },
            /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
            emit: function (event, data) {
                // we also want to trigger dom events
                if (this.options.domEvents) {
                    triggerDomEvent(event, data);
                }
                // no handlers, so skip it all
                var handlers = this.handlers[event] && this.handlers[event].slice();
                if (!handlers || !handlers.length) {
                    return;
                }
                data.type = event;
                data.preventDefault = function () {
                    data.srcEvent.preventDefault();
                };
                var i = 0;
                while (i < handlers.length) {
                    handlers[i](data);
                    i++;
                }
            },
            /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
            destroy: function () {
                this.element && toggleCssProps(this, false);
                this.handlers = {};
                this.session = {};
                this.input.destroy();
                this.element = null;
            }
        };
        /**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
        function toggleCssProps(manager, add) {
            var element = manager.element;
            if (!element.style) {
                return;
            }
            var prop;
            each(manager.options.cssProps, function (value, name) {
                prop = prefixed(element.style, name);
                if (add) {
                    manager.oldCssProps[prop] = element.style[prop];
                    element.style[prop] = value;
                } else {
                    element.style[prop] = manager.oldCssProps[prop] || '';
                }
            });
            if (!add) {
                manager.oldCssProps = {};
            }
        }
        /**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
        function triggerDomEvent(event, data) {
            var gestureEvent = document.createEvent('Event');
            gestureEvent.initEvent(event, true, true);
            gestureEvent.gesture = data;
            data.target.dispatchEvent(gestureEvent);
        }
        assign(Hammer, {
            INPUT_START: INPUT_START,
            INPUT_MOVE: INPUT_MOVE,
            INPUT_END: INPUT_END,
            INPUT_CANCEL: INPUT_CANCEL,
            STATE_POSSIBLE: STATE_POSSIBLE,
            STATE_BEGAN: STATE_BEGAN,
            STATE_CHANGED: STATE_CHANGED,
            STATE_ENDED: STATE_ENDED,
            STATE_RECOGNIZED: STATE_RECOGNIZED,
            STATE_CANCELLED: STATE_CANCELLED,
            STATE_FAILED: STATE_FAILED,
            DIRECTION_NONE: DIRECTION_NONE,
            DIRECTION_LEFT: DIRECTION_LEFT,
            DIRECTION_RIGHT: DIRECTION_RIGHT,
            DIRECTION_UP: DIRECTION_UP,
            DIRECTION_DOWN: DIRECTION_DOWN,
            DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
            DIRECTION_VERTICAL: DIRECTION_VERTICAL,
            DIRECTION_ALL: DIRECTION_ALL,
            Manager: Manager,
            Input: Input,
            TouchAction: TouchAction,
            TouchInput: TouchInput,
            MouseInput: MouseInput,
            PointerEventInput: PointerEventInput,
            TouchMouseInput: TouchMouseInput,
            SingleTouchInput: SingleTouchInput,
            Recognizer: Recognizer,
            AttrRecognizer: AttrRecognizer,
            Tap: TapRecognizer,
            Pan: PanRecognizer,
            Swipe: SwipeRecognizer,
            Pinch: PinchRecognizer,
            Rotate: RotateRecognizer,
            Press: PressRecognizer,
            on: addEventListeners,
            off: removeEventListeners,
            each: each,
            merge: merge,
            extend: extend,
            assign: assign,
            inherit: inherit,
            bindFn: bindFn,
            prefixed: prefixed
        });
        // this prevents errors when Hammer is loaded in the presence of an AMD
        //  style loader but by script tag, not by the loader.
        var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {};
        // jshint ignore:line
        freeGlobal.Hammer = Hammer;
        if (typeof define === 'function' && define.amd) {
            define(function () {
                return Hammer;
            });
        } else if (typeof module != 'undefined' && module.exports) {
            module.exports = Hammer;
        } else {
            window[exportName] = Hammer;
        }
    }(window, document, 'Hammer'));
},
/*kiwi/build/constraint*/
function _(require, module, exports) {
    var strength_1 = require(324    /* ./strength */);
    /**
 * An enum defining the linear constraint operators.
 */
    var Operator;
    (function (Operator) {
        Operator[Operator['Le'] = 0] = 'Le';
        Operator[Operator['Ge'] = 1] = 'Ge';
        Operator[Operator['Eq'] = 2] = 'Eq';    // ==
    }(Operator = exports.Operator || (exports.Operator = {})));
    /**
 * A linear constraint equation.
 *
 * A constraint equation is composed of an expression, an operator,
 * and a strength. The RHS of the equation is implicitly zero.
 *
 * @class
 */
    var Constraint = function () {
        /**
     * Construct a new Constraint.
     *
     * @param expression The constraint expression.
     * @param operator The equation operator.
     * @param strength The strength of the constraint.
     */
        function Constraint(expression, operator, strength) {
            if (strength === void 0) {
                strength = strength_1.Strength.required;
            }
            this._id = CnId++;
            this._operator = operator;
            this._expression = expression;
            this._strength = strength_1.Strength.clip(strength);
        }
        /**
     * A static constraint comparison function.
     */
        Constraint.Compare = function (a, b) {
            return a.id - b.id;
        };
        Constraint.prototype.toString = function () {
            var _this = this;
            var op = function () {
                switch (_this._operator) {
                case Operator.Le:
                    return '<=';
                case Operator.Ge:
                    return '>=';
                case Operator.Eq:
                    return '==';
                }
            };
            return this._expression + ' ' + op() + ' 0';
        };
        Object.defineProperty(Constraint.prototype, 'id', {
            /**
         * Returns the unique id number of the constraint.
         */
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Constraint.prototype, 'expression', {
            /**
         * Returns the expression of the constraint.
         */
            get: function () {
                return this._expression;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Constraint.prototype, 'op', {
            /**
         * Returns the relational operator of the constraint.
         */
            get: function () {
                return this._operator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Constraint.prototype, 'strength', {
            /**
         * Returns the strength of the constraint.
         */
            get: function () {
                return this._strength;
            },
            enumerable: true,
            configurable: true
        });
        return Constraint;
    }();
    exports.Constraint = Constraint;
    /**
 * The internal constraint id counter.
 */
    var CnId = 0;
},
/*kiwi/build/expression*/
function _(require, module, exports) {
    var tsu_1 = require(328    /* ./tsu */);
    var variable_1 = require(331    /* ./variable */);
    var maptype_1 = require(322    /* ./maptype */);
    /**
 * An expression of variable terms and a constant.
 *
 * @class
 */
    var Expression = function () {
        function Expression() {
            var parsed = parseArgs(arguments);
            this._terms = parsed.terms;
            this._constant = parsed.constant;
        }
        Expression.prototype.toString = function () {
            var terms = [];
            tsu_1.forEach(this._terms, function (pair) {
                terms.push([
                    pair.first,
                    pair.second
                ]);
            });
            var first = true;
            var s = '';
            for (var _i = 0, terms_1 = terms; _i < terms_1.length; _i++) {
                var _a = terms_1[_i], v = _a[0], c_1 = _a[1];
                if (first) {
                    first = false;
                    if (c_1 == 1)
                        s += '' + v;
                    else if (c_1 == -1)
                        s += '-' + v;
                    else
                        s += c_1 + '*' + v;
                } else {
                    if (c_1 == 1)
                        s += ' + ' + v;
                    else if (c_1 == -1)
                        s += ' - ' + v;
                    else if (c_1 >= 0)
                        s += ' + ' + c_1 + v;
                    else
                        s += ' - ' + -c_1 + v;
                }
            }
            var c = this.constant;
            if (c < 0)
                s += ' - ' + -c;
            else if (c > 0)
                s += ' + ' + c;
            return s;
        };
        Object.defineProperty(Expression.prototype, 'terms', {
            /**
         * Returns the mapping of terms in the expression.
         *
         * This *must* be treated as const.
         */
            get: function () {
                return this._terms;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Expression.prototype, 'constant', {
            /**
         * Returns the constant of the expression.
         */
            get: function () {
                return this._constant;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Expression.prototype, 'value', {
            /**
         * Returns the computed value of the expression.
         */
            get: function () {
                var result = this._constant;
                tsu_1.forEach(this._terms, function (pair) {
                    result += pair.first.value * pair.second;
                });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        return Expression;
    }();
    exports.Expression = Expression;
    /**
 * An internal argument parsing function.
 */
    function parseArgs(args) {
        var constant = 0;
        var factory = function () {
            return 0;
        };
        var terms = maptype_1.createMap(variable_1.Variable.Compare);
        for (var i = 0, n = args.length; i < n; ++i) {
            var item = args[i];
            if (typeof item === 'number') {
                constant += item;
            } else if (item instanceof variable_1.Variable) {
                terms.setDefault(item, factory).second += 1;
            } else if (item instanceof Array) {
                if (item.length !== 2) {
                    throw new Error('array must have length 2');
                }
                var value = item[0];
                var variable = item[1];
                if (typeof value !== 'number') {
                    throw new Error('array item 0 must be a number');
                }
                if (!(variable instanceof variable_1.Variable)) {
                    throw new Error('array item 1 must be a variable');
                }
                terms.setDefault(variable, factory).second += value;
            } else {
                throw new Error('invalid Expression argument: ' + JSON.stringify(item));
            }
        }
        return {
            terms: terms,
            constant: constant
        };
    }
},
/*kiwi/build/index*/
function _(require, module, exports) {
    /*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
    function __export(m) {
        for (var p in m)
            if (!exports.hasOwnProperty(p))
                exports[p] = m[p];
    }
    __export(require(331    /* ./variable */));
    __export(require(320    /* ./expression */));
    __export(require(319    /* ./constraint */));
    __export(require(324    /* ./strength */));
    __export(require(323    /* ./solver */));
},
/*kiwi/build/maptype*/
function _(require, module, exports) {
    var tsu_1 = require(328    /* ./tsu */);
    function createMap(compare) {
        return new tsu_1.AssociativeArray(compare);
    }
    exports.createMap = createMap;
},
/*kiwi/build/solver*/
function _(require, module, exports) {
    var variable_1 = require(331    /* ./variable */);
    var expression_1 = require(320    /* ./expression */);
    var constraint_1 = require(319    /* ./constraint */);
    var strength_1 = require(324    /* ./strength */);
    var maptype_1 = require(322    /* ./maptype */);
    var tsu_1 = require(328    /* ./tsu */);
    /**
 * The constraint solver class.
 *
 * @class
 */
    var Solver = function () {
        /**
     * Construct a new Solver.
     */
        function Solver() {
            this._cnMap = createCnMap();
            this._rowMap = createRowMap();
            this._varMap = createVarMap();
            this._editMap = createEditMap();
            this._infeasibleRows = [];
            this._objective = new Row();
            this._artificial = null;
            this._idTick = 0;
        }
        /**
     * Add a constraint to the solver.
     */
        Solver.prototype.addConstraint = function (constraint) {
            var cnPair = this._cnMap.find(constraint);
            if (cnPair !== undefined) {
                throw new Error('duplicate constraint');
            }
            // Creating a row causes symbols to be reserved for the variables
            // in the constraint. If this method exits with an exception,
            // then its possible those variables will linger in the var map.
            // Since its likely that those variables will be used in other
            // constraints and since exceptional conditions are uncommon,
            // i'm not too worried about aggressive cleanup of the var map.
            var data = this._createRow(constraint);
            var row = data.row;
            var tag = data.tag;
            var subject = this._chooseSubject(row, tag);
            // If chooseSubject couldnt find a valid entering symbol, one
            // last option is available if the entire row is composed of
            // dummy variables. If the constant of the row is zero, then
            // this represents redundant constraints and the new dummy
            // marker can enter the basis. If the constant is non-zero,
            // then it represents an unsatisfiable constraint.
            if (subject.type() === SymbolType.Invalid && row.allDummies()) {
                if (!nearZero(row.constant())) {
                    var names = [];
                    for (var _i = 0, _a = constraint.expression.terms._array; _i < _a.length; _i++) {
                        var item = _a[_i];
                        names.push(item.first.name);
                    }
                    var op = [
                        'LE',
                        'GE',
                        'EQ'
                    ][constraint.op];
                    throw new Error('unsatisfiable constraint [' + names.join(',') + '] operator: ' + op);
                } else {
                    subject = tag.marker;
                }
            }
            // If an entering symbol still isn't found, then the row must
            // be added using an artificial variable. If that fails, then
            // the row represents an unsatisfiable constraint.
            if (subject.type() === SymbolType.Invalid) {
                if (!this._addWithArtificialVariable(row)) {
                    throw new Error('unsatisfiable constraint');
                }
            } else {
                row.solveFor(subject);
                this._substitute(subject, row);
                this._rowMap.insert(subject, row);
            }
            this._cnMap.insert(constraint, tag);
            // Optimizing after each constraint is added performs less
            // aggregate work due to a smaller average system size. It
            // also ensures the solver remains in a consistent state.
            this._optimize(this._objective);
        };
        /**
     * Remove a constraint from the solver.
     */
        Solver.prototype.removeConstraint = function (constraint, silent) {
            if (silent === void 0) {
                silent = false;
            }
            var cnPair = this._cnMap.erase(constraint);
            if (cnPair === undefined) {
                if (silent)
                    return;
                else
                    throw new Error('unknown constraint');
            }
            // Remove the error effects from the objective function
            // *before* pivoting, or substitutions into the objective
            // will lead to incorrect solver results.
            this._removeConstraintEffects(constraint, cnPair.second);
            // If the marker is basic, simply drop the row. Otherwise,
            // pivot the marker into the basis and then drop the row.
            var marker = cnPair.second.marker;
            var rowPair = this._rowMap.erase(marker);
            if (rowPair === undefined) {
                var leaving = this._getMarkerLeavingSymbol(marker);
                if (leaving.type() === SymbolType.Invalid) {
                    throw new Error('failed to find leaving row');
                }
                rowPair = this._rowMap.erase(leaving);
                rowPair.second.solveForEx(leaving, marker);
                this._substitute(marker, rowPair.second);
            }
            // Optimizing after each constraint is removed ensures that the
            // solver remains consistent. It makes the solver api easier to
            // use at a small tradeoff for speed.
            this._optimize(this._objective);
        };
        /**
     * Test whether the solver contains the constraint.
     */
        Solver.prototype.hasConstraint = function (constraint) {
            return this._cnMap.contains(constraint);
        };
        /**
     * Add an edit variable to the solver.
     */
        Solver.prototype.addEditVariable = function (variable, strength) {
            var editPair = this._editMap.find(variable);
            if (editPair !== undefined) {
                throw new Error('duplicate edit variable: ' + variable.name);
            }
            strength = strength_1.Strength.clip(strength);
            if (strength === strength_1.Strength.required) {
                throw new Error('bad required strength');
            }
            var expr = new expression_1.Expression(variable);
            var cn = new constraint_1.Constraint(expr, constraint_1.Operator.Eq, strength);
            this.addConstraint(cn);
            var tag = this._cnMap.find(cn).second;
            var info = {
                tag: tag,
                constraint: cn,
                constant: 0
            };
            this._editMap.insert(variable, info);
        };
        /**
     * Remove an edit variable from the solver.
     */
        Solver.prototype.removeEditVariable = function (variable, silent) {
            if (silent === void 0) {
                silent = false;
            }
            var editPair = this._editMap.erase(variable);
            if (editPair === undefined) {
                if (silent)
                    return;
                else
                    throw new Error('unknown edit variable: ' + variable.name);
            }
            this.removeConstraint(editPair.second.constraint, silent);
        };
        /**
     * Test whether the solver contains the edit variable.
     */
        Solver.prototype.hasEditVariable = function (variable) {
            return this._editMap.contains(variable);
        };
        /**
     * Suggest the value of an edit variable.
     */
        Solver.prototype.suggestValue = function (variable, value) {
            var editPair = this._editMap.find(variable);
            if (editPair === undefined) {
                throw new Error('unknown edit variable: ' + variable.name);
            }
            var rows = this._rowMap;
            var info = editPair.second;
            var delta = value - info.constant;
            info.constant = value;
            // Check first if the positive error variable is basic.
            var marker = info.tag.marker;
            var rowPair = rows.find(marker);
            if (rowPair !== undefined) {
                if (rowPair.second.add(-delta) < 0) {
                    this._infeasibleRows.push(marker);
                }
                this._dualOptimize();
                return;
            }
            // Check next if the negative error variable is basic.
            var other = info.tag.other;
            rowPair = rows.find(other);
            if (rowPair !== undefined) {
                if (rowPair.second.add(delta) < 0) {
                    this._infeasibleRows.push(other);
                }
                this._dualOptimize();
                return;
            }
            // Otherwise update each row where the error variables exist.
            for (var i = 0, n = rows.size(); i < n; ++i) {
                var rowPair_1 = rows.itemAt(i);
                var row = rowPair_1.second;
                var coeff = row.coefficientFor(marker);
                if (coeff !== 0 && row.add(delta * coeff) < 0 && rowPair_1.first.type() !== SymbolType.External) {
                    this._infeasibleRows.push(rowPair_1.first);
                }
            }
            this._dualOptimize();
        };
        /**
     * Update the values of the variables.
     */
        Solver.prototype.updateVariables = function () {
            var vars = this._varMap;
            var rows = this._rowMap;
            for (var i = 0, n = vars.size(); i < n; ++i) {
                var pair = vars.itemAt(i);
                var rowPair = rows.find(pair.second);
                var c = 0;
                if (rowPair !== undefined) {
                    c = rowPair.second.constant();
                    // Normalize -0 to 0. Note that c === -0 is the same as c === 0, so we set c to zero
                    // for both kinds of zeros. One would preferably use Object.is(c, -0), but that's not
                    // widely supported yet.
                    if (c === -0)
                        c = 0;
                }
                pair.first.setValue(c);
            }
        };
        Solver.prototype.getConstraints = function () {
            var constraints = [];
            tsu_1.forEach(this._cnMap, function (pair) {
                constraints.push(pair.first);
            });
            return constraints;
        };
        Object.defineProperty(Solver.prototype, 'numConstraints', {
            get: function () {
                return this._cnMap.size();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Solver.prototype, 'numEditVariables', {
            get: function () {
                return this._editMap.size();
            },
            enumerable: true,
            configurable: true
        });
        /**
     * Get the symbol for the given variable.
     *
     * If a symbol does not exist for the variable, one will be created.
     */
        Solver.prototype._getVarSymbol = function (variable) {
            var _this = this;
            var factory = function () {
                return _this._makeSymbol(SymbolType.External);
            };
            return this._varMap.setDefault(variable, factory).second;
        };
        /**
     * Create a new Row object for the given constraint.
     *
     * The terms in the constraint will be converted to cells in the row.
     * Any term in the constraint with a coefficient of zero is ignored.
     * This method uses the `_getVarSymbol` method to get the symbol for
     * the variables added to the row. If the symbol for a given cell
     * variable is basic, the cell variable will be substituted with the
     * basic row.
     *
     * The necessary slack and error variables will be added to the row.
     * If the constant for the row is negative, the sign for the row
     * will be inverted so the constant becomes positive.
     *
     * Returns the created Row and the tag for tracking the constraint.
     */
        Solver.prototype._createRow = function (constraint) {
            var expr = constraint.expression;
            var row = new Row(expr.constant);
            // Substitute the current basic variables into the row.
            var terms = expr.terms;
            for (var i = 0, n = terms.size(); i < n; ++i) {
                var termPair = terms.itemAt(i);
                if (!nearZero(termPair.second)) {
                    var symbol = this._getVarSymbol(termPair.first);
                    var basicPair = this._rowMap.find(symbol);
                    if (basicPair !== undefined) {
                        row.insertRow(basicPair.second, termPair.second);
                    } else {
                        row.insertSymbol(symbol, termPair.second);
                    }
                }
            }
            // Add the necessary slack, error, and dummy variables.
            var objective = this._objective;
            var strength = constraint.strength;
            var tag = {
                marker: INVALID_SYMBOL,
                other: INVALID_SYMBOL
            };
            switch (constraint.op) {
            case constraint_1.Operator.Le:
            case constraint_1.Operator.Ge: {
                    var coeff = constraint.op === constraint_1.Operator.Le ? 1 : -1;
                    var slack = this._makeSymbol(SymbolType.Slack);
                    tag.marker = slack;
                    row.insertSymbol(slack, coeff);
                    if (strength < strength_1.Strength.required) {
                        var error = this._makeSymbol(SymbolType.Error);
                        tag.other = error;
                        row.insertSymbol(error, -coeff);
                        objective.insertSymbol(error, strength);
                    }
                    break;
                }
            case constraint_1.Operator.Eq: {
                    if (strength < strength_1.Strength.required) {
                        var errplus = this._makeSymbol(SymbolType.Error);
                        var errminus = this._makeSymbol(SymbolType.Error);
                        tag.marker = errplus;
                        tag.other = errminus;
                        row.insertSymbol(errplus, -1);
                        // v = eplus - eminus
                        row.insertSymbol(errminus, 1);
                        // v - eplus + eminus = 0
                        objective.insertSymbol(errplus, strength);
                        objective.insertSymbol(errminus, strength);
                    } else {
                        var dummy = this._makeSymbol(SymbolType.Dummy);
                        tag.marker = dummy;
                        row.insertSymbol(dummy);
                    }
                    break;
                }
            }
            // Ensure the row has a positive constant.
            if (row.constant() < 0) {
                row.reverseSign();
            }
            return {
                row: row,
                tag: tag
            };
        };
        /**
     * Choose the subject for solving for the row.
     *
     * This method will choose the best subject for using as the solve
     * target for the row. An invalid symbol will be returned if there
     * is no valid target.
     *
     * The symbols are chosen according to the following precedence:
     *
     * 1) The first symbol representing an external variable.
     * 2) A negative slack or error tag variable.
     *
     * If a subject cannot be found, an invalid symbol will be returned.
     */
        Solver.prototype._chooseSubject = function (row, tag) {
            var cells = row.cells();
            for (var i = 0, n = cells.size(); i < n; ++i) {
                var pair = cells.itemAt(i);
                if (pair.first.type() === SymbolType.External) {
                    return pair.first;
                }
            }
            var type = tag.marker.type();
            if (type === SymbolType.Slack || type === SymbolType.Error) {
                if (row.coefficientFor(tag.marker) < 0) {
                    return tag.marker;
                }
            }
            type = tag.other.type();
            if (type === SymbolType.Slack || type === SymbolType.Error) {
                if (row.coefficientFor(tag.other) < 0) {
                    return tag.other;
                }
            }
            return INVALID_SYMBOL;
        };
        /**
     * Add the row to the tableau using an artificial variable.
     *
     * This will return false if the constraint cannot be satisfied.
     */
        Solver.prototype._addWithArtificialVariable = function (row) {
            // Create and add the artificial variable to the tableau.
            var art = this._makeSymbol(SymbolType.Slack);
            this._rowMap.insert(art, row.copy());
            this._artificial = row.copy();
            // Optimize the artificial objective. This is successful
            // only if the artificial objective is optimized to zero.
            this._optimize(this._artificial);
            var success = nearZero(this._artificial.constant());
            this._artificial = null;
            // If the artificial variable is basic, pivot the row so that
            // it becomes non-basic. If the row is constant, exit early.
            var pair = this._rowMap.erase(art);
            if (pair !== undefined) {
                var basicRow = pair.second;
                if (basicRow.isConstant()) {
                    return success;
                }
                var entering = this._anyPivotableSymbol(basicRow);
                if (entering.type() === SymbolType.Invalid) {
                    return false;    // unsatisfiable (will this ever happen?)
                }
                basicRow.solveForEx(art, entering);
                this._substitute(entering, basicRow);
                this._rowMap.insert(entering, basicRow);
            }
            // Remove the artificial variable from the tableau.
            var rows = this._rowMap;
            for (var i = 0, n = rows.size(); i < n; ++i) {
                rows.itemAt(i).second.removeSymbol(art);
            }
            this._objective.removeSymbol(art);
            return success;
        };
        /**
     * Substitute the parametric symbol with the given row.
     *
     * This method will substitute all instances of the parametric symbol
     * in the tableau and the objective function with the given row.
     */
        Solver.prototype._substitute = function (symbol, row) {
            var rows = this._rowMap;
            for (var i = 0, n = rows.size(); i < n; ++i) {
                var pair = rows.itemAt(i);
                pair.second.substitute(symbol, row);
                if (pair.second.constant() < 0 && pair.first.type() !== SymbolType.External) {
                    this._infeasibleRows.push(pair.first);
                }
            }
            this._objective.substitute(symbol, row);
            if (this._artificial) {
                this._artificial.substitute(symbol, row);
            }
        };
        /**
     * Optimize the system for the given objective function.
     *
     * This method performs iterations of Phase 2 of the simplex method
     * until the objective function reaches a minimum.
     */
        Solver.prototype._optimize = function (objective) {
            while (true) {
                var entering = this._getEnteringSymbol(objective);
                if (entering.type() === SymbolType.Invalid) {
                    return;
                }
                var leaving = this._getLeavingSymbol(entering);
                if (leaving.type() === SymbolType.Invalid) {
                    throw new Error('the objective is unbounded');
                }
                // pivot the entering symbol into the basis
                var row = this._rowMap.erase(leaving).second;
                row.solveForEx(leaving, entering);
                this._substitute(entering, row);
                this._rowMap.insert(entering, row);
            }
        };
        /**
     * Optimize the system using the dual of the simplex method.
     *
     * The current state of the system should be such that the objective
     * function is optimal, but not feasible. This method will perform
     * an iteration of the dual simplex method to make the solution both
     * optimal and feasible.
     */
        Solver.prototype._dualOptimize = function () {
            var rows = this._rowMap;
            var infeasible = this._infeasibleRows;
            while (infeasible.length !== 0) {
                var leaving = infeasible.pop();
                var pair = rows.find(leaving);
                if (pair !== undefined && pair.second.constant() < 0) {
                    var entering = this._getDualEnteringSymbol(pair.second);
                    if (entering.type() === SymbolType.Invalid) {
                        throw new Error('dual optimize failed');
                    }
                    // pivot the entering symbol into the basis
                    var row = pair.second;
                    rows.erase(leaving);
                    row.solveForEx(leaving, entering);
                    this._substitute(entering, row);
                    rows.insert(entering, row);
                }
            }
        };
        /**
     * Compute the entering variable for a pivot operation.
     *
     * This method will return first symbol in the objective function which
     * is non-dummy and has a coefficient less than zero. If no symbol meets
     * the criteria, it means the objective function is at a minimum, and an
     * invalid symbol is returned.
     */
        Solver.prototype._getEnteringSymbol = function (objective) {
            var cells = objective.cells();
            for (var i = 0, n = cells.size(); i < n; ++i) {
                var pair = cells.itemAt(i);
                var symbol = pair.first;
                if (pair.second < 0 && symbol.type() !== SymbolType.Dummy) {
                    return symbol;
                }
            }
            return INVALID_SYMBOL;
        };
        /**
     * Compute the entering symbol for the dual optimize operation.
     *
     * This method will return the symbol in the row which has a positive
     * coefficient and yields the minimum ratio for its respective symbol
     * in the objective function. The provided row *must* be infeasible.
     * If no symbol is found which meats the criteria, an invalid symbol
     * is returned.
     */
        Solver.prototype._getDualEnteringSymbol = function (row) {
            var ratio = Number.MAX_VALUE;
            var entering = INVALID_SYMBOL;
            var cells = row.cells();
            for (var i = 0, n = cells.size(); i < n; ++i) {
                var pair = cells.itemAt(i);
                var symbol = pair.first;
                var c = pair.second;
                if (c > 0 && symbol.type() !== SymbolType.Dummy) {
                    var coeff = this._objective.coefficientFor(symbol);
                    var r = coeff / c;
                    if (r < ratio) {
                        ratio = r;
                        entering = symbol;
                    }
                }
            }
            return entering;
        };
        /**
     * Compute the symbol for pivot exit row.
     *
     * This method will return the symbol for the exit row in the row
     * map. If no appropriate exit symbol is found, an invalid symbol
     * will be returned. This indicates that the objective function is
     * unbounded.
     */
        Solver.prototype._getLeavingSymbol = function (entering) {
            var ratio = Number.MAX_VALUE;
            var found = INVALID_SYMBOL;
            var rows = this._rowMap;
            for (var i = 0, n = rows.size(); i < n; ++i) {
                var pair = rows.itemAt(i);
                var symbol = pair.first;
                if (symbol.type() !== SymbolType.External) {
                    var row = pair.second;
                    var temp = row.coefficientFor(entering);
                    if (temp < 0) {
                        var temp_ratio = -row.constant() / temp;
                        if (temp_ratio < ratio) {
                            ratio = temp_ratio;
                            found = symbol;
                        }
                    }
                }
            }
            return found;
        };
        /**
     * Compute the leaving symbol for a marker variable.
     *
     * This method will return a symbol corresponding to a basic row
     * which holds the given marker variable. The row will be chosen
     * according to the following precedence:
     *
     * 1) The row with a restricted basic varible and a negative coefficient
     *    for the marker with the smallest ratio of -constant / coefficient.
     *
     * 2) The row with a restricted basic variable and the smallest ratio
     *    of constant / coefficient.
     *
     * 3) The last unrestricted row which contains the marker.
     *
     * If the marker does not exist in any row, an invalid symbol will be
     * returned. This indicates an internal solver error since the marker
     * *should* exist somewhere in the tableau.
     */
        Solver.prototype._getMarkerLeavingSymbol = function (marker) {
            var dmax = Number.MAX_VALUE;
            var r1 = dmax;
            var r2 = dmax;
            var invalid = INVALID_SYMBOL;
            var first = invalid;
            var second = invalid;
            var third = invalid;
            var rows = this._rowMap;
            for (var i = 0, n = rows.size(); i < n; ++i) {
                var pair = rows.itemAt(i);
                var row = pair.second;
                var c = row.coefficientFor(marker);
                if (c === 0) {
                    continue;
                }
                var symbol = pair.first;
                if (symbol.type() === SymbolType.External) {
                    third = symbol;
                } else if (c < 0) {
                    var r = -row.constant() / c;
                    if (r < r1) {
                        r1 = r;
                        first = symbol;
                    }
                } else {
                    var r = row.constant() / c;
                    if (r < r2) {
                        r2 = r;
                        second = symbol;
                    }
                }
            }
            if (first !== invalid) {
                return first;
            }
            if (second !== invalid) {
                return second;
            }
            return third;
        };
        /**
     * Remove the effects of a constraint on the objective function.
     */
        Solver.prototype._removeConstraintEffects = function (cn, tag) {
            if (tag.marker.type() === SymbolType.Error) {
                this._removeMarkerEffects(tag.marker, cn.strength);
            }
            if (tag.other.type() === SymbolType.Error) {
                this._removeMarkerEffects(tag.other, cn.strength);
            }
        };
        /**
     * Remove the effects of an error marker on the objective function.
     */
        Solver.prototype._removeMarkerEffects = function (marker, strength) {
            var pair = this._rowMap.find(marker);
            if (pair !== undefined) {
                this._objective.insertRow(pair.second, -strength);
            } else {
                this._objective.insertSymbol(marker, -strength);
            }
        };
        /**
     * Get the first Slack or Error symbol in the row.
     *
     * If no such symbol is present, an invalid symbol will be returned.
     */
        Solver.prototype._anyPivotableSymbol = function (row) {
            var cells = row.cells();
            for (var i = 0, n = cells.size(); i < n; ++i) {
                var pair = cells.itemAt(i);
                var type = pair.first.type();
                if (type === SymbolType.Slack || type === SymbolType.Error) {
                    return pair.first;
                }
            }
            return INVALID_SYMBOL;
        };
        /**
     * Returns a new Symbol of the given type.
     */
        Solver.prototype._makeSymbol = function (type) {
            return new Symbol(type, this._idTick++);
        };
        return Solver;
    }();
    exports.Solver = Solver;
    /**
 * Test whether a value is approximately zero.
 */
    function nearZero(value) {
        var eps = 1e-8;
        return value < 0 ? -value < eps : value < eps;
    }
    /**
 * An internal function for creating a constraint map.
 */
    function createCnMap() {
        return maptype_1.createMap(constraint_1.Constraint.Compare);
    }
    /**
 * An internal function for creating a row map.
 */
    function createRowMap() {
        return maptype_1.createMap(Symbol.Compare);
    }
    /**
 * An internal function for creating a variable map.
 */
    function createVarMap() {
        return maptype_1.createMap(variable_1.Variable.Compare);
    }
    /**
 * An internal function for creating an edit map.
 */
    function createEditMap() {
        return maptype_1.createMap(variable_1.Variable.Compare);
    }
    /**
 * An enum defining the available symbol types.
 */
    var SymbolType;
    (function (SymbolType) {
        SymbolType[SymbolType['Invalid'] = 0] = 'Invalid';
        SymbolType[SymbolType['External'] = 1] = 'External';
        SymbolType[SymbolType['Slack'] = 2] = 'Slack';
        SymbolType[SymbolType['Error'] = 3] = 'Error';
        SymbolType[SymbolType['Dummy'] = 4] = 'Dummy';
    }(SymbolType || (SymbolType = {})));
    /**
 * An internal class representing a symbol in the solver.
 */
    var Symbol = function () {
        /**
     * Construct a new Symbol
     *
     * @param [type] The type of the symbol.
     * @param [id] The unique id number of the symbol.
     */
        function Symbol(type, id) {
            this._id = id;
            this._type = type;
        }
        /**
     * The static Symbol comparison function.
     */
        Symbol.Compare = function (a, b) {
            return a.id() - b.id();
        };
        /**
     * Returns the unique id number of the symbol.
     */
        Symbol.prototype.id = function () {
            return this._id;
        };
        /**
     * Returns the type of the symbol.
     */
        Symbol.prototype.type = function () {
            return this._type;
        };
        return Symbol;
    }();
    /**
 * A static invalid symbol
 */
    var INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);
    /**
 * An internal row class used by the solver.
 */
    var Row = function () {
        /**
     * Construct a new Row.
     */
        function Row(constant) {
            if (constant === void 0) {
                constant = 0;
            }
            this._cellMap = maptype_1.createMap(Symbol.Compare);
            this._constant = constant;
        }
        /**
     * Returns the mapping of symbols to coefficients.
     */
        Row.prototype.cells = function () {
            return this._cellMap;
        };
        /**
     * Returns the constant for the row.
     */
        Row.prototype.constant = function () {
            return this._constant;
        };
        /**
     * Returns true if the row is a constant value.
     */
        Row.prototype.isConstant = function () {
            return this._cellMap.empty();
        };
        /**
     * Returns true if the Row has all dummy symbols.
     */
        Row.prototype.allDummies = function () {
            var cells = this._cellMap;
            for (var i = 0, n = cells.size(); i < n; ++i) {
                var pair = cells.itemAt(i);
                if (pair.first.type() !== SymbolType.Dummy) {
                    return false;
                }
            }
            return true;
        };
        /**
     * Create a copy of the row.
     */
        Row.prototype.copy = function () {
            var theCopy = new Row(this._constant);
            theCopy._cellMap = this._cellMap.copy();
            return theCopy;
        };
        /**
     * Add a constant value to the row constant.
     *
     * Returns the new value of the constant.
     */
        Row.prototype.add = function (value) {
            return this._constant += value;
        };
        /**
     * Insert the symbol into the row with the given coefficient.
     *
     * If the symbol already exists in the row, the coefficient
     * will be added to the existing coefficient. If the resulting
     * coefficient is zero, the symbol will be removed from the row.
     */
        Row.prototype.insertSymbol = function (symbol, coefficient) {
            if (coefficient === void 0) {
                coefficient = 1;
            }
            var pair = this._cellMap.setDefault(symbol, function () {
                return 0;
            });
            if (nearZero(pair.second += coefficient)) {
                this._cellMap.erase(symbol);
            }
        };
        /**
     * Insert a row into this row with a given coefficient.
     *
     * The constant and the cells of the other row will be
     * multiplied by the coefficient and added to this row. Any
     * cell with a resulting coefficient of zero will be removed
     * from the row.
     */
        Row.prototype.insertRow = function (other, coefficient) {
            if (coefficient === void 0) {
                coefficient = 1;
            }
            this._constant += other._constant * coefficient;
            var cells = other._cellMap;
            for (var i = 0, n = cells.size(); i < n; ++i) {
                var pair = cells.itemAt(i);
                this.insertSymbol(pair.first, pair.second * coefficient);
            }
        };
        /**
     * Remove a symbol from the row.
     */
        Row.prototype.removeSymbol = function (symbol) {
            this._cellMap.erase(symbol);
        };
        /**
     * Reverse the sign of the constant and cells in the row.
     */
        Row.prototype.reverseSign = function () {
            this._constant = -this._constant;
            var cells = this._cellMap;
            for (var i = 0, n = cells.size(); i < n; ++i) {
                var pair = cells.itemAt(i);
                pair.second = -pair.second;
            }
        };
        /**
     * Solve the row for the given symbol.
     *
     * This method assumes the row is of the form
     * a * x + b * y + c = 0 and (assuming solve for x) will modify
     * the row to represent the right hand side of
     * x = -b/a * y - c / a. The target symbol will be removed from
     * the row, and the constant and other cells will be multiplied
     * by the negative inverse of the target coefficient.
     *
     * The given symbol *must* exist in the row.
     */
        Row.prototype.solveFor = function (symbol) {
            var cells = this._cellMap;
            var pair = cells.erase(symbol);
            var coeff = -1 / pair.second;
            this._constant *= coeff;
            for (var i = 0, n = cells.size(); i < n; ++i) {
                cells.itemAt(i).second *= coeff;
            }
        };
        /**
     * Solve the row for the given symbols.
     *
     * This method assumes the row is of the form
     * x = b * y + c and will solve the row such that
     * y = x / b - c / b. The rhs symbol will be removed from the
     * row, the lhs added, and the result divided by the negative
     * inverse of the rhs coefficient.
     *
     * The lhs symbol *must not* exist in the row, and the rhs
     * symbol must* exist in the row.
     */
        Row.prototype.solveForEx = function (lhs, rhs) {
            this.insertSymbol(lhs, -1);
            this.solveFor(rhs);
        };
        /**
     * Returns the coefficient for the given symbol.
     */
        Row.prototype.coefficientFor = function (symbol) {
            var pair = this._cellMap.find(symbol);
            return pair !== undefined ? pair.second : 0;
        };
        /**
     * Substitute a symbol with the data from another row.
     *
     * Given a row of the form a * x + b and a substitution of the
     * form x = 3 * y + c the row will be updated to reflect the
     * expression 3 * a * y + a * c + b.
     *
     * If the symbol does not exist in the row, this is a no-op.
     */
        Row.prototype.substitute = function (symbol, row) {
            var pair = this._cellMap.erase(symbol);
            if (pair !== undefined) {
                this.insertRow(row, pair.second);
            }
        };
        return Row;
    }();
},
/*kiwi/build/strength*/
function _(require, module, exports) {
    var Strength;
    (function (Strength) {
        /**
     * Create a new symbolic strength.
     */
        function create(a, b, c, w) {
            if (w === void 0) {
                w = 1;
            }
            var result = 0;
            result += Math.max(0, Math.min(1000, a * w)) * 1000000;
            result += Math.max(0, Math.min(1000, b * w)) * 1000;
            result += Math.max(0, Math.min(1000, c * w));
            return result;
        }
        Strength.create = create;
        /**
     * The 'required' symbolic strength.
     */
        Strength.required = create(1000, 1000, 1000);
        /**
     * The 'strong' symbolic strength.
     */
        Strength.strong = create(1, 0, 0);
        /**
     * The 'medium' symbolic strength.
     */
        Strength.medium = create(0, 1, 0);
        /**
     * The 'weak' symbolic strength.
     */
        Strength.weak = create(0, 0, 1);
        /**
     * Clip a symbolic strength to the allowed min and max.
     */
        function clip(value) {
            return Math.max(0, Math.min(Strength.required, value));
        }
        Strength.clip = clip;
    }(Strength = exports.Strength || (exports.Strength = {})));
},
/*kiwi/build/tsu/algorithm*/
function _(require, module, exports) {
    var iterator_1 = require(329    /* ./iterator */);
    /**
* Perform a lower bound search on a sorted array.
*
* @param array The array of sorted items to search.
* @param value The value to located in the array.
* @param compare The value comparison function.
* @returns The index of the first element in the array which
*          compares greater than or equal to the given value.
*/
    function lowerBound(array, value, compare) {
        var begin = 0;
        var n = array.length;
        var half;
        var middle;
        while (n > 0) {
            half = n >> 1;
            middle = begin + half;
            if (compare(array[middle], value) < 0) {
                begin = middle + 1;
                n -= half + 1;
            } else {
                n = half;
            }
        }
        return begin;
    }
    exports.lowerBound = lowerBound;
    /**
* Perform a binary search on a sorted array.
*
* @param array The array of sorted items to search.
* @param value The value to located in the array.
* @param compare The value comparison function.
* @returns The index of the found item, or -1.
*/
    function binarySearch(array, value, compare) {
        var index = lowerBound(array, value, compare);
        if (index === array.length) {
            return -1;
        }
        var item = array[index];
        if (compare(item, value) !== 0) {
            return -1;
        }
        return index;
    }
    exports.binarySearch = binarySearch;
    /**
* Perform a binary find on a sorted array.
*
* @param array The array of sorted items to search.
* @param value The value to located in the array.
* @param compare The value comparison function.
* @returns The found item in the array, or undefined.
*/
    function binaryFind(array, value, compare) {
        var index = lowerBound(array, value, compare);
        if (index === array.length) {
            return undefined;
        }
        var item = array[index];
        if (compare(item, value) !== 0) {
            return undefined;
        }
        return item;
    }
    exports.binaryFind = binaryFind;
    function asSet(items, compare) {
        var array = iterator_1.asArray(items);
        var n = array.length;
        if (n <= 1) {
            return array;
        }
        array.sort(compare);
        var result = [array[0]];
        for (var i = 1, j = 0; i < n; ++i) {
            var item = array[i];
            if (compare(result[j], item) !== 0) {
                result.push(item);
                ++j;
            }
        }
        return result;
    }
    exports.asSet = asSet;
    /**
* Test whether a two sorted arrays sets are disjoint.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns true if the sets are disjoint, false otherwise.
*/
    function setIsDisjoint(first, second, compare) {
        var i = 0, j = 0;
        var len1 = first.length;
        var len2 = second.length;
        while (i < len1 && j < len2) {
            var v = compare(first[i], second[j]);
            if (v < 0) {
                ++i;
            } else if (v > 0) {
                ++j;
            } else {
                return false;
            }
        }
        return true;
    }
    exports.setIsDisjoint = setIsDisjoint;
    /**
* Test whether one sorted array set is the subset of another.
*
* @param first The potential subset.
* @param second The potential superset.
* @param compare The value comparison function.
* @returns true if the first set is a subset of the second.
*/
    function setIsSubset(first, second, compare) {
        var len1 = first.length;
        var len2 = second.length;
        if (len1 > len2) {
            return false;
        }
        var i = 0, j = 0;
        while (i < len1 && j < len2) {
            var v = compare(first[i], second[j]);
            if (v < 0) {
                return false;
            } else if (v > 0) {
                ++j;
            } else {
                ++i;
                ++j;
            }
        }
        if (i < len1) {
            return false;
        }
        return true;
    }
    exports.setIsSubset = setIsSubset;
    /**
* Create the set union of two sorted set arrays.
var j = 0;
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set union of the two arrays.
*/
    function setUnion(first, second, compare) {
        var i = 0, j = 0;
        var len1 = first.length;
        var len2 = second.length;
        var merged = [];
        while (i < len1 && j < len2) {
            var a = first[i];
            var b = second[j];
            var v = compare(a, b);
            if (v < 0) {
                merged.push(a);
                ++i;
            } else if (v > 0) {
                merged.push(b);
                ++j;
            } else {
                merged.push(a);
                ++i;
                ++j;
            }
        }
        while (i < len1) {
            merged.push(first[i]);
            ++i;
        }
        while (j < len2) {
            merged.push(second[j]);
            ++j;
        }
        return merged;
    }
    exports.setUnion = setUnion;
    /**
* Create a set intersection of two sorted set arrays.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set intersection of the two arrays.
*/
    function setIntersection(first, second, compare) {
        var i = 0, j = 0;
        var len1 = first.length;
        var len2 = second.length;
        var merged = [];
        while (i < len1 && j < len2) {
            var a = first[i];
            var b = second[j];
            var v = compare(a, b);
            if (v < 0) {
                ++i;
            } else if (v > 0) {
                ++j;
            } else {
                merged.push(a);
                ++i;
                ++j;
            }
        }
        return merged;
    }
    exports.setIntersection = setIntersection;
    /**
* Create a set difference of two sorted set arrays.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set difference of the two arrays.
*/
    function setDifference(first, second, compare) {
        var i = 0, j = 0;
        var len1 = first.length;
        var len2 = second.length;
        var merged = [];
        while (i < len1 && j < len2) {
            var a = first[i];
            var b = second[j];
            var v = compare(a, b);
            if (v < 0) {
                merged.push(a);
                ++i;
            } else if (v > 0) {
                ++j;
            } else {
                ++i;
                ++j;
            }
        }
        while (i < len1) {
            merged.push(first[i]);
            ++i;
        }
        return merged;
    }
    exports.setDifference = setDifference;
    /**
* Create a set symmetric difference of two sorted set arrays.
*
* @param first The first sorted array set.
* @param second The second sorted array set.
* @param compare The value comparison function.
* @returns The set symmetric difference of the two arrays.
*/
    function setSymmetricDifference(first, second, compare) {
        var i = 0, j = 0;
        var len1 = first.length;
        var len2 = second.length;
        var merged = [];
        while (i < len1 && j < len2) {
            var a = first[i];
            var b = second[j];
            var v = compare(a, b);
            if (v < 0) {
                merged.push(a);
                ++i;
            } else if (v > 0) {
                merged.push(b);
                ++j;
            } else {
                ++i;
                ++j;
            }
        }
        while (i < len1) {
            merged.push(first[i]);
            ++i;
        }
        while (j < len2) {
            merged.push(second[j]);
            ++j;
        }
        return merged;
    }
    exports.setSymmetricDifference = setSymmetricDifference;
},
/*kiwi/build/tsu/array_base*/
function _(require, module, exports) {
    var iterator_1 = require(329    /* ./iterator */);
    /**
* A base class for implementing array-based data structures.
*
* @class
*/
    var ArrayBase = function () {
        function ArrayBase() {
            /*
        * The internal data array.
        *
        * @protected
        */
            this._array = [];
        }
        /**
    * Returns the number of items in the array.
    */
        ArrayBase.prototype.size = function () {
            return this._array.length;
        };
        /**
    * Returns true if the array is empty.
    */
        ArrayBase.prototype.empty = function () {
            return this._array.length === 0;
        };
        /**
    * Returns the item at the given array index.
    *
    * @param index The integer index of the desired item.
    */
        ArrayBase.prototype.itemAt = function (index) {
            return this._array[index];
        };
        /**
    * Removes and returns the item at the given index.
    *
    * @param index The integer index of the desired item.
    */
        ArrayBase.prototype.takeAt = function (index) {
            return this._array.splice(index, 1)[0];
        };
        /**
    * Clear the internal contents of array.
    */
        ArrayBase.prototype.clear = function () {
            this._array = [];
        };
        /**
    * Swap this array's contents with another array.
    *
    * @param other The array base to use for the swap.
    */
        ArrayBase.prototype.swap = function (other) {
            var array = this._array;
            this._array = other._array;
            other._array = array;
        };
        /**
    * Returns an iterator over the array of items.
    */
        ArrayBase.prototype.__iter__ = function () {
            return iterator_1.iter(this._array);
        };
        /**
    * Returns a reverse iterator over the array of items.
    */
        ArrayBase.prototype.__reversed__ = function () {
            return iterator_1.reversed(this._array);
        };
        return ArrayBase;
    }();
    exports.ArrayBase = ArrayBase;
},
/*kiwi/build/tsu/associative_array*/
function _(require, module, exports) {
    /*-----------------------------------------------------------------------------
| Copyright (c) 2014, Nucleic Development Team.
|
| Distributed under the terms of the Modified BSD License.
|
| The full license is in the file COPYING.txt, distributed with this software.
|----------------------------------------------------------------------------*/
    var __extends = this && this.__extends || function () {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p];
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var pair_1 = require(330    /* ./pair */);
    var array_base_1 = require(326    /* ./array_base */);
    var algorithm_1 = require(325    /* ./algorithm */);
    var iterator_1 = require(329    /* ./iterator */);
    /**
* A mapping container build on a sorted array.
*
* @class
*/
    var AssociativeArray = function (_super) {
        __extends(AssociativeArray, _super);
        /**
    * Construct a new AssociativeArray.
    *
    * @param compare The key comparison function.
    */
        function AssociativeArray(compare) {
            var _this = _super.call(this) || this;
            _this._compare = compare;
            _this._wrapped = wrapCompare(compare);
            return _this;
        }
        /**
    * Returns the key comparison function used by this array.
    */
        AssociativeArray.prototype.comparitor = function () {
            return this._compare;
        };
        /**
    * Return the array index of the given key, or -1.
    *
    * @param key The key to locate in the array.
    */
        AssociativeArray.prototype.indexOf = function (key) {
            return algorithm_1.binarySearch(this._array, key, this._wrapped);
        };
        /**
    * Returns true if the key is in the array, false otherwise.
    *
    * @param key The key to locate in the array.
    */
        AssociativeArray.prototype.contains = function (key) {
            return algorithm_1.binarySearch(this._array, key, this._wrapped) >= 0;
        };
        /**
    * Returns the pair associated with the given key, or undefined.
    *
    * @param key The key to locate in the array.
    */
        AssociativeArray.prototype.find = function (key) {
            return algorithm_1.binaryFind(this._array, key, this._wrapped);
        };
        /**
    * Returns the pair associated with the key if it exists.
    *
    * If the key does not exist, a new pair will be created and
    * inserted using the value created by the given factory.
    *
    * @param key The key to locate in the array.
    * @param factory The function which creates the default value.
    */
        AssociativeArray.prototype.setDefault = function (key, factory) {
            var array = this._array;
            var index = algorithm_1.lowerBound(array, key, this._wrapped);
            if (index === array.length) {
                var pair = new pair_1.Pair(key, factory());
                array.push(pair);
                return pair;
            }
            var currPair = array[index];
            if (this._compare(currPair.first, key) !== 0) {
                var pair = new pair_1.Pair(key, factory());
                array.splice(index, 0, pair);
                return pair;
            }
            return currPair;
        };
        /**
    * Insert the pair into the array and return the pair.
    *
    * This will overwrite any existing entry in the array.
    *
    * @param key The key portion of the pair.
    * @param value The value portion of the pair.
    */
        AssociativeArray.prototype.insert = function (key, value) {
            var array = this._array;
            var index = algorithm_1.lowerBound(array, key, this._wrapped);
            if (index === array.length) {
                var pair = new pair_1.Pair(key, value);
                array.push(pair);
                return pair;
            }
            var currPair = array[index];
            if (this._compare(currPair.first, key) !== 0) {
                var pair = new pair_1.Pair(key, value);
                array.splice(index, 0, pair);
                return pair;
            }
            currPair.second = value;
            return currPair;
        };
        AssociativeArray.prototype.update = function (object) {
            var _this = this;
            if (object instanceof AssociativeArray) {
                this._array = merge(this._array, object._array, this._compare);
            } else {
                iterator_1.forEach(object, function (pair) {
                    _this.insert(pair.first, pair.second);
                });
            }
        };
        /**
    * Removes and returns the pair for the given key, or undefined.
    *
    * @param key The key to remove from the map.
    */
        AssociativeArray.prototype.erase = function (key) {
            var array = this._array;
            var index = algorithm_1.binarySearch(array, key, this._wrapped);
            if (index < 0) {
                return undefined;
            }
            return array.splice(index, 1)[0];
        };
        /**
    * Create a copy of this associative array.
    */
        AssociativeArray.prototype.copy = function () {
            var theCopy = new AssociativeArray(this._compare);
            var copyArray = theCopy._array;
            var thisArray = this._array;
            for (var i = 0, n = thisArray.length; i < n; ++i) {
                copyArray.push(thisArray[i].copy());
            }
            return theCopy;
        };
        return AssociativeArray;
    }(array_base_1.ArrayBase);
    exports.AssociativeArray = AssociativeArray;
    /**
* An internal which wraps a comparison key function.
*/
    function wrapCompare(cmp) {
        return function (pair, value) {
            return cmp(pair.first, value);
        };
    }
    /**
* An internal function which merges two ordered pair arrays.
*/
    function merge(first, second, compare) {
        var i = 0, j = 0;
        var len1 = first.length;
        var len2 = second.length;
        var merged = [];
        while (i < len1 && j < len2) {
            var a = first[i];
            var b = second[j];
            var v = compare(a.first, b.first);
            if (v < 0) {
                merged.push(a.copy());
                ++i;
            } else if (v > 0) {
                merged.push(b.copy());
                ++j;
            } else {
                merged.push(b.copy());
                ++i;
                ++j;
            }
        }
        while (i < len1) {
            merged.push(first[i].copy());
            ++i;
        }
        while (j < len2) {
            merged.push(second[j].copy());
            ++j;
        }
        return merged;
    }
},
/*kiwi/build/tsu/index*/
function _(require, module, exports) {
    function __export(m) {
        for (var p in m)
            if (!exports.hasOwnProperty(p))
                exports[p] = m[p];
    }
    __export(require(325    /* ./algorithm */));
    __export(require(326    /* ./array_base */));
    __export(require(327    /* ./associative_array */));
    __export(require(329    /* ./iterator */));
    __export(require(330    /* ./pair */));
},
/*kiwi/build/tsu/iterator*/
function _(require, module, exports) {
    /**
* An iterator for an array of items.
*/
    var ArrayIterator = function () {
        /*
    * Construct a new ArrayIterator.
    *
    * @param array The array of items to iterate.
    * @param [index] The index at which to start iteration.
    */
        function ArrayIterator(array, index) {
            if (typeof index === 'undefined') {
                index = 0;
            }
            this._array = array;
            this._index = Math.max(0, Math.min(index, array.length));
        }
        /**
    * Returns the next item from the iterator or undefined.
    */
        ArrayIterator.prototype.__next__ = function () {
            return this._array[this._index++];
        };
        /**
    * Returns this same iterator.
    */
        ArrayIterator.prototype.__iter__ = function () {
            return this;
        };
        return ArrayIterator;
    }();
    exports.ArrayIterator = ArrayIterator;
    /**
* A reverse iterator for an array of items.
*/
    var ReverseArrayIterator = function () {
        /**
    * Construct a new ReverseArrayIterator.
    *
    * @param array The array of items to iterate.
    * @param [index] The index at which to start iteration.
    */
        function ReverseArrayIterator(array, index) {
            if (typeof index === 'undefined') {
                index = array.length;
            }
            this._array = array;
            this._index = Math.max(0, Math.min(index, array.length));
        }
        /**
    * Returns the next item from the iterator or undefined.
    */
        ReverseArrayIterator.prototype.__next__ = function () {
            return this._array[--this._index];
        };
        /**
    * Returns this same iterator.
    */
        ReverseArrayIterator.prototype.__iter__ = function () {
            return this;
        };
        return ReverseArrayIterator;
    }();
    exports.ReverseArrayIterator = ReverseArrayIterator;
    function iter(object) {
        if (object instanceof Array) {
            return new ArrayIterator(object);
        }
        return object.__iter__();
    }
    exports.iter = iter;
    function reversed(object) {
        if (object instanceof Array) {
            return new ReverseArrayIterator(object);
        }
        return object.__reversed__();
    }
    exports.reversed = reversed;
    /**
* Returns the next value from an iterator, or undefined.
*/
    function next(iterator) {
        return iterator.__next__();
    }
    exports.next = next;
    function asArray(object) {
        if (object instanceof Array) {
            return object.slice();
        }
        var value;
        var array = [];
        var it = object.__iter__();
        while ((value = it.__next__()) !== undefined) {
            array.push(value);
        }
        return array;
    }
    exports.asArray = asArray;
    function forEach(object, callback) {
        if (object instanceof Array) {
            for (var i = 0, n = object.length; i < n; ++i) {
                if (callback(object[i]) === false) {
                    return;
                }
            }
        } else {
            var value;
            var it = object.__iter__();
            while ((value = it.__next__()) !== undefined) {
                if (callback(value) === false) {
                    return;
                }
            }
        }
    }
    exports.forEach = forEach;
    function map(object, callback) {
        var result = [];
        if (object instanceof Array) {
            for (var i = 0, n = object.length; i < n; ++i) {
                result.push(callback(object[i]));
            }
        } else {
            var value;
            var it = object.__iter__();
            while ((value = it.__next__()) !== undefined) {
                result.push(callback(value));
            }
        }
        return result;
    }
    exports.map = map;
    function filter(object, callback) {
        var value;
        var result = [];
        if (object instanceof Array) {
            for (var i = 0, n = object.length; i < n; ++i) {
                value = object[i];
                if (callback(value)) {
                    result.push(value);
                }
            }
        } else {
            var it = object.__iter__();
            while ((value = it.__next__()) !== undefined) {
                if (callback(value)) {
                    result.push(value);
                }
            }
        }
        return result;
    }
    exports.filter = filter;
},
/*kiwi/build/tsu/pair*/
function _(require, module, exports) {
    /**
* A class which defines a generic pair object.
*/
    var Pair = function () {
        /**
    * Construct a new Pair object.
    *
    * @param first The first item of the pair.
    * @param second The second item of the pair.
    */
        function Pair(first, second) {
            this.first = first;
            this.second = second;
        }
        /**
    * Create a copy of the pair.
    */
        Pair.prototype.copy = function () {
            return new Pair(this.first, this.second);
        };
        return Pair;
    }();
    exports.Pair = Pair;
},
/*kiwi/build/variable*/
function _(require, module, exports) {
    /**
 * The primary user constraint variable.
 *
 * @class
 */
    var Variable = function () {
        /**
     * Construct a new Variable
     *
     * @param [name] The name to associated with the variable.
     */
        function Variable(name) {
            if (name === void 0) {
                name = '';
            }
            this._value = 0;
            this._context = null;
            this._id = VarId++;
            this._name = name;
        }
        /**
     * A static variable comparison function.
     */
        Variable.Compare = function (a, b) {
            return a.id - b.id;
        };
        Variable.prototype.toString = function () {
            return this._name;
        };
        Object.defineProperty(Variable.prototype, 'id', {
            /**
         * Returns the unique id number of the variable.
         */
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Variable.prototype, 'name', {
            /**
         * Returns the name of the variable.
         */
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        /**
     * Set the name of the variable.
     */
        Variable.prototype.setName = function (name) {
            this._name = name;
        };
        Object.defineProperty(Variable.prototype, 'context', {
            /**
         * Returns the user context object of the variable.
         */
            get: function () {
                return this._context;
            },
            enumerable: true,
            configurable: true
        });
        /**
     * Set the user context object of the variable.
     */
        Variable.prototype.setContext = function (context) {
            this._context = context;
        };
        Object.defineProperty(Variable.prototype, 'value', {
            /**
         * Returns the value of the variable.
         */
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        /**
     * Set the value of the variable.
     */
        Variable.prototype.setValue = function (value) {
            this._value = value;
        };
        return Variable;
    }();
    exports.Variable = Variable;
    /**
 * The internal variable id counter.
 */
    var VarId = 0;
},
/*!
 * numbro.js
 * version : 1.6.2
 * author : Fretagsplatsen AB
 * license : MIT
 * http://www.foretagsplatsen.se
 */
/************************************
        Constants
    ************************************/
/*numbro/numbro*/
function _(require, module, exports) {
    var numbro, VERSION = '1.6.2',
        // internal storage for culture config files
        cultures = {},
        // Todo: Remove in 2.0.0
        languages = cultures, currentCulture = 'en-US', zeroFormat = null, defaultFormat = '0,0', defaultCurrencyFormat = '0$',
        // check for nodeJS
        hasModule = typeof module !== 'undefined' && module.exports,
        // default culture
        enUS = {
            delimiters: {
                thousands: ',',
                decimal: '.'
            },
            abbreviations: {
                thousand: 'k',
                million: 'm',
                billion: 'b',
                trillion: 't'
            },
            ordinal: function (number) {
                var b = number % 10;
                return ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            },
            currency: {
                symbol: '$',
                position: 'prefix'
            },
            defaults: { currencyFormat: ',0000 a' },
            formats: {
                fourDigits: '0000 a',
                fullWithTwoDecimals: '$ ,0.00',
                fullWithTwoDecimalsNoCurrency: ',0.00'
            }
        };
    /************************************
        Constructors
    ************************************/
    // Numbro prototype object
    function Numbro(number) {
        this._value = number;
    }
    function zeroes(count) {
        var i, ret = '';
        for (i = 0; i < count; i++) {
            ret += '0';
        }
        return ret;
    }
    /**
     * Implementation of toFixed() for numbers with exponent > 21
     *
     *
     */
    function toFixedLarge(value, precision) {
        var mantissa, beforeDec, afterDec, exponent, str;
        str = value.toString();
        mantissa = str.split('e')[0];
        exponent = str.split('e')[1];
        beforeDec = mantissa.split('.')[0];
        afterDec = mantissa.split('.')[1] || '';
        str = beforeDec + afterDec + zeroes(exponent - afterDec.length);
        if (precision > 0) {
            str += '.' + zeroes(precision);
        }
        return str;
    }
    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision), optionalsRegExp, output;
        if (value.toFixed(0).search('e') > -1) {
            // Above 1e21, toFixed returns scientific notation, which
            // is useless and unexpected
            output = toFixedLarge(value, precision);
        } else {
            //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
            // Multiply up by precision, round accurately, then divide and use native toFixed():
            output = (roundingFunction(value * power) / power).toFixed(precision);
        }
        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }
        return output;
    }
    /************************************
        Formatting
    ************************************/
    // determine what type of formatting we need to do
    function formatNumbro(value, format, roundingFunction) {
        var output;
        // TODO: do something with `language`
        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(value, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(value, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(value);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(value, format, roundingFunction);
        }
        // return string
        return output;
    }
    function formatCurrency(value, originalFormat, roundingFunction) {
        var format = originalFormat, symbolIndex = format.indexOf('$'), openParenIndex = format.indexOf('('), plusSignIndex = format.indexOf('+'), minusSignIndex = format.indexOf('-'), space = '', decimalSeparator = '', spliceIndex, output;
        if (format.indexOf('$') === -1) {
            // Use defaults instead of the format provided
            if (cultures[currentCulture].currency.position === 'infix') {
                decimalSeparator = cultures[currentCulture].currency.symbol;
                if (cultures[currentCulture].currency.spaceSeparated) {
                    decimalSeparator = ' ' + decimalSeparator + ' ';
                }
            } else if (cultures[currentCulture].currency.spaceSeparated) {
                space = ' ';
            }
        } else {
            // check for space before or after currency
            if (format.indexOf(' $') > -1) {
                space = ' ';
                format = format.replace(' $', '');
            } else if (format.indexOf('$ ') > -1) {
                space = ' ';
                format = format.replace('$ ', '');
            } else {
                format = format.replace('$', '');
            }
        }
        // Format The Number
        output = formatNumber(value, format, roundingFunction, decimalSeparator);
        if (originalFormat.indexOf('$') === -1) {
            // Use defaults instead of the format provided
            switch (cultures[currentCulture].currency.position) {
            case 'postfix':
                if (output.indexOf(')') > -1) {
                    output = output.split('');
                    output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);
                    output = output.join('');
                } else {
                    output = output + space + cultures[currentCulture].currency.symbol;
                }
                break;
            case 'infix':
                break;
            case 'prefix':
                if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                    output = output.split('');
                    spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;
                    output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);
                    output = output.join('');
                } else {
                    output = cultures[currentCulture].currency.symbol + space + output;
                }
                break;
            default:
                throw Error('Currency position should be among ["prefix", "infix", "postfix"]');
            }
        } else {
            // position the symbol
            if (symbolIndex <= 1) {
                if (output.indexOf('(') > -1 || output.indexOf('+') > -1 || output.indexOf('-') > -1) {
                    output = output.split('');
                    spliceIndex = 1;
                    if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {
                        // the symbol appears before the "(", "+" or "-"
                        spliceIndex = 0;
                    }
                    output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);
                    output = output.join('');
                } else {
                    output = cultures[currentCulture].currency.symbol + space + output;
                }
            } else {
                if (output.indexOf(')') > -1) {
                    output = output.split('');
                    output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);
                    output = output.join('');
                } else {
                    output = output + space + cultures[currentCulture].currency.symbol;
                }
            }
        }
        return output;
    }
    function formatPercentage(value, format, roundingFunction) {
        var space = '', output;
        value = value * 100;
        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }
        output = formatNumber(value, format, roundingFunction);
        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }
        return output;
    }
    function formatTime(value) {
        var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }
    function formatNumber(value, format, roundingFunction, sep) {
        var negP = false, signed = false, optDec = false, abbr = '', i, abbrK = false,
            // force abbreviation to thousands
            abbrM = false,
            // force abbreviation to millions
            abbrB = false,
            // force abbreviation to billions
            abbrT = false,
            // force abbreviation to trillions
            abbrForce = false,
            // force abbreviation
            bytes = '', ord = '', abs = Math.abs(value), binarySuffixes = [
                'B',
                'KiB',
                'MiB',
                'GiB',
                'TiB',
                'PiB',
                'EiB',
                'ZiB',
                'YiB'
            ], decimalSuffixes = [
                'B',
                'KB',
                'MB',
                'GB',
                'TB',
                'PB',
                'EB',
                'ZB',
                'YB'
            ], min, max, power, totalLength, length, minimumPrecision, pow, w, intPrecision, precision, prefix, postfix, thousands, d = '', forcedNeg = false, neg = false, indexOpenP, size, indexMinus, paren = '', minlen;
        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        }
        if (!isFinite(value)) {
            return '' + value;
        }
        if (format.indexOf('{') === 0) {
            var end = format.indexOf('}');
            if (end === -1) {
                throw Error('Format should also contain a "}"');
            }
            prefix = format.slice(1, end);
            format = format.slice(end + 1);
        } else {
            prefix = '';
        }
        if (format.indexOf('}') === format.length - 1) {
            var start = format.indexOf('{');
            if (start === -1) {
                throw Error('Format should also contain a "{"');
            }
            postfix = format.slice(start + 1, -1);
            format = format.slice(0, start + 1);
        } else {
            postfix = '';
        }
        // check for min length
        var info;
        if (format.indexOf('.') === -1) {
            info = format.match(/([0-9]+).*/);
        } else {
            info = format.match(/([0-9]+)\..*/);
        }
        minlen = info === null ? -1 : info[1].length;
        // see if we should use parentheses for negative number or if we should prefix with a sign
        // if both are present we default to parentheses
        if (format.indexOf('-') !== -1) {
            forcedNeg = true;
        }
        if (format.indexOf('(') > -1) {
            negP = true;
            format = format.slice(1, -1);
        } else if (format.indexOf('+') > -1) {
            signed = true;
            format = format.replace(/\+/g, '');
        }
        // see if abbreviation is wanted
        if (format.indexOf('a') > -1) {
            intPrecision = format.split('.')[0].match(/[0-9]+/g) || ['0'];
            intPrecision = parseInt(intPrecision[0], 10);
            // check if abbreviation is specified
            abbrK = format.indexOf('aK') >= 0;
            abbrM = format.indexOf('aM') >= 0;
            abbrB = format.indexOf('aB') >= 0;
            abbrT = format.indexOf('aT') >= 0;
            abbrForce = abbrK || abbrM || abbrB || abbrT;
            // check for space before abbreviation
            if (format.indexOf(' a') > -1) {
                abbr = ' ';
                format = format.replace(' a', '');
            } else {
                format = format.replace('a', '');
            }
            totalLength = Math.floor(Math.log(abs) / Math.LN10) + 1;
            minimumPrecision = totalLength % 3;
            minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;
            if (intPrecision && abs !== 0) {
                length = Math.floor(Math.log(abs) / Math.LN10) + 1 - intPrecision;
                pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);
                abs = abs / Math.pow(10, pow);
                if (format.indexOf('.') === -1 && intPrecision > 3) {
                    format += '[.]';
                    size = length === 0 ? 0 : 3 * ~~(length / 3) - length;
                    size = size < 0 ? size + 3 : size;
                    for (i = 0; i < size; i++) {
                        format += '0';
                    }
                }
            }
            if (Math.floor(Math.log(Math.abs(value)) / Math.LN10) + 1 !== intPrecision) {
                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + cultures[currentCulture].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + cultures[currentCulture].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + cultures[currentCulture].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + cultures[currentCulture].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }
        }
        // see if we are formatting binary bytes
        if (format.indexOf('b') > -1) {
            // check for space before
            if (format.indexOf(' b') > -1) {
                bytes = ' ';
                format = format.replace(' b', '');
            } else {
                format = format.replace('b', '');
            }
            for (power = 0; power <= binarySuffixes.length; power++) {
                min = Math.pow(1024, power);
                max = Math.pow(1024, power + 1);
                if (value >= min && value < max) {
                    bytes = bytes + binarySuffixes[power];
                    if (min > 0) {
                        value = value / min;
                    }
                    break;
                }
            }
        }
        // see if we are formatting decimal bytes
        if (format.indexOf('d') > -1) {
            // check for space before
            if (format.indexOf(' d') > -1) {
                bytes = ' ';
                format = format.replace(' d', '');
            } else {
                format = format.replace('d', '');
            }
            for (power = 0; power <= decimalSuffixes.length; power++) {
                min = Math.pow(1000, power);
                max = Math.pow(1000, power + 1);
                if (value >= min && value < max) {
                    bytes = bytes + decimalSuffixes[power];
                    if (min > 0) {
                        value = value / min;
                    }
                    break;
                }
            }
        }
        // see if ordinal is wanted
        if (format.indexOf('o') > -1) {
            // check for space before
            if (format.indexOf(' o') > -1) {
                ord = ' ';
                format = format.replace(' o', '');
            } else {
                format = format.replace('o', '');
            }
            if (cultures[currentCulture].ordinal) {
                ord = ord + cultures[currentCulture].ordinal(value);
            }
        }
        if (format.indexOf('[.]') > -1) {
            optDec = true;
            format = format.replace('[.]', '.');
        }
        w = value.toString().split('.')[0];
        precision = format.split('.')[1];
        thousands = format.indexOf(',');
        if (precision) {
            if (precision.indexOf('*') !== -1) {
                d = toFixed(value, value.toString().split('.')[1].length, roundingFunction);
            } else {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }
            }
            w = d.split('.')[0];
            if (d.split('.')[1].length) {
                var p = sep ? abbr + sep : cultures[currentCulture].delimiters.decimal;
                d = p + d.split('.')[1];
            } else {
                d = '';
            }
            if (optDec && Number(d.slice(1)) === 0) {
                d = '';
            }
        } else {
            w = toFixed(value, null, roundingFunction);
        }
        // format number
        if (w.indexOf('-') > -1) {
            w = w.slice(1);
            neg = true;
        }
        if (w.length < minlen) {
            w = new Array(minlen - w.length + 1).join('0') + w;
        }
        if (thousands > -1) {
            w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + cultures[currentCulture].delimiters.thousands);
        }
        if (format.indexOf('.') === 0) {
            w = '';
        }
        indexOpenP = format.indexOf('(');
        indexMinus = format.indexOf('-');
        if (indexOpenP < indexMinus) {
            paren = (negP && neg ? '(' : '') + (forcedNeg && neg || !negP && neg ? '-' : '');
        } else {
            paren = (forcedNeg && neg || !negP && neg ? '-' : '') + (negP && neg ? '(' : '');
        }
        return prefix + paren + (!neg && signed && value !== 0 ? '+' : '') + w + d + (ord ? ord : '') + (abbr && !sep ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '') + postfix;
    }
    /************************************
        Top Level Functions
    ************************************/
    numbro = function (input) {
        if (numbro.isNumbro(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numbro.fn.unformat(input);
        }
        return new Numbro(Number(input));
    };
    // version number
    numbro.version = VERSION;
    // compare numbro object
    numbro.isNumbro = function (obj) {
        return obj instanceof Numbro;
    };
    /**
     * This function allow the user to set a new language with a fallback if
     * the language does not exist. If no fallback language is provided,
     * it fallbacks to english.
     *
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `setCulture` should be used instead.
     */
    numbro.setLanguage = function (newLanguage, fallbackLanguage) {
        console.warn('`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead');
        var key = newLanguage, prefix = newLanguage.split('-')[0], matchingLanguage = null;
        if (!languages[key]) {
            Object.keys(languages).forEach(function (language) {
                if (!matchingLanguage && language.split('-')[0] === prefix) {
                    matchingLanguage = language;
                }
            });
            key = matchingLanguage || fallbackLanguage || 'en-US';
        }
        chooseCulture(key);
    };
    /**
     * This function allow the user to set a new culture with a fallback if
     * the culture does not exist. If no fallback culture is provided,
     * it fallbacks to "en-US".
     */
    numbro.setCulture = function (newCulture, fallbackCulture) {
        var key = newCulture, suffix = newCulture.split('-')[1], matchingCulture = null;
        if (!cultures[key]) {
            if (suffix) {
                Object.keys(cultures).forEach(function (language) {
                    if (!matchingCulture && language.split('-')[1] === suffix) {
                        matchingCulture = language;
                    }
                });
            }
            key = matchingCulture || fallbackCulture || 'en-US';
        }
        chooseCulture(key);
    };
    /**
     * This function will load languages and then set the global language.  If
     * no arguments are passed in, it will simply return the current global
     * language key.
     *
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `culture` should be used instead.
     */
    numbro.language = function (key, values) {
        console.warn('`language` is deprecated since version 1.6.0. Use `culture` instead');
        if (!key) {
            return currentCulture;
        }
        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            chooseCulture(key);
        }
        if (values || !languages[key]) {
            setCulture(key, values);
        }
        return numbro;
    };
    /**
     * This function will load cultures and then set the global culture.  If
     * no arguments are passed in, it will simply return the current global
     * culture code.
     */
    numbro.culture = function (code, values) {
        if (!code) {
            return currentCulture;
        }
        if (code && !values) {
            if (!cultures[code]) {
                throw new Error('Unknown culture : ' + code);
            }
            chooseCulture(code);
        }
        if (values || !cultures[code]) {
            setCulture(code, values);
        }
        return numbro;
    };
    /**
     * This function provides access to the loaded language data.  If
     * no arguments are passed in, it will simply return the current
     * global language object.
     *
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `culture` should be used instead.
     */
    numbro.languageData = function (key) {
        console.warn('`languageData` is deprecated since version 1.6.0. Use `cultureData` instead');
        if (!key) {
            return languages[currentCulture];
        }
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        return languages[key];
    };
    /**
     * This function provides access to the loaded culture data.  If
     * no arguments are passed in, it will simply return the current
     * global culture object.
     */
    numbro.cultureData = function (code) {
        if (!code) {
            return cultures[currentCulture];
        }
        if (!cultures[code]) {
            throw new Error('Unknown culture : ' + code);
        }
        return cultures[code];
    };
    numbro.culture('en-US', enUS);
    /**
     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0
     * `cultures` should be used instead.
     */
    numbro.languages = function () {
        console.warn('`languages` is deprecated since version 1.6.0. Use `cultures` instead');
        return languages;
    };
    numbro.cultures = function () {
        return cultures;
    };
    numbro.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };
    numbro.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };
    numbro.defaultCurrencyFormat = function (format) {
        defaultCurrencyFormat = typeof format === 'string' ? format : '0$';
    };
    numbro.validate = function (val, culture) {
        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, cultureData, temp;
        //coerce val to string
        if (typeof val !== 'string') {
            val += '';
            if (console.warn) {
                console.warn('Numbro.js: Value is not string. It has been co-erced to: ', val);
            }
        }
        //trim whitespaces from either sides
        val = val.trim();
        //if val is just digits return true
        if (!!val.match(/^\d+$/)) {
            return true;
        }
        //if val is empty return false
        if (val === '') {
            return false;
        }
        //get the decimal and thousands separator from numbro.cultureData
        try {
            //check if the culture is understood by numbro. if not, default it to current culture
            cultureData = numbro.cultureData(culture);
        } catch (e) {
            cultureData = numbro.cultureData(numbro.culture());
        }
        //setup the delimiters and currency symbol based on culture
        _currSymbol = cultureData.currency.symbol;
        _abbrObj = cultureData.abbreviations;
        _decimalSep = cultureData.delimiters.decimal;
        if (cultureData.delimiters.thousands === '.') {
            _thousandSep = '\\.';
        } else {
            _thousandSep = cultureData.delimiters.thousands;
        }
        // validating currency symbol
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
                return false;
            }
        }
        //validating abbreviation symbol
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
                return false;
            }
        }
        _thousandRegEx = new RegExp(_thousandSep + '{2}');
        if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
                return false;
            } else {
                if (_valArray.length < 2) {
                    return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
                } else {
                    if (_valArray[0].length === 1) {
                        return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                    } else {
                        return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                    }
                }
            }
        }
        return false;
    };
    /************************************
        Helpers
    ************************************/
    function setCulture(code, values) {
        cultures[code] = values;
    }
    function chooseCulture(code) {
        currentCulture = code;
        var defaults = cultures[code].defaults;
        if (defaults && defaults.format) {
            numbro.defaultFormat(defaults.format);
        }
        if (defaults && defaults.currencyFormat) {
            numbro.defaultCurrencyFormat(defaults.currencyFormat);
        }
    }
    function format(input, formatString, language, roundingFunction) {
        if (language != null && language !== numbro.culture()) {
            numbro.setCulture(language);
        }
        return formatNumbro(Number(input), formatString != null ? formatString : defaultFormat, roundingFunction == null ? Math.round : roundingFunction);
    }
    module.exports = { 'format': format };
},
/*proj4/lib/Proj*/
function _(require, module, exports) {
    var parseCode = require(353    /* ./parseCode */);
    var extend = require(351    /* ./extend */);
    var projections = require(355    /* ./projections */);
    var deriveConstants = require(350    /* ./deriveConstants */);
    var Datum = require(341    /* ./constants/Datum */);
    var datum = require(346    /* ./datum */);
    function Projection(srsCode, callback) {
        if (!(this instanceof Projection)) {
            return new Projection(srsCode);
        }
        callback = callback || function (error) {
            if (error) {
                throw error;
            }
        };
        var json = parseCode(srsCode);
        if (typeof json !== 'object') {
            callback(srsCode);
            return;
        }
        var ourProj = Projection.projections.get(json.projName);
        if (!ourProj) {
            callback(srsCode);
            return;
        }
        if (json.datumCode && json.datumCode !== 'none') {
            var datumDef = Datum[json.datumCode];
            if (datumDef) {
                json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
                json.ellps = datumDef.ellipse;
                json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
            }
        }
        json.k0 = json.k0 || 1;
        json.axis = json.axis || 'enu';
        var sphere = deriveConstants.sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
        var ecc = deriveConstants.eccentricity(sphere.a, sphere.b, sphere.rf, json.R_A);
        var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere.a, sphere.b, ecc.es, ecc.ep2);
        extend(this, json);
        // transfer everything over from the projection because we don't know what we'll need
        extend(this, ourProj);
        // transfer all the methods from the projection
        // copy the 4 things over we calulated in deriveConstants.sphere
        this.a = sphere.a;
        this.b = sphere.b;
        this.rf = sphere.rf;
        this.sphere = sphere.sphere;
        // copy the 3 things we calculated in deriveConstants.eccentricity
        this.es = ecc.es;
        this.e = ecc.e;
        this.ep2 = ecc.ep2;
        // add in the datum object
        this.datum = datumObj;
        // init the projection
        this.init();
        // legecy callback from back in the day when it went to spatialreference.org
        callback(null, this);
    }
    Projection.projections = projections;
    Projection.projections.start();
    module.exports = Projection;
},
/*proj4/lib/adjust_axis*/
function _(require, module, exports) {
    module.exports = function (crs, denorm, point) {
        var xin = point.x, yin = point.y, zin = point.z || 0;
        var v, t, i;
        var out = {};
        for (i = 0; i < 3; i++) {
            if (denorm && i === 2 && point.z === undefined) {
                continue;
            }
            if (i === 0) {
                v = xin;
                t = 'x';
            } else if (i === 1) {
                v = yin;
                t = 'y';
            } else {
                v = zin;
                t = 'z';
            }
            switch (crs.axis[i]) {
            case 'e':
                out[t] = v;
                break;
            case 'w':
                out[t] = -v;
                break;
            case 'n':
                out[t] = v;
                break;
            case 's':
                out[t] = -v;
                break;
            case 'u':
                if (point[t] !== undefined) {
                    out.z = v;
                }
                break;
            case 'd':
                if (point[t] !== undefined) {
                    out.z = -v;
                }
                break;
            default:
                //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
                return null;
            }
        }
        return out;
    };
},
/*proj4/lib/common/adjust_lon*/
function _(require, module, exports) {
    var TWO_PI = Math.PI * 2;
    // SPI is slightly greater than Math.PI, so values that exceed the -180..180
    // degree range by a tiny amount don't get wrapped. This prevents points that
    // have drifted from their original location along the 180th meridian (due to
    // floating point error) from changing their sign.
    var SPI = 3.14159265359;
    var sign = require(338    /* ./sign */);
    module.exports = function (x) {
        return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
    };
},
/*proj4/lib/common/msfnz*/
function _(require, module, exports) {
    module.exports = function (eccent, sinphi, cosphi) {
        var con = eccent * sinphi;
        return cosphi / Math.sqrt(1 - con * con);
    };
},
/*proj4/lib/common/phi2z*/
function _(require, module, exports) {
    var HALF_PI = Math.PI / 2;
    module.exports = function (eccent, ts) {
        var eccnth = 0.5 * eccent;
        var con, dphi;
        var phi = HALF_PI - 2 * Math.atan(ts);
        for (var i = 0; i <= 15; i++) {
            con = eccent * Math.sin(phi);
            dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
                return phi;
            }
        }
        //console.log("phi2z has NoConvergence");
        return -9999;
    };
},
/*proj4/lib/common/sign*/
function _(require, module, exports) {
    module.exports = function (x) {
        return x < 0 ? -1 : 1;
    };
},
/*proj4/lib/common/toPoint*/
function _(require, module, exports) {
    module.exports = function (array) {
        var out = {
            x: array[0],
            y: array[1]
        };
        if (array.length > 2) {
            out.z = array[2];
        }
        if (array.length > 3) {
            out.m = array[3];
        }
        return out;
    };
},
/*proj4/lib/common/tsfnz*/
function _(require, module, exports) {
    var HALF_PI = Math.PI / 2;
    module.exports = function (eccent, phi, sinphi) {
        var con = eccent * sinphi;
        var com = 0.5 * eccent;
        con = Math.pow((1 - con) / (1 + con), com);
        return Math.tan(0.5 * (HALF_PI - phi)) / con;
    };
},
/*proj4/lib/constants/Datum*/
function _(require, module, exports) {
    exports.wgs84 = {
        towgs84: '0,0,0',
        ellipse: 'WGS84',
        datumName: 'WGS84'
    };
    exports.ch1903 = {
        towgs84: '674.374,15.056,405.346',
        ellipse: 'bessel',
        datumName: 'swiss'
    };
    exports.ggrs87 = {
        towgs84: '-199.87,74.79,246.62',
        ellipse: 'GRS80',
        datumName: 'Greek_Geodetic_Reference_System_1987'
    };
    exports.nad83 = {
        towgs84: '0,0,0',
        ellipse: 'GRS80',
        datumName: 'North_American_Datum_1983'
    };
    exports.nad27 = {
        nadgrids: '@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat',
        ellipse: 'clrk66',
        datumName: 'North_American_Datum_1927'
    };
    exports.potsdam = {
        towgs84: '606.0,23.0,413.0',
        ellipse: 'bessel',
        datumName: 'Potsdam Rauenberg 1950 DHDN'
    };
    exports.carthage = {
        towgs84: '-263.0,6.0,431.0',
        ellipse: 'clark80',
        datumName: 'Carthage 1934 Tunisia'
    };
    exports.hermannskogel = {
        towgs84: '653.0,-212.0,449.0',
        ellipse: 'bessel',
        datumName: 'Hermannskogel'
    };
    exports.ire65 = {
        towgs84: '482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15',
        ellipse: 'mod_airy',
        datumName: 'Ireland 1965'
    };
    exports.rassadiran = {
        towgs84: '-133.63,-157.5,-158.62',
        ellipse: 'intl',
        datumName: 'Rassadiran'
    };
    exports.nzgd49 = {
        towgs84: '59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993',
        ellipse: 'intl',
        datumName: 'New Zealand Geodetic Datum 1949'
    };
    exports.osgb36 = {
        towgs84: '446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894',
        ellipse: 'airy',
        datumName: 'Airy 1830'
    };
    exports.s_jtsk = {
        towgs84: '589,76,480',
        ellipse: 'bessel',
        datumName: 'S-JTSK (Ferro)'
    };
    exports.beduaram = {
        towgs84: '-106,-87,188',
        ellipse: 'clrk80',
        datumName: 'Beduaram'
    };
    exports.gunung_segara = {
        towgs84: '-403,684,41',
        ellipse: 'bessel',
        datumName: 'Gunung Segara Jakarta'
    };
    exports.rnb72 = {
        towgs84: '106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1',
        ellipse: 'intl',
        datumName: 'Reseau National Belge 1972'
    };
},
/*proj4/lib/constants/Ellipsoid*/
function _(require, module, exports) {
    exports.MERIT = {
        a: 6378137,
        rf: 298.257,
        ellipseName: 'MERIT 1983'
    };
    exports.SGS85 = {
        a: 6378136,
        rf: 298.257,
        ellipseName: 'Soviet Geodetic System 85'
    };
    exports.GRS80 = {
        a: 6378137,
        rf: 298.257222101,
        ellipseName: 'GRS 1980(IUGG, 1980)'
    };
    exports.IAU76 = {
        a: 6378140,
        rf: 298.257,
        ellipseName: 'IAU 1976'
    };
    exports.airy = {
        a: 6377563.396,
        b: 6356256.91,
        ellipseName: 'Airy 1830'
    };
    exports.APL4 = {
        a: 6378137,
        rf: 298.25,
        ellipseName: 'Appl. Physics. 1965'
    };
    exports.NWL9D = {
        a: 6378145,
        rf: 298.25,
        ellipseName: 'Naval Weapons Lab., 1965'
    };
    exports.mod_airy = {
        a: 6377340.189,
        b: 6356034.446,
        ellipseName: 'Modified Airy'
    };
    exports.andrae = {
        a: 6377104.43,
        rf: 300,
        ellipseName: 'Andrae 1876 (Den., Iclnd.)'
    };
    exports.aust_SA = {
        a: 6378160,
        rf: 298.25,
        ellipseName: 'Australian Natl & S. Amer. 1969'
    };
    exports.GRS67 = {
        a: 6378160,
        rf: 298.247167427,
        ellipseName: 'GRS 67(IUGG 1967)'
    };
    exports.bessel = {
        a: 6377397.155,
        rf: 299.1528128,
        ellipseName: 'Bessel 1841'
    };
    exports.bess_nam = {
        a: 6377483.865,
        rf: 299.1528128,
        ellipseName: 'Bessel 1841 (Namibia)'
    };
    exports.clrk66 = {
        a: 6378206.4,
        b: 6356583.8,
        ellipseName: 'Clarke 1866'
    };
    exports.clrk80 = {
        a: 6378249.145,
        rf: 293.4663,
        ellipseName: 'Clarke 1880 mod.'
    };
    exports.clrk58 = {
        a: 6378293.645208759,
        rf: 294.2606763692654,
        ellipseName: 'Clarke 1858'
    };
    exports.CPM = {
        a: 6375738.7,
        rf: 334.29,
        ellipseName: 'Comm. des Poids et Mesures 1799'
    };
    exports.delmbr = {
        a: 6376428,
        rf: 311.5,
        ellipseName: 'Delambre 1810 (Belgium)'
    };
    exports.engelis = {
        a: 6378136.05,
        rf: 298.2566,
        ellipseName: 'Engelis 1985'
    };
    exports.evrst30 = {
        a: 6377276.345,
        rf: 300.8017,
        ellipseName: 'Everest 1830'
    };
    exports.evrst48 = {
        a: 6377304.063,
        rf: 300.8017,
        ellipseName: 'Everest 1948'
    };
    exports.evrst56 = {
        a: 6377301.243,
        rf: 300.8017,
        ellipseName: 'Everest 1956'
    };
    exports.evrst69 = {
        a: 6377295.664,
        rf: 300.8017,
        ellipseName: 'Everest 1969'
    };
    exports.evrstSS = {
        a: 6377298.556,
        rf: 300.8017,
        ellipseName: 'Everest (Sabah & Sarawak)'
    };
    exports.fschr60 = {
        a: 6378166,
        rf: 298.3,
        ellipseName: 'Fischer (Mercury Datum) 1960'
    };
    exports.fschr60m = {
        a: 6378155,
        rf: 298.3,
        ellipseName: 'Fischer 1960'
    };
    exports.fschr68 = {
        a: 6378150,
        rf: 298.3,
        ellipseName: 'Fischer 1968'
    };
    exports.helmert = {
        a: 6378200,
        rf: 298.3,
        ellipseName: 'Helmert 1906'
    };
    exports.hough = {
        a: 6378270,
        rf: 297,
        ellipseName: 'Hough'
    };
    exports.intl = {
        a: 6378388,
        rf: 297,
        ellipseName: 'International 1909 (Hayford)'
    };
    exports.kaula = {
        a: 6378163,
        rf: 298.24,
        ellipseName: 'Kaula 1961'
    };
    exports.lerch = {
        a: 6378139,
        rf: 298.257,
        ellipseName: 'Lerch 1979'
    };
    exports.mprts = {
        a: 6397300,
        rf: 191,
        ellipseName: 'Maupertius 1738'
    };
    exports.new_intl = {
        a: 6378157.5,
        b: 6356772.2,
        ellipseName: 'New International 1967'
    };
    exports.plessis = {
        a: 6376523,
        rf: 6355863,
        ellipseName: 'Plessis 1817 (France)'
    };
    exports.krass = {
        a: 6378245,
        rf: 298.3,
        ellipseName: 'Krassovsky, 1942'
    };
    exports.SEasia = {
        a: 6378155,
        b: 6356773.3205,
        ellipseName: 'Southeast Asia'
    };
    exports.walbeck = {
        a: 6376896,
        b: 6355834.8467,
        ellipseName: 'Walbeck'
    };
    exports.WGS60 = {
        a: 6378165,
        rf: 298.3,
        ellipseName: 'WGS 60'
    };
    exports.WGS66 = {
        a: 6378145,
        rf: 298.25,
        ellipseName: 'WGS 66'
    };
    exports.WGS7 = {
        a: 6378135,
        rf: 298.26,
        ellipseName: 'WGS 72'
    };
    exports.WGS84 = {
        a: 6378137,
        rf: 298.257223563,
        ellipseName: 'WGS 84'
    };
    exports.sphere = {
        a: 6370997,
        b: 6370997,
        ellipseName: 'Normal Sphere (r=6370997)'
    };
},
/*proj4/lib/constants/PrimeMeridian*/
function _(require, module, exports) {
    exports.greenwich = 0;
    //"0dE",
    exports.lisbon = -9.131906111111;
    //"9d07'54.862\"W",
    exports.paris = 2.337229166667;
    //"2d20'14.025\"E",
    exports.bogota = -74.080916666667;
    //"74d04'51.3\"W",
    exports.madrid = -3.687938888889;
    //"3d41'16.58\"W",
    exports.rome = 12.452333333333;
    //"12d27'8.4\"E",
    exports.bern = 7.439583333333;
    //"7d26'22.5\"E",
    exports.jakarta = 106.807719444444;
    //"106d48'27.79\"E",
    exports.ferro = -17.666666666667;
    //"17d40'W",
    exports.brussels = 4.367975;
    //"4d22'4.71\"E",
    exports.stockholm = 18.058277777778;
    //"18d3'29.8\"E",
    exports.athens = 23.7163375;
    //"23d42'58.815\"E",
    exports.oslo = 10.722916666667;    //"10d43'22.5\"E"
},
/*proj4/lib/constants/units*/
function _(require, module, exports) {
    exports.ft = { to_meter: 0.3048 };
    exports['us-ft'] = { to_meter: 1200 / 3937 };
},
/*proj4/lib/core*/
function _(require, module, exports) {
    var proj = require(333    /* ./Proj */);
    var transform = require(358    /* ./transform */);
    var wgs84 = proj('WGS84');
    function transformer(from, to, coords) {
        var transformedArray;
        if (Array.isArray(coords)) {
            transformedArray = transform(from, to, coords);
            if (coords.length === 3) {
                return [
                    transformedArray.x,
                    transformedArray.y,
                    transformedArray.z
                ];
            } else {
                return [
                    transformedArray.x,
                    transformedArray.y
                ];
            }
        } else {
            return transform(from, to, coords);
        }
    }
    function checkProj(item) {
        if (item instanceof proj) {
            return item;
        }
        if (item.oProj) {
            return item.oProj;
        }
        return proj(item);
    }
    function proj4(fromProj, toProj, coord) {
        fromProj = checkProj(fromProj);
        var single = false;
        var obj;
        if (typeof toProj === 'undefined') {
            toProj = fromProj;
            fromProj = wgs84;
            single = true;
        } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
            coord = toProj;
            toProj = fromProj;
            fromProj = wgs84;
            single = true;
        }
        toProj = checkProj(toProj);
        if (coord) {
            return transformer(fromProj, toProj, coord);
        } else {
            obj = {
                forward: function (coords) {
                    return transformer(fromProj, toProj, coords);
                },
                inverse: function (coords) {
                    return transformer(toProj, fromProj, coords);
                }
            };
            if (single) {
                obj.oProj = toProj;
            }
            return obj;
        }
    }
    module.exports = proj4;
},
/*proj4/lib/datum*/
function _(require, module, exports) {
    var PJD_3PARAM = 1;
    var PJD_7PARAM = 2;
    var PJD_WGS84 = 4;
    // WGS84 or equivalent
    var PJD_NODATUM = 5;
    // WGS84 or equivalent
    var SEC_TO_RAD = 0.00000484813681109536;
    function datum(datumCode, datum_params, a, b, es, ep2) {
        var out = {};
        out.datum_type = PJD_WGS84;
        //default setting
        if (datumCode && datumCode === 'none') {
            out.datum_type = PJD_NODATUM;
        }
        if (datum_params) {
            out.datum_params = datum_params.map(parseFloat);
            if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
                out.datum_type = PJD_3PARAM;
            }
            if (out.datum_params.length > 3) {
                if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
                    out.datum_type = PJD_7PARAM;
                    out.datum_params[3] *= SEC_TO_RAD;
                    out.datum_params[4] *= SEC_TO_RAD;
                    out.datum_params[5] *= SEC_TO_RAD;
                    out.datum_params[6] = out.datum_params[6] / 1000000 + 1;
                }
            }
        }
        out.a = a;
        //datum object also uses these values
        out.b = b;
        out.es = es;
        out.ep2 = ep2;
        return out;
    }
    module.exports = datum;
},
/*proj4/lib/datumUtils*/
function _(require, module, exports) {
    var PJD_3PARAM = 1;
    var PJD_7PARAM = 2;
    var HALF_PI = Math.PI / 2;
    exports.compareDatums = function (source, dest) {
        if (source.datum_type !== dest.datum_type) {
            return false;    // false, datums are not equal
        } else if (source.a !== dest.a || Math.abs(this.es - dest.es) > 5e-11) {
            // the tolerence for es is to ensure that GRS80 and WGS84
            // are considered identical
            return false;
        } else if (source.datum_type === PJD_3PARAM) {
            return this.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
        } else if (source.datum_type === PJD_7PARAM) {
            return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
        } else {
            return true;    // datums are equal
        }
    };
    // cs_compare_datums()
    /*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
    exports.geodeticToGeocentric = function (p, es, a) {
        var Longitude = p.x;
        var Latitude = p.y;
        var Height = p.z ? p.z : 0;
        //Z value not always supplied
        var Rn;
        /*  Earth radius at location  */
        var Sin_Lat;
        /*  Math.sin(Latitude)  */
        var Sin2_Lat;
        /*  Square of Math.sin(Latitude)  */
        var Cos_Lat;
        /*  Math.cos(Latitude)  */
        /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
        if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
            Latitude = -HALF_PI;
        } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
            Latitude = HALF_PI;
        } else if (Latitude < -HALF_PI || Latitude > HALF_PI) {
            /* Latitude out of range */
            //..reportError('geocent:lat out of range:' + Latitude);
            return null;
        }
        if (Longitude > Math.PI) {
            Longitude -= 2 * Math.PI;
        }
        Sin_Lat = Math.sin(Latitude);
        Cos_Lat = Math.cos(Latitude);
        Sin2_Lat = Sin_Lat * Sin_Lat;
        Rn = a / Math.sqrt(1 - es * Sin2_Lat);
        return {
            x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
            y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
            z: (Rn * (1 - es) + Height) * Sin_Lat
        };
    };
    // cs_geodetic_to_geocentric()
    exports.geocentricToGeodetic = function (p, es, a, b) {
        /* local defintions and variables */
        /* end-criterium of loop, accuracy of sin(Latitude) */
        var genau = 1e-12;
        var genau2 = genau * genau;
        var maxiter = 30;
        var P;
        /* distance between semi-minor axis and location */
        var RR;
        /* distance between center and location */
        var CT;
        /* sin of geocentric latitude */
        var ST;
        /* cos of geocentric latitude */
        var RX;
        var RK;
        var RN;
        /* Earth radius at location */
        var CPHI0;
        /* cos of start or old geodetic latitude in iterations */
        var SPHI0;
        /* sin of start or old geodetic latitude in iterations */
        var CPHI;
        /* cos of searched geodetic latitude */
        var SPHI;
        /* sin of searched geodetic latitude */
        var SDPHI;
        /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
        var iter;
        /* # of continous iteration, max. 30 is always enough (s.a.) */
        var X = p.x;
        var Y = p.y;
        var Z = p.z ? p.z : 0;
        //Z value not always supplied
        var Longitude;
        var Latitude;
        var Height;
        P = Math.sqrt(X * X + Y * Y);
        RR = Math.sqrt(X * X + Y * Y + Z * Z);
        /*      special cases for latitude and longitude */
        if (P / a < genau) {
            /*  special case, if P=0. (X=0., Y=0.) */
            Longitude = 0;
            /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
            if (RR / a < genau) {
                Latitude = HALF_PI;
                Height = -b;
                return {
                    x: p.x,
                    y: p.y,
                    z: p.z
                };
            }
        } else {
            /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
            Longitude = Math.atan2(Y, X);
        }
        /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
        CT = Z / RR;
        ST = P / RR;
        RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
        CPHI0 = ST * (1 - es) * RX;
        SPHI0 = CT * RX;
        iter = 0;
        /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
        do {
            iter++;
            RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
            /*  ellipsoidal (geodetic) height */
            Height = P * CPHI0 + Z * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
            RK = es * RN / (RN + Height);
            RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
            CPHI = ST * (1 - RK) * RX;
            SPHI = CT * RX;
            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
            CPHI0 = CPHI;
            SPHI0 = SPHI;
        } while (SDPHI * SDPHI > genau2 && iter < maxiter);
        /*      ellipsoidal (geodetic) latitude */
        Latitude = Math.atan(SPHI / Math.abs(CPHI));
        return {
            x: Longitude,
            y: Latitude,
            z: Height
        };
    };
    // cs_geocentric_to_geodetic()
    /****************************************************************/
    // pj_geocentic_to_wgs84( p )
    //  p = point to transform in geocentric coordinates (x,y,z)
    /** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
    exports.geocentricToWgs84 = function (p, datum_type, datum_params) {
        if (datum_type === PJD_3PARAM) {
            // if( x[io] === HUGE_VAL )
            //    continue;
            return {
                x: p.x + datum_params[0],
                y: p.y + datum_params[1],
                z: p.z + datum_params[2]
            };
        } else if (datum_type === PJD_7PARAM) {
            var Dx_BF = datum_params[0];
            var Dy_BF = datum_params[1];
            var Dz_BF = datum_params[2];
            var Rx_BF = datum_params[3];
            var Ry_BF = datum_params[4];
            var Rz_BF = datum_params[5];
            var M_BF = datum_params[6];
            // if( x[io] === HUGE_VAL )
            //    continue;
            return {
                x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
                y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
                z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
            };
        }
    };
    // cs_geocentric_to_wgs84
    /****************************************************************/
    // pj_geocentic_from_wgs84()
    //  coordinate system definition,
    //  point to transform in geocentric coordinates (x,y,z)
    exports.geocentricFromWgs84 = function (p, datum_type, datum_params) {
        if (datum_type === PJD_3PARAM) {
            //if( x[io] === HUGE_VAL )
            //    continue;
            return {
                x: p.x - datum_params[0],
                y: p.y - datum_params[1],
                z: p.z - datum_params[2]
            };
        } else if (datum_type === PJD_7PARAM) {
            var Dx_BF = datum_params[0];
            var Dy_BF = datum_params[1];
            var Dz_BF = datum_params[2];
            var Rx_BF = datum_params[3];
            var Ry_BF = datum_params[4];
            var Rz_BF = datum_params[5];
            var M_BF = datum_params[6];
            var x_tmp = (p.x - Dx_BF) / M_BF;
            var y_tmp = (p.y - Dy_BF) / M_BF;
            var z_tmp = (p.z - Dz_BF) / M_BF;
            //if( x[io] === HUGE_VAL )
            //    continue;
            return {
                x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
                y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
                z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
            };
        }    //cs_geocentric_from_wgs84()
    };
},
/*proj4/lib/datum_transform*/
function _(require, module, exports) {
    var PJD_3PARAM = 1;
    var PJD_7PARAM = 2;
    var PJD_NODATUM = 5;
    // WGS84 or equivalent
    var datum = require(347    /* ./datumUtils */);
    function checkParams(type) {
        return type === PJD_3PARAM || type === PJD_7PARAM;
    }
    module.exports = function (source, dest, point) {
        // Short cut if the datums are identical.
        if (datum.compareDatums(source, dest)) {
            return point;    // in this case, zero is sucess,
                             // whereas cs_compare_datums returns 1 to indicate TRUE
                             // confusing, should fix this
        }
        // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
        if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
            return point;
        }
        // If this datum requires grid shifts, then apply it to geodetic coordinates.
        // Do we need to go through geocentric coordinates?
        if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
            return point;
        }
        // Convert to geocentric coordinates.
        point = datum.geodeticToGeocentric(point, source.es, source.a);
        // Convert between datums
        if (checkParams(source.datum_type)) {
            point = datum.geocentricToWgs84(point, source.datum_type, source.datum_params);
        }
        if (checkParams(dest.datum_type)) {
            point = datum.geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
        }
        return datum.geocentricToGeodetic(point, dest.es, dest.a, dest.b);
    };
},
/*proj4/lib/defs*/
function _(require, module, exports) {
    var globals = require(352    /* ./global */);
    var parseProj = require(354    /* ./projString */);
    var wkt = require(359    /* ./wkt */);
    function defs(name) {
        /*global console*/
        var that = this;
        if (arguments.length === 2) {
            var def = arguments[1];
            if (typeof def === 'string') {
                if (def.charAt(0) === '+') {
                    defs[name] = parseProj(arguments[1]);
                } else {
                    defs[name] = wkt(arguments[1]);
                }
            } else {
                defs[name] = def;
            }
        } else if (arguments.length === 1) {
            if (Array.isArray(name)) {
                return name.map(function (v) {
                    if (Array.isArray(v)) {
                        defs.apply(that, v);
                    } else {
                        defs(v);
                    }
                });
            } else if (typeof name === 'string') {
                if (name in defs) {
                    return defs[name];
                }
            } else if ('EPSG' in name) {
                defs['EPSG:' + name.EPSG] = name;
            } else if ('ESRI' in name) {
                defs['ESRI:' + name.ESRI] = name;
            } else if ('IAU2000' in name) {
                defs['IAU2000:' + name.IAU2000] = name;
            } else {
                console.log(name);
            }
            return;
        }
    }
    globals(defs);
    module.exports = defs;
},
// ellipoid pj_set_ell.c
/*proj4/lib/deriveConstants*/
function _(require, module, exports) {
    var SIXTH = 0.16666666666666666;
    /* 1/6 */
    var RA4 = 0.04722222222222222;
    /* 17/360 */
    var RA6 = 0.022156084656084655;
    var EPSLN = 1e-10;
    var Ellipsoid = require(342    /* ./constants/Ellipsoid */);
    exports.eccentricity = function (a, b, rf, R_A) {
        var a2 = a * a;
        // used in geocentric
        var b2 = b * b;
        // used in geocentric
        var es = (a2 - b2) / a2;
        // e ^ 2
        var e = 0;
        if (R_A) {
            a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
            a2 = a * a;
            es = 0;
        } else {
            e = Math.sqrt(es);    // eccentricity
        }
        var ep2 = (a2 - b2) / b2;
        // used in geocentric
        return {
            es: es,
            e: e,
            ep2: ep2
        };
    };
    exports.sphere = function (a, b, rf, ellps, sphere) {
        if (!a) {
            // do we have an ellipsoid?
            var ellipse = Ellipsoid[ellps];
            if (!ellipse) {
                ellipse = Ellipsoid.WGS84;
            }
            a = ellipse.a;
            b = ellipse.b;
            rf = ellipse.rf;
        }
        if (rf && !b) {
            b = (1 - 1 / rf) * a;
        }
        if (rf === 0 || Math.abs(a - b) < EPSLN) {
            sphere = true;
            b = a;
        }
        return {
            a: a,
            b: b,
            rf: rf,
            sphere: sphere
        };
    };
},
/*proj4/lib/extend*/
function _(require, module, exports) {
    module.exports = function (destination, source) {
        destination = destination || {};
        var value, property;
        if (!source) {
            return destination;
        }
        for (property in source) {
            value = source[property];
            if (value !== undefined) {
                destination[property] = value;
            }
        }
        return destination;
    };
},
/*proj4/lib/global*/
function _(require, module, exports) {
    module.exports = function (defs) {
        defs('EPSG:4326', '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees');
        defs('EPSG:4269', '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees');
        defs('EPSG:3857', '+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs');
        defs.WGS84 = defs['EPSG:4326'];
        defs['EPSG:3785'] = defs['EPSG:3857'];
        // maintain backward compat, official code is 3857
        defs.GOOGLE = defs['EPSG:3857'];
        defs['EPSG:900913'] = defs['EPSG:3857'];
        defs['EPSG:102113'] = defs['EPSG:3857'];
    };
},
/*proj4/lib/parseCode*/
function _(require, module, exports) {
    var defs = require(349    /* ./defs */);
    var wkt = require(359    /* ./wkt */);
    var projStr = require(354    /* ./projString */);
    function testObj(code) {
        return typeof code === 'string';
    }
    function testDef(code) {
        return code in defs;
    }
    var codeWords = [
        'GEOGCS',
        'GEOCCS',
        'PROJCS',
        'LOCAL_CS'
    ];
    function testWKT(code) {
        return codeWords.some(function (word) {
            return code.indexOf(word) > -1;
        });
    }
    function testProj(code) {
        return code[0] === '+';
    }
    function parse(code) {
        if (testObj(code)) {
            //check to see if this is a WKT string
            if (testDef(code)) {
                return defs[code];
            }
            if (testWKT(code)) {
                return wkt(code);
            }
            if (testProj(code)) {
                return projStr(code);
            }
        } else {
            return code;
        }
    }
    module.exports = parse;
},
/*proj4/lib/projString*/
function _(require, module, exports) {
    var D2R = 0.017453292519943295;
    var PrimeMeridian = require(343    /* ./constants/PrimeMeridian */);
    var units = require(344    /* ./constants/units */);
    module.exports = function (defData) {
        var self = {};
        var paramObj = defData.split('+').map(function (v) {
            return v.trim();
        }).filter(function (a) {
            return a;
        }).reduce(function (p, a) {
            var split = a.split('=');
            split.push(true);
            p[split[0].toLowerCase()] = split[1];
            return p;
        }, {});
        var paramName, paramVal, paramOutname;
        var params = {
            proj: 'projName',
            datum: 'datumCode',
            rf: function (v) {
                self.rf = parseFloat(v);
            },
            lat_0: function (v) {
                self.lat0 = v * D2R;
            },
            lat_1: function (v) {
                self.lat1 = v * D2R;
            },
            lat_2: function (v) {
                self.lat2 = v * D2R;
            },
            lat_ts: function (v) {
                self.lat_ts = v * D2R;
            },
            lon_0: function (v) {
                self.long0 = v * D2R;
            },
            lon_1: function (v) {
                self.long1 = v * D2R;
            },
            lon_2: function (v) {
                self.long2 = v * D2R;
            },
            alpha: function (v) {
                self.alpha = parseFloat(v) * D2R;
            },
            lonc: function (v) {
                self.longc = v * D2R;
            },
            x_0: function (v) {
                self.x0 = parseFloat(v);
            },
            y_0: function (v) {
                self.y0 = parseFloat(v);
            },
            k_0: function (v) {
                self.k0 = parseFloat(v);
            },
            k: function (v) {
                self.k0 = parseFloat(v);
            },
            a: function (v) {
                self.a = parseFloat(v);
            },
            b: function (v) {
                self.b = parseFloat(v);
            },
            r_a: function () {
                self.R_A = true;
            },
            zone: function (v) {
                self.zone = parseInt(v, 10);
            },
            south: function () {
                self.utmSouth = true;
            },
            towgs84: function (v) {
                self.datum_params = v.split(',').map(function (a) {
                    return parseFloat(a);
                });
            },
            to_meter: function (v) {
                self.to_meter = parseFloat(v);
            },
            units: function (v) {
                self.units = v;
                if (units[v]) {
                    self.to_meter = units[v].to_meter;
                }
            },
            from_greenwich: function (v) {
                self.from_greenwich = v * D2R;
            },
            pm: function (v) {
                self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
            },
            nadgrids: function (v) {
                if (v === '@null') {
                    self.datumCode = 'none';
                } else {
                    self.nadgrids = v;
                }
            },
            axis: function (v) {
                var legalAxis = 'ewnsud';
                if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                    self.axis = v;
                }
            }
        };
        for (paramName in paramObj) {
            paramVal = paramObj[paramName];
            if (paramName in params) {
                paramOutname = params[paramName];
                if (typeof paramOutname === 'function') {
                    paramOutname(paramVal);
                } else {
                    self[paramOutname] = paramVal;
                }
            } else {
                self[paramName] = paramVal;
            }
        }
        if (typeof self.datumCode === 'string' && self.datumCode !== 'WGS84') {
            self.datumCode = self.datumCode.toLowerCase();
        }
        return self;
    };
},
/*proj4/lib/projections*/
function _(require, module, exports) {
    var projs = [
        require(357    /* ./projections/merc */),
        require(356    /* ./projections/longlat */)
    ];
    var names = {};
    var projStore = [];
    function add(proj, i) {
        var len = projStore.length;
        if (!proj.names) {
            console.log(i);
            return true;
        }
        projStore[len] = proj;
        proj.names.forEach(function (n) {
            names[n.toLowerCase()] = len;
        });
        return this;
    }
    exports.add = add;
    exports.get = function (name) {
        if (!name) {
            return false;
        }
        var n = name.toLowerCase();
        if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
            return projStore[names[n]];
        }
    };
    exports.start = function () {
        projs.forEach(add);
    };
},
/*proj4/lib/projections/longlat*/
function _(require, module, exports) {
    exports.init = function () {
    };
    function identity(pt) {
        return pt;
    }
    exports.forward = identity;
    exports.inverse = identity;
    exports.names = [
        'longlat',
        'identity'
    ];
},
/*proj4/lib/projections/merc*/
function _(require, module, exports) {
    var msfnz = require(336    /* ../common/msfnz */);
    var HALF_PI = Math.PI / 2;
    var EPSLN = 1e-10;
    var R2D = 57.29577951308232;
    var adjust_lon = require(335    /* ../common/adjust_lon */);
    var FORTPI = Math.PI / 4;
    var tsfnz = require(340    /* ../common/tsfnz */);
    var phi2z = require(337    /* ../common/phi2z */);
    exports.init = function () {
        var con = this.b / this.a;
        this.es = 1 - con * con;
        if (!('x0' in this)) {
            this.x0 = 0;
        }
        if (!('y0' in this)) {
            this.y0 = 0;
        }
        this.e = Math.sqrt(this.es);
        if (this.lat_ts) {
            if (this.sphere) {
                this.k0 = Math.cos(this.lat_ts);
            } else {
                this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
            }
        } else {
            if (!this.k0) {
                if (this.k) {
                    this.k0 = this.k;
                } else {
                    this.k0 = 1;
                }
            }
        }
    };
    /* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/
    exports.forward = function (p) {
        var lon = p.x;
        var lat = p.y;
        // convert to radians
        if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
            return null;
        }
        var x, y;
        if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            return null;
        } else {
            if (this.sphere) {
                x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
                y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
            } else {
                var sinphi = Math.sin(lat);
                var ts = tsfnz(this.e, lat, sinphi);
                x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
                y = this.y0 - this.a * this.k0 * Math.log(ts);
            }
            p.x = x;
            p.y = y;
            return p;
        }
    };
    /* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
    exports.inverse = function (p) {
        var x = p.x - this.x0;
        var y = p.y - this.y0;
        var lon, lat;
        if (this.sphere) {
            lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
        } else {
            var ts = Math.exp(-y / (this.a * this.k0));
            lat = phi2z(this.e, ts);
            if (lat === -9999) {
                return null;
            }
        }
        lon = adjust_lon(this.long0 + x / (this.a * this.k0));
        p.x = lon;
        p.y = lat;
        return p;
    };
    exports.names = [
        'Mercator',
        'Popular Visualisation Pseudo Mercator',
        'Mercator_1SP',
        'Mercator_Auxiliary_Sphere',
        'merc'
    ];
},
/*proj4/lib/transform*/
function _(require, module, exports) {
    var D2R = 0.017453292519943295;
    var R2D = 57.29577951308232;
    var PJD_3PARAM = 1;
    var PJD_7PARAM = 2;
    var datum_transform = require(348    /* ./datum_transform */);
    var adjust_axis = require(334    /* ./adjust_axis */);
    var proj = require(333    /* ./Proj */);
    var toPoint = require(339    /* ./common/toPoint */);
    function checkNotWGS(source, dest) {
        return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84';
    }
    module.exports = function transform(source, dest, point) {
        var wgs84;
        if (Array.isArray(point)) {
            point = toPoint(point);
        }
        // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
        if (source.datum && dest.datum && checkNotWGS(source, dest)) {
            wgs84 = new proj('WGS84');
            point = transform(source, wgs84, point);
            source = wgs84;
        }
        // DGR, 2010/11/12
        if (source.axis !== 'enu') {
            point = adjust_axis(source, false, point);
        }
        // Transform source points to long/lat, if they aren't already.
        if (source.projName === 'longlat') {
            point = {
                x: point.x * D2R,
                y: point.y * D2R
            };
        } else {
            if (source.to_meter) {
                point = {
                    x: point.x * source.to_meter,
                    y: point.y * source.to_meter
                };
            }
            point = source.inverse(point);    // Convert Cartesian to longlat
        }
        // Adjust for the prime meridian if necessary
        if (source.from_greenwich) {
            point.x += source.from_greenwich;
        }
        // Convert datums if needed, and if possible.
        point = datum_transform(source.datum, dest.datum, point);
        // Adjust for the prime meridian if necessary
        if (dest.from_greenwich) {
            point = {
                x: point.x - dest.grom_greenwich,
                y: point.y
            };
        }
        if (dest.projName === 'longlat') {
            // convert radians to decimal degrees
            point = {
                x: point.x * R2D,
                y: point.y * R2D
            };
        } else {
            // else project
            point = dest.forward(point);
            if (dest.to_meter) {
                point = {
                    x: point.x / dest.to_meter,
                    y: point.y / dest.to_meter
                };
            }
        }
        // DGR, 2010/11/12
        if (dest.axis !== 'enu') {
            return adjust_axis(dest, true, point);
        }
        return point;
    };
},
/*proj4/lib/wkt*/
function _(require, module, exports) {
    var D2R = 0.017453292519943295;
    var extend = require(351    /* ./extend */);
    function mapit(obj, key, v) {
        obj[key] = v.map(function (aa) {
            var o = {};
            sExpr(aa, o);
            return o;
        }).reduce(function (a, b) {
            return extend(a, b);
        }, {});
    }
    function sExpr(v, obj) {
        var key;
        if (!Array.isArray(v)) {
            obj[v] = true;
            return;
        } else {
            key = v.shift();
            if (key === 'PARAMETER') {
                key = v.shift();
            }
            if (v.length === 1) {
                if (Array.isArray(v[0])) {
                    obj[key] = {};
                    sExpr(v[0], obj[key]);
                } else {
                    obj[key] = v[0];
                }
            } else if (!v.length) {
                obj[key] = true;
            } else if (key === 'TOWGS84') {
                obj[key] = v;
            } else {
                obj[key] = {};
                if ([
                        'UNIT',
                        'PRIMEM',
                        'VERT_DATUM'
                    ].indexOf(key) > -1) {
                    obj[key] = {
                        name: v[0].toLowerCase(),
                        convert: v[1]
                    };
                    if (v.length === 3) {
                        obj[key].auth = v[2];
                    }
                } else if (key === 'SPHEROID') {
                    obj[key] = {
                        name: v[0],
                        a: v[1],
                        rf: v[2]
                    };
                    if (v.length === 4) {
                        obj[key].auth = v[3];
                    }
                } else if ([
                        'GEOGCS',
                        'GEOCCS',
                        'DATUM',
                        'VERT_CS',
                        'COMPD_CS',
                        'LOCAL_CS',
                        'FITTED_CS',
                        'LOCAL_DATUM'
                    ].indexOf(key) > -1) {
                    v[0] = [
                        'name',
                        v[0]
                    ];
                    mapit(obj, key, v);
                } else if (v.every(function (aa) {
                        return Array.isArray(aa);
                    })) {
                    mapit(obj, key, v);
                } else {
                    sExpr(v, obj[key]);
                }
            }
        }
    }
    function rename(obj, params) {
        var outName = params[0];
        var inName = params[1];
        if (!(outName in obj) && inName in obj) {
            obj[outName] = obj[inName];
            if (params.length === 3) {
                obj[outName] = params[2](obj[outName]);
            }
        }
    }
    function d2r(input) {
        return input * D2R;
    }
    function cleanWKT(wkt) {
        if (wkt.type === 'GEOGCS') {
            wkt.projName = 'longlat';
        } else if (wkt.type === 'LOCAL_CS') {
            wkt.projName = 'identity';
            wkt.local = true;
        } else {
            if (typeof wkt.PROJECTION === 'object') {
                wkt.projName = Object.keys(wkt.PROJECTION)[0];
            } else {
                wkt.projName = wkt.PROJECTION;
            }
        }
        if (wkt.UNIT) {
            wkt.units = wkt.UNIT.name.toLowerCase();
            if (wkt.units === 'metre') {
                wkt.units = 'meter';
            }
            if (wkt.UNIT.convert) {
                if (wkt.type === 'GEOGCS') {
                    if (wkt.DATUM && wkt.DATUM.SPHEROID) {
                        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10) * wkt.DATUM.SPHEROID.a;
                    }
                } else {
                    wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
                }
            }
        }
        if (wkt.GEOGCS) {
            //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
            //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
            //}
            if (wkt.GEOGCS.DATUM) {
                wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
            } else {
                wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
            }
            if (wkt.datumCode.slice(0, 2) === 'd_') {
                wkt.datumCode = wkt.datumCode.slice(2);
            }
            if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
                wkt.datumCode = 'nzgd49';
            }
            if (wkt.datumCode === 'wgs_1984') {
                if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
                    wkt.sphere = true;
                }
                wkt.datumCode = 'wgs84';
            }
            if (wkt.datumCode.slice(-6) === '_ferro') {
                wkt.datumCode = wkt.datumCode.slice(0, -6);
            }
            if (wkt.datumCode.slice(-8) === '_jakarta') {
                wkt.datumCode = wkt.datumCode.slice(0, -8);
            }
            if (~wkt.datumCode.indexOf('belge')) {
                wkt.datumCode = 'rnb72';
            }
            if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
                wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
                if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
                    wkt.ellps = 'intl';
                }
                wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
                wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
            }
            if (~wkt.datumCode.indexOf('osgb_1936')) {
                wkt.datumCode = 'osgb36';
            }
        }
        if (wkt.b && !isFinite(wkt.b)) {
            wkt.b = wkt.a;
        }
        function toMeter(input) {
            var ratio = wkt.to_meter || 1;
            return parseFloat(input, 10) * ratio;
        }
        var renamer = function (a) {
            return rename(wkt, a);
        };
        var list = [
            [
                'standard_parallel_1',
                'Standard_Parallel_1'
            ],
            [
                'standard_parallel_2',
                'Standard_Parallel_2'
            ],
            [
                'false_easting',
                'False_Easting'
            ],
            [
                'false_northing',
                'False_Northing'
            ],
            [
                'central_meridian',
                'Central_Meridian'
            ],
            [
                'latitude_of_origin',
                'Latitude_Of_Origin'
            ],
            [
                'latitude_of_origin',
                'Central_Parallel'
            ],
            [
                'scale_factor',
                'Scale_Factor'
            ],
            [
                'k0',
                'scale_factor'
            ],
            [
                'latitude_of_center',
                'Latitude_of_center'
            ],
            [
                'lat0',
                'latitude_of_center',
                d2r
            ],
            [
                'longitude_of_center',
                'Longitude_Of_Center'
            ],
            [
                'longc',
                'longitude_of_center',
                d2r
            ],
            [
                'x0',
                'false_easting',
                toMeter
            ],
            [
                'y0',
                'false_northing',
                toMeter
            ],
            [
                'long0',
                'central_meridian',
                d2r
            ],
            [
                'lat0',
                'latitude_of_origin',
                d2r
            ],
            [
                'lat0',
                'standard_parallel_1',
                d2r
            ],
            [
                'lat1',
                'standard_parallel_1',
                d2r
            ],
            [
                'lat2',
                'standard_parallel_2',
                d2r
            ],
            [
                'alpha',
                'azimuth',
                d2r
            ],
            [
                'srsCode',
                'name'
            ]
        ];
        list.forEach(renamer);
        if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
            wkt.long0 = wkt.longc;
        }
        if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
            wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
            wkt.lat_ts = wkt.lat1;
        }
    }
    module.exports = function (wkt, self) {
        var lisp = JSON.parse((',' + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/, ''));
        var type = lisp.shift();
        var name = lisp.shift();
        lisp.unshift([
            'name',
            name
        ]);
        lisp.unshift([
            'type',
            type
        ]);
        lisp.unshift('output');
        var obj = {};
        sExpr(lisp, obj);
        cleanWKT(obj.output);
        return extend(self, obj.output);
    };
},
/*quickselect/index*/
function _(require, module, exports) {
    module.exports = partialSort;
    // Floyd-Rivest selection algorithm:
    // Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
    // The k-th element will have the (k - left + 1)th smallest value in [left, right]
    function partialSort(arr, k, left, right, compare) {
        left = left || 0;
        right = right || arr.length - 1;
        compare = compare || defaultCompare;
        while (right > left) {
            if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                partialSort(arr, k, newLeft, newRight, compare);
            }
            var t = arr[k];
            var i = left;
            var j = right;
            swap(arr, left, k);
            if (compare(arr[right], t) > 0)
                swap(arr, left, right);
            while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0)
                    i++;
                while (compare(arr[j], t) > 0)
                    j--;
            }
            if (compare(arr[left], t) === 0)
                swap(arr, left, j);
            else {
                j++;
                swap(arr, j, right);
            }
            if (j <= k)
                left = j + 1;
            if (k <= j)
                right = j - 1;
        }
    }
    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }
},
/*rbush/index*/
function _(require, module, exports) {
    module.exports = rbush;
    var quickselect = require(360    /* quickselect */);
    function rbush(maxEntries, format) {
        if (!(this instanceof rbush))
            return new rbush(maxEntries, format);
        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format) {
            this._initFormat(format);
        }
        this.clear();
    }
    rbush.prototype = {
        all: function () {
            return this._all(this.data, []);
        },
        search: function (bbox) {
            var node = this.data, result = [], toBBox = this.toBBox;
            if (!intersects(bbox, node))
                return result;
            var nodesToSearch = [], i, len, child, childBBox;
            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;
                    if (intersects(bbox, childBBox)) {
                        if (node.leaf)
                            result.push(child);
                        else if (contains(bbox, childBBox))
                            this._all(child, result);
                        else
                            nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }
            return result;
        },
        collides: function (bbox) {
            var node = this.data, toBBox = this.toBBox;
            if (!intersects(bbox, node))
                return false;
            var nodesToSearch = [], i, len, child, childBBox;
            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;
                    if (intersects(bbox, childBBox)) {
                        if (node.leaf || contains(bbox, childBBox))
                            return true;
                        nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }
            return false;
        },
        load: function (data) {
            if (!(data && data.length))
                return this;
            if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                    this.insert(data[i]);
                }
                return this;
            }
            // recursively build the tree with the given data from stratch using OMT algorithm
            var node = this._build(data.slice(), 0, data.length - 1, 0);
            if (!this.data.children.length) {
                // save as is if tree is empty
                this.data = node;
            } else if (this.data.height === node.height) {
                // split root if trees have the same height
                this._splitRoot(this.data, node);
            } else {
                if (this.data.height < node.height) {
                    // swap trees if inserted one is bigger
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                }
                // insert the small tree into the large tree at appropriate level
                this._insert(node, this.data.height - node.height - 1, true);
            }
            return this;
        },
        insert: function (item) {
            if (item)
                this._insert(item, this.data.height - 1);
            return this;
        },
        clear: function () {
            this.data = createNode([]);
            return this;
        },
        remove: function (item, equalsFn) {
            if (!item)
                return this;
            var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
            // depth-first iterative tree traversal
            while (node || path.length) {
                if (!node) {
                    // go up
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                }
                if (node.leaf) {
                    // check current node
                    index = findItem(item, node.children, equalsFn);
                    if (index !== -1) {
                        // item found, remove the item and condense tree upwards
                        node.children.splice(index, 1);
                        path.push(node);
                        this._condense(path);
                        return this;
                    }
                }
                if (!goingUp && !node.leaf && contains(node, bbox)) {
                    // go down
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];
                } else if (parent) {
                    // go right
                    i++;
                    node = parent.children[i];
                    goingUp = false;
                } else
                    node = null;    // nothing found
            }
            return this;
        },
        toBBox: function (item) {
            return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function () {
            return this.data;
        },
        fromJSON: function (data) {
            this.data = data;
            return this;
        },
        _all: function (node, result) {
            var nodesToSearch = [];
            while (node) {
                if (node.leaf)
                    result.push.apply(result, node.children);
                else
                    nodesToSearch.push.apply(nodesToSearch, node.children);
                node = nodesToSearch.pop();
            }
            return result;
        },
        _build: function (items, left, right, height) {
            var N = right - left + 1, M = this._maxEntries, node;
            if (N <= M) {
                // reached leaf level; return leaf
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
            }
            if (!height) {
                // target height of the bulk-loaded tree
                height = Math.ceil(Math.log(N) / Math.log(M));
                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
            }
            node = createNode([]);
            node.leaf = false;
            node.height = height;
            // split the items into M mostly square tiles
            var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
            multiSelect(items, left, right, N1, this.compareMinX);
            for (i = left; i <= right; i += N1) {
                right2 = Math.min(i + N1 - 1, right);
                multiSelect(items, i, right2, N2, this.compareMinY);
                for (j = i; j <= right2; j += N2) {
                    right3 = Math.min(j + N2 - 1, right2);
                    // pack each entry recursively
                    node.children.push(this._build(items, j, right3, height - 1));
                }
            }
            calcBBox(node, this.toBBox);
            return node;
        },
        _chooseSubtree: function (bbox, node, level, path) {
            var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
            while (true) {
                path.push(node);
                if (node.leaf || path.length - 1 === level)
                    break;
                minArea = minEnlargement = Infinity;
                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    area = bboxArea(child);
                    enlargement = enlargedArea(bbox, child) - area;
                    // choose entry with the least area enlargement
                    if (enlargement < minEnlargement) {
                        minEnlargement = enlargement;
                        minArea = area < minArea ? area : minArea;
                        targetNode = child;
                    } else if (enlargement === minEnlargement) {
                        // otherwise choose one with the smallest area
                        if (area < minArea) {
                            minArea = area;
                            targetNode = child;
                        }
                    }
                }
                node = targetNode || node.children[0];
            }
            return node;
        },
        _insert: function (item, level, isNode) {
            var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);
            // put the item into the node
            node.children.push(item);
            extend(node, bbox);
            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                    this._split(insertPath, level);
                    level--;
                } else
                    break;
            }
            // adjust bboxes along the insertion path
            this._adjustParentBBoxes(bbox, insertPath, level);
        },
        // split overflowed node into two
        _split: function (insertPath, level) {
            var node = insertPath[level], M = node.children.length, m = this._minEntries;
            this._chooseSplitAxis(node, m, M);
            var splitIndex = this._chooseSplitIndex(node, m, M);
            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;
            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);
            if (level)
                insertPath[level - 1].children.push(newNode);
            else
                this._splitRoot(node, newNode);
        },
        _splitRoot: function (node, newNode) {
            // split root node
            this.data = createNode([
                node,
                newNode
            ]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function (node, m, M) {
            var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
            minOverlap = minArea = Infinity;
            for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);
                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);
                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;
                    minArea = area < minArea ? area : minArea;
                } else if (overlap === minOverlap) {
                    // otherwise choose distribution with minimum area
                    if (area < minArea) {
                        minArea = area;
                        index = i;
                    }
                }
            }
            return index;
        },
        // sorts node children by the best axis for split
        _chooseSplitAxis: function (node, m, M) {
            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin)
                node.children.sort(compareMinX);
        },
        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function (node, m, M, compare) {
            node.children.sort(compare);
            var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
            for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
            }
            for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
            }
            return margin;
        },
        _adjustParentBBoxes: function (bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
            }
        },
        _condense: function (path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                    if (i > 0) {
                        siblings = path[i - 1].children;
                        siblings.splice(siblings.indexOf(path[i]), 1);
                    } else
                        this.clear();
                } else
                    calcBBox(path[i], this.toBBox);
            }
        },
        _initFormat: function (format) {
            // data format (minX, minY, maxX, maxY accessors)
            // uses eval-type function compilation instead of just accepting a toBBox function
            // because the algorithms are very sensitive to sorting functions performance,
            // so they should be dead simple and without inner calls
            var compareArr = [
                'return a',
                ' - b',
                ';'
            ];
            this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
            this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
            this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
        }
    };
    function findItem(item, items, equalsFn) {
        if (!equalsFn)
            return items.indexOf(item);
        for (var i = 0; i < items.length; i++) {
            if (equalsFn(item, items[i]))
                return i;
        }
        return -1;
    }
    // calculate node's bbox from bboxes of its children
    function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
    }
    // min bounding rectangle of node children from k to p-1
    function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode)
            destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
    }
    function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
    }
    function compareNodeMinX(a, b) {
        return a.minX - b.minX;
    }
    function compareNodeMinY(a, b) {
        return a.minY - b.minY;
    }
    function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
    }
    function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
    }
    function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }
    function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }
    function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }
    function intersects(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }
    function createNode(children) {
        return {
            children: children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
    }
    // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach
    function multiSelect(arr, left, right, n, compare) {
        var stack = [
                left,
                right
            ], mid;
        while (stack.length) {
            right = stack.pop();
            left = stack.pop();
            if (right - left <= n)
                continue;
            mid = left + Math.ceil((right - left) / n / 2) * n;
            quickselect(arr, mid, left, right, compare);
            stack.push(left, mid, mid, right);
        }
    }
},
/* global window, exports, define */
/*sprintf-js/src/sprintf*/
function _(require, module, exports) {
    !function () {
        'use strict';
        var re = {
            not_string: /[^s]/,
            not_bool: /[^t]/,
            not_type: /[^T]/,
            not_primitive: /[^v]/,
            number: /[diefg]/,
            numeric_arg: /[bcdiefguxX]/,
            json: /[j]/,
            not_json: /[^j]/,
            text: /^[^\x25]+/,
            modulo: /^\x25{2}/,
            placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
            key: /^([a-z_][a-z_\d]*)/i,
            key_access: /^\.([a-z_][a-z_\d]*)/i,
            index_access: /^\[(\d+)\]/,
            sign: /^[\+\-]/
        };
        function sprintf(key) {
            // `arguments` is not an array, but should be fine for this call
            return sprintf_format(sprintf_parse(key), arguments);
        }
        function vsprintf(fmt, argv) {
            return sprintf.apply(null, [fmt].concat(argv || []));
        }
        function sprintf_format(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign;
            for (i = 0; i < tree_length; i++) {
                if (typeof parse_tree[i] === 'string') {
                    output += parse_tree[i];
                } else if (Array.isArray(parse_tree[i])) {
                    match = parse_tree[i];
                    // convenience purposes only
                    if (match[2]) {
                        // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    } else if (match[1]) {
                        // positional argument (explicit)
                        arg = argv[match[1]];
                    } else {
                        // positional argument (implicit)
                        arg = argv[cursor++];
                    }
                    if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {
                        arg = arg();
                    }
                    if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {
                        throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
                    }
                    if (re.number.test(match[8])) {
                        is_positive = arg >= 0;
                    }
                    switch (match[8]) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2);
                        break;
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10));
                        break;
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10);
                        break;
                    case 'j':
                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
                        break;
                    case 'e':
                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();
                        break;
                    case 'f':
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                        break;
                    case 'g':
                        arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg);
                        break;
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8);
                        break;
                    case 's':
                        arg = String(arg);
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 't':
                        arg = String(!!arg);
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0;
                        break;
                    case 'v':
                        arg = arg.valueOf();
                        arg = match[7] ? arg.substring(0, match[7]) : arg;
                        break;
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16);
                        break;
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                        break;
                    }
                    if (re.json.test(match[8])) {
                        output += arg;
                    } else {
                        if (re.number.test(match[8]) && (!is_positive || match[3])) {
                            sign = is_positive ? '+' : '-';
                            arg = arg.toString().replace(re.sign, '');
                        } else {
                            sign = '';
                        }
                        pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';
                        pad_length = match[6] - (sign + arg).length;
                        pad = match[6] ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
                        output += match[5] ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
                    }
                }
            }
            return output;
        }
        var sprintf_cache = Object.create(null);
        function sprintf_parse(fmt) {
            if (sprintf_cache[fmt]) {
                return sprintf_cache[fmt];
            }
            var _fmt = fmt, match, parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = re.text.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                } else if ((match = re.modulo.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                } else if ((match = re.placeholder.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = re.key.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                } else {
                                    throw new SyntaxError('[sprintf] failed to parse named argument key');
                                }
                            }
                        } else {
                            throw new SyntaxError('[sprintf] failed to parse named argument key');
                        }
                        match[2] = field_list;
                    } else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                } else {
                    throw new SyntaxError('[sprintf] unexpected placeholder');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return sprintf_cache[fmt] = parse_tree;
        }
        /**
     * export to either browser or node.js
     */
        /* eslint-disable quote-props */
        if (typeof exports !== 'undefined') {
            exports['sprintf'] = sprintf;
            exports['vsprintf'] = vsprintf;
        }
        if (typeof window !== 'undefined') {
            window['sprintf'] = sprintf;
            window['vsprintf'] = vsprintf;
            if (typeof define === 'function' && define['amd']) {
                define(function () {
                    return {
                        'sprintf': sprintf,
                        'vsprintf': vsprintf
                    };
                });
            }
        }    /* eslint-enable quote-props */
    }();
},
/*timezone/index*/
function _(require, module, exports) {
    !function (definition) {
        if (typeof module == 'object' && module.exports)
            module.exports = definition();
        else if (typeof define == 'function')
            define(definition);
        else
            this.tz = definition();
    }(function () {
        /*
  function die () {
    console.log.apply(console, __slice.call(arguments, 0));
    return process.exit(1);
  }

  function say () { return console.log.apply(console, __slice.call(arguments, 0)) }
*/
        function actualize(entry, rule, year) {
            var actualized, date = rule.day[1];
            do {
                actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));
            } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0]);
            actualized = {
                clock: rule.clock,
                sort: actualized.getTime(),
                rule: rule,
                save: rule.save * 60000,
                offset: entry.offset
            };
            actualized[actualized.clock] = actualized.sort + rule.time * 60000;
            if (actualized.posix) {
                actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);
            } else {
                actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);
            }
            return actualized;
        }
        function find(request, clock, time) {
            var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules, j, year = new Date(time).getUTCFullYear(), off = 1;
            for (i = 1, I = zone.length; i < I; i++)
                if (zone[i][clock] <= time)
                    break;
            entry = zone[i];
            if (entry.rules) {
                rules = request[entry.rules];
                for (j = year + 1; j >= year - off; --j)
                    for (i = 0, I = rules.length; i < I; i++)
                        if (rules[i].from <= j && j <= rules[i].to)
                            actualized.push(actualize(entry, rules[i], j));
                        else if (rules[i].to < j && off == 1)
                            off = j - rules[i].to;
                actualized.sort(function (a, b) {
                    return a.sort - b.sort;
                });
                for (i = 0, I = actualized.length; i < I; i++) {
                    if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock])
                        found = actualized[i];
                }
            }
            if (found) {
                if (abbrev = /^(.*)\/(.*)$/.exec(entry.format)) {
                    found.abbrev = abbrev[found.save ? 2 : 1];
                } else {
                    found.abbrev = entry.format.replace(/%s/, found.rule.letter);
                }
            }
            return found || entry;
        }
        function convertToWallclock(request, posix) {
            if (request.zone == 'UTC')
                return posix;
            request.entry = find(request, 'posix', posix);
            return posix + request.entry.offset + request.entry.save;
        }
        function convertToPOSIX(request, wallclock) {
            if (request.zone == 'UTC')
                return wallclock;
            var entry, diff;
            request.entry = entry = find(request, 'wallclock', wallclock);
            diff = wallclock - entry.wallclock;
            return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;
        }
        function adjust(request, posix, match) {
            var increment = +(match[1] + 1)    // conversion necessary for week day addition
, offset = match[2] * increment, index = UNITS.indexOf(match[3].toLowerCase()), date;
            if (index > 9) {
                posix += offset * TIME[index - 10];
            } else {
                date = new Date(convertToWallclock(request, posix));
                if (index < 7) {
                    while (offset) {
                        date.setUTCDate(date.getUTCDate() + increment);
                        if (date.getUTCDay() == index)
                            offset -= increment;
                    }
                } else if (index == 7) {
                    date.setUTCFullYear(date.getUTCFullYear() + offset);
                } else if (index == 8) {
                    date.setUTCMonth(date.getUTCMonth() + offset);
                } else {
                    date.setUTCDate(date.getUTCDate() + offset);
                }
                if ((posix = convertToPOSIX(request, date.getTime())) == null) {
                    posix = convertToPOSIX(request, date.getTime() + 86400000 * increment) - 86400000 * increment;
                }
            }
            return posix;
        }
        function convert(vargs) {
            if (!vargs.length)
                return '1.0.13';
            var request = Object.create(this), adjustments = [], i, I, $, argument, date;
            for (i = 0; i < vargs.length; i++) {
                // leave the for loop alone, it works.
                argument = vargs[i];
                // https://twitter.com/bigeasy/status/215112186572439552
                if (Array.isArray(argument)) {
                    if (!i && !isNaN(argument[1])) {
                        date = argument;
                    } else {
                        argument.splice.apply(vargs, [
                            i--,
                            1
                        ].concat(argument));
                    }
                } else if (isNaN(argument)) {
                    $ = typeof argument;
                    if ($ == 'string') {
                        if (~argument.indexOf('%')) {
                            request.format = argument;
                        } else if (!i && argument == '*') {
                            date = argument;
                        } else if (!i && ($ = /^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d+))?)?(Z|(([+-])(\d{2}(:\d{2}){0,2})))?)?$/.exec(argument))) {
                            date = [];
                            date.push.apply(date, $.slice(1, 8));
                            if ($[9]) {
                                date.push($[10] + 1);
                                date.push.apply(date, $[11].split(/:/));
                            } else if ($[8]) {
                                date.push(1);
                            }
                        } else if (/^\w{2,3}_\w{2}$/.test(argument)) {
                            request.locale = argument;
                        } else if ($ = UNIT_RE.exec(argument)) {
                            adjustments.push($);
                        } else {
                            request.zone = argument;
                        }
                    } else if ($ == 'function') {
                        if ($ = argument.call(request))
                            return $;
                    } else if (/^\w{2,3}_\w{2}$/.test(argument.name)) {
                        request[argument.name] = argument;
                    } else if (argument.zones) {
                        for ($ in argument.zones)
                            request[$] = argument.zones[$];
                        for ($ in argument.rules)
                            request[$] = argument.rules[$];
                    }
                } else if (!i) {
                    date = argument;
                }
            }
            if (!request[request.locale])
                delete request.locale;
            if (!request[request.zone])
                delete request.zone;
            if (date != null) {
                if (date == '*') {
                    date = request.clock();
                } else if (Array.isArray(date)) {
                    $ = [];
                    I = !date[7];
                    for (i = 0; i < 11; i++)
                        $[i] = +(date[i] || 0);
                    // conversion necessary for decrement
                    --$[1];
                    // Grr..
                    date = Date.UTC.apply(Date.UTC, $) + -$[7] * ($[8] * 3600000 + $[9] * 60000 + $[10] * 1000);
                } else {
                    date = Math.floor(date);
                }
                if (!isNaN(date)) {
                    if (I)
                        date = convertToPOSIX(request, date);
                    if (date == null)
                        return date;
                    for (i = 0, I = adjustments.length; i < I; i++) {
                        date = adjust(request, date, adjustments[i]);
                    }
                    if (!request.format)
                        return date;
                    $ = new Date(convertToWallclock(request, date));
                    return request.format.replace(/%([-0_^]?)(:{0,3})(\d*)(.)/g, function (value, flag, colons, padding, specifier) {
                        var f, fill = '0', pad;
                        if (f = request[specifier]) {
                            value = String(f.call(request, $, date, flag, colons.length));
                            if ((flag || f.style) == '_')
                                fill = ' ';
                            pad = flag == '-' ? 0 : f.pad || 0;
                            while (value.length < pad)
                                value = fill + value;
                            pad = flag == '-' ? 0 : padding || f.pad;
                            while (value.length < pad)
                                value = fill + value;
                            if (specifier == 'N' && pad < value.length)
                                value = value.slice(0, pad);
                            if (flag == '^')
                                value = value.toUpperCase();
                        }
                        return value;
                    });
                }
            }
            return function () {
                return request.convert(arguments);
            };
        }
        var context = {
            clock: function () {
                return +new Date();
            },
            zone: 'UTC',
            entry: {
                abbrev: 'UTC',
                offset: 0,
                save: 0
            },
            UTC: 1,
            z: function (date, posix, flag, delimiters) {
                var offset = this.entry.offset + this.entry.save, seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;
                for (i = 0; i < 3; i++) {
                    parts.push(('0' + Math.floor(seconds / part)).slice(-2));
                    seconds %= part;
                    part /= 60;
                }
                if (flag == '^' && !offset)
                    return 'Z';
                if (flag == '^')
                    delimiters = 3;
                if (delimiters == 3) {
                    z = parts.join(':');
                    z = z.replace(/:00$/, '');
                    if (flag != '^')
                        z = z.replace(/:00$/, '');
                } else if (delimiters) {
                    z = parts.slice(0, delimiters + 1).join(':');
                    if (flag == '^')
                        z = z.replace(/:00$/, '');
                } else {
                    z = parts.slice(0, 2).join('');
                }
                z = (offset < 0 ? '-' : '+') + z;
                z = z.replace(/([-+])(0)/, {
                    '_': ' $1',
                    '-': '$1'
                }[flag] || '$1$2');
                return z;
            },
            '%': function (date) {
                return '%';
            },
            n: function (date) {
                return '\n';
            },
            t: function (date) {
                return '\t';
            },
            U: function (date) {
                return weekOfYear(date, 0);
            },
            W: function (date) {
                return weekOfYear(date, 1);
            },
            V: function (date) {
                return isoWeek(date)[0];
            },
            G: function (date) {
                return isoWeek(date)[1];
            },
            g: function (date) {
                return isoWeek(date)[1] % 100;
            },
            j: function (date) {
                return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 86400000) + 1;
            },
            s: function (date) {
                return Math.floor(date.getTime() / 1000);
            },
            C: function (date) {
                return Math.floor(date.getUTCFullYear() / 100);
            },
            N: function (date) {
                return date.getTime() % 1000 * 1000000;
            },
            m: function (date) {
                return date.getUTCMonth() + 1;
            },
            Y: function (date) {
                return date.getUTCFullYear();
            },
            y: function (date) {
                return date.getUTCFullYear() % 100;
            },
            H: function (date) {
                return date.getUTCHours();
            },
            M: function (date) {
                return date.getUTCMinutes();
            },
            S: function (date) {
                return date.getUTCSeconds();
            },
            e: function (date) {
                return date.getUTCDate();
            },
            d: function (date) {
                return date.getUTCDate();
            },
            u: function (date) {
                return date.getUTCDay() || 7;
            },
            w: function (date) {
                return date.getUTCDay();
            },
            l: function (date) {
                return date.getUTCHours() % 12 || 12;
            },
            I: function (date) {
                return date.getUTCHours() % 12 || 12;
            },
            k: function (date) {
                return date.getUTCHours();
            },
            Z: function (date) {
                return this.entry.abbrev;
            },
            a: function (date) {
                return this[this.locale].day.abbrev[date.getUTCDay()];
            },
            A: function (date) {
                return this[this.locale].day.full[date.getUTCDay()];
            },
            h: function (date) {
                return this[this.locale].month.abbrev[date.getUTCMonth()];
            },
            b: function (date) {
                return this[this.locale].month.abbrev[date.getUTCMonth()];
            },
            B: function (date) {
                return this[this.locale].month.full[date.getUTCMonth()];
            },
            P: function (date) {
                return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase();
            },
            p: function (date) {
                return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)];
            },
            R: function (date, posix) {
                return this.convert([
                    posix,
                    '%H:%M'
                ]);
            },
            T: function (date, posix) {
                return this.convert([
                    posix,
                    '%H:%M:%S'
                ]);
            },
            D: function (date, posix) {
                return this.convert([
                    posix,
                    '%m/%d/%y'
                ]);
            },
            F: function (date, posix) {
                return this.convert([
                    posix,
                    '%Y-%m-%d'
                ]);
            },
            x: function (date, posix) {
                return this.convert([
                    posix,
                    this[this.locale].date
                ]);
            },
            r: function (date, posix) {
                return this.convert([
                    posix,
                    this[this.locale].time12 || '%I:%M:%S'
                ]);
            },
            X: function (date, posix) {
                return this.convert([
                    posix,
                    this[this.locale].time24
                ]);
            },
            c: function (date, posix) {
                return this.convert([
                    posix,
                    this[this.locale].dateTime
                ]);
            },
            convert: convert,
            locale: 'en_US',
            en_US: {
                date: '%m/%d/%Y',
                time24: '%I:%M:%S %p',
                time12: '%I:%M:%S %p',
                dateTime: '%a %d %b %Y %I:%M:%S %p %Z',
                meridiem: [
                    'AM',
                    'PM'
                ],
                month: {
                    abbrev: 'Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec'.split('|'),
                    full: 'January|February|March|April|May|June|July|August|September|October|November|December'.split('|')
                },
                day: {
                    abbrev: 'Sun|Mon|Tue|Wed|Thu|Fri|Sat'.split('|'),
                    full: 'Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday'.split('|')
                }
            }
        };
        var UNITS = 'Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond', UNIT_RE = new RegExp('^\\s*([+-])(\\d+)\\s+(' + UNITS + ')s?\\s*$', 'i'), TIME = [
                3600000,
                60000,
                1000,
                1
            ];
        UNITS = UNITS.toLowerCase().split('|');
        'delmHMSUWVgCIky'.replace(/./g, function (e) {
            context[e].pad = 2;
        });
        context.N.pad = 9;
        context.j.pad = 3;
        context.k.style = '_';
        context.l.style = '_';
        context.e.style = '_';
        function weekOfYear(date, startOfWeek) {
            var diff, nyd, weekStart;
            nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));
            diff = Math.floor((date.getTime() - nyd.getTime()) / 86400000);
            if (nyd.getUTCDay() == startOfWeek) {
                weekStart = 0;
            } else {
                weekStart = 7 - nyd.getUTCDay() + startOfWeek;
                if (weekStart == 8) {
                    weekStart = 1;
                }
            }
            return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;
        }
        function isoWeek(date) {
            var nyd, nyy, week;
            nyy = date.getUTCFullYear();
            nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
            week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);
            if (!week) {
                nyy = date.getUTCFullYear() - 1;
                nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
                week = nyd == 4 || nyd == 3 && new Date(nyy, 1, 29).getDate() == 29 ? 53 : 52;
                return [
                    week,
                    date.getUTCFullYear() - 1
                ];
            } else if (week == 53 && !(nyd == 4 || nyd == 3 && new Date(nyy, 1, 29).getDate() == 29)) {
                return [
                    1,
                    date.getUTCFullYear() + 1
                ];
            } else {
                return [
                    week,
                    date.getUTCFullYear()
                ];
            }
        }
        return function () {
            return context.convert(arguments);
        };
    });
},
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
/*tslib/tslib*/
function _(require, module, exports) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    (function (factory) {
        var root = typeof global === 'object' ? global : typeof self === 'object' ? self : typeof this === 'object' ? this : {};
        if (typeof define === 'function' && define.amd) {
            define('tslib', ['exports'], function (exports) {
                factory(createExporter(root, createExporter(exports)));
            });
        } else if (typeof module === 'object' && typeof module.exports === 'object') {
            factory(createExporter(root, createExporter(module.exports)));
        } else {
            factory(createExporter(root));
        }
        function createExporter(exports, previous) {
            if (typeof Object.create === 'function') {
                Object.defineProperty(exports, '__esModule', { value: true });
            } else {
                exports.__esModule = true;
            }
            return function (id, v) {
                return exports[id] = previous ? previous(id, v) : v;
            };
        }
    }(function (exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p];
        };
        __extends = function (d, b) {
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        __rest = function (s, e) {
            var t = {};
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                    t[p] = s[p];
            if (s != null && typeof Object.getOwnPropertySymbols === 'function')
                for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
                    if (e.indexOf(p[i]) < 0)
                        t[p[i]] = s[p[i]];
            return t;
        };
        __decorate = function (decorators, target, key, desc) {
            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
            if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
                r = Reflect.decorate(decorators, target, key, desc);
            else
                for (var i = decorators.length - 1; i >= 0; i--)
                    if (d = decorators[i])
                        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param = function (paramIndex, decorator) {
            return function (target, key) {
                decorator(target, key, paramIndex);
            };
        };
        __metadata = function (metadataKey, metadataValue) {
            if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
                return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter = function (thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator['throw'](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : new P(function (resolve) {
                        resolve(result.value);
                    }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        __generator = function (thisArg, body) {
            var _ = {
                    label: 0,
                    sent: function () {
                        if (t[0] & 1)
                            throw t[1];
                        return t[1];
                    },
                    trys: [],
                    ops: []
                }, f, y, t, g;
            return g = {
                next: verb(0),
                'throw': verb(1),
                'return': verb(2)
            }, typeof Symbol === 'function' && (g[Symbol.iterator] = function () {
                return this;
            }), g;
            function verb(n) {
                return function (v) {
                    return step([
                        n,
                        v
                    ]);
                };
            }
            function step(op) {
                if (f)
                    throw new TypeError('Generator is already executing.');
                while (_)
                    try {
                        if (f = 1, y && (t = y[op[0] & 2 ? 'return' : op[0] ? 'throw' : 'next']) && !(t = t.call(y, op[1])).done)
                            return t;
                        if (y = 0, t)
                            op = [
                                0,
                                t.value
                            ];
                        switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return {
                                value: op[1],
                                done: false
                            };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [
                            6,
                            e
                        ];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                if (op[0] & 5)
                    throw op[1];
                return {
                    value: op[0] ? op[1] : void 0,
                    done: true
                };
            }
        };
        __exportStar = function (m, exports) {
            for (var p in m)
                if (!exports.hasOwnProperty(p))
                    exports[p] = m[p];
        };
        __values = function (o) {
            var m = typeof Symbol === 'function' && o[Symbol.iterator], i = 0;
            if (m)
                return m.call(o);
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return {
                        value: o && o[i++],
                        done: !o
                    };
                }
            };
        };
        __read = function (o, n) {
            var m = typeof Symbol === 'function' && o[Symbol.iterator];
            if (!m)
                return o;
            var i = m.call(o), r, ar = [], e;
            try {
                while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                    ar.push(r.value);
            } catch (error) {
                e = { error: error };
            } finally {
                try {
                    if (r && !r.done && (m = i['return']))
                        m.call(i);
                } finally {
                    if (e)
                        throw e.error;
                }
            }
            return ar;
        };
        __spread = function () {
            for (var ar = [], i = 0; i < arguments.length; i++)
                ar = ar.concat(__read(arguments[i]));
            return ar;
        };
        __await = function (v) {
            return this instanceof __await ? (this.v = v, this) : new __await(v);
        };
        __asyncGenerator = function (thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator)
                throw new TypeError('Symbol.asyncIterator is not defined.');
            var g = generator.apply(thisArg, _arguments || []), i, q = [];
            return i = {}, verb('next'), verb('throw'), verb('return'), i[Symbol.asyncIterator] = function () {
                return this;
            }, i;
            function verb(n) {
                if (g[n])
                    i[n] = function (v) {
                        return new Promise(function (a, b) {
                            q.push([
                                n,
                                v,
                                a,
                                b
                            ]) > 1 || resume(n, v);
                        });
                    };
            }
            function resume(n, v) {
                try {
                    step(g[n](v));
                } catch (e) {
                    settle(q[0][3], e);
                }
            }
            function step(r) {
                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            }
            function fulfill(value) {
                resume('next', value);
            }
            function reject(value) {
                resume('throw', value);
            }
            function settle(f, v) {
                if (f(v), q.shift(), q.length)
                    resume(q[0][0], q[0][1]);
            }
        };
        __asyncDelegator = function (o) {
            var i, p;
            return i = {}, verb('next'), verb('throw', function (e) {
                throw e;
            }), verb('return'), i[Symbol.iterator] = function () {
                return this;
            }, i;
            function verb(n, f) {
                if (o[n])
                    i[n] = function (v) {
                        return (p = !p) ? {
                            value: __await(o[n](v)),
                            done: n === 'return'
                        } : f ? f(v) : v;
                    };
            }
        };
        __asyncValues = function (o) {
            if (!Symbol.asyncIterator)
                throw new TypeError('Symbol.asyncIterator is not defined.');
            var m = o[Symbol.asyncIterator];
            return m ? m.call(o) : typeof __values === 'function' ? __values(o) : o[Symbol.iterator]();
        };
        __makeTemplateObject = function (cooked, raw) {
            if (Object.defineProperty) {
                Object.defineProperty(cooked, 'raw', { value: raw });
            } else {
                cooked.raw = raw;
            }
            return cooked;
        };
        exporter('__extends', __extends);
        exporter('__assign', __assign);
        exporter('__rest', __rest);
        exporter('__decorate', __decorate);
        exporter('__param', __param);
        exporter('__metadata', __metadata);
        exporter('__awaiter', __awaiter);
        exporter('__generator', __generator);
        exporter('__exportStar', __exportStar);
        exporter('__values', __values);
        exporter('__read', __read);
        exporter('__spread', __spread);
        exporter('__await', __await);
        exporter('__asyncGenerator', __asyncGenerator);
        exporter('__asyncDelegator', __asyncDelegator);
        exporter('__asyncValues', __asyncValues);
        exporter('__makeTemplateObject', __makeTemplateObject);
    }));
}
], {"base":0,"client/connection":1,"client/session":2,"core/bokeh_events":3,"core/build_views":4,"core/dom":5,"core/dom_view":6,"core/enums":7,"core/has_props":8,"core/hittest":9,"core/layout/alignments":10,"core/layout/layout_canvas":11,"core/layout/side_panel":12,"core/layout/solver":13,"core/logging":14,"core/properties":15,"core/property_mixins":16,"core/selection_manager":17,"core/selector":18,"core/settings":19,"core/signaling":20,"core/ui_events":21,"core/util/array":22,"core/util/bbox":23,"core/util/callback":24,"core/util/canvas":25,"core/util/color":26,"core/util/data_structures":27,"core/util/eq":28,"core/util/math":29,"core/util/object":30,"core/util/proj4":31,"core/util/projections":32,"core/util/refs":33,"core/util/selection":34,"core/util/serialization":35,"core/util/spatial":36,"core/util/string":37,"core/util/svg_colors":38,"core/util/templating":39,"core/util/text":40,"core/util/throttle":41,"core/util/types":42,"core/util/wheel":43,"core/util/zoom":44,"core/view":45,"core/visuals":46,"document":47,"embed":48,"main":49,"model":50,"models/annotations/annotation":51,"models/annotations/arrow":52,"models/annotations/arrow_head":53,"models/annotations/band":54,"models/annotations/box_annotation":55,"models/annotations/color_bar":56,"models/annotations/index":57,"models/annotations/label":58,"models/annotations/label_set":59,"models/annotations/legend":60,"models/annotations/legend_item":61,"models/annotations/poly_annotation":62,"models/annotations/span":63,"models/annotations/text_annotation":64,"models/annotations/title":65,"models/annotations/toolbar_panel":66,"models/annotations/tooltip":67,"models/annotations/whisker":68,"models/axes/axis":69,"models/axes/categorical_axis":70,"models/axes/continuous_axis":71,"models/axes/datetime_axis":72,"models/axes/index":73,"models/axes/linear_axis":74,"models/axes/log_axis":75,"models/callbacks/customjs":76,"models/callbacks/index":77,"models/callbacks/open_url":78,"models/canvas/canvas":79,"models/canvas/cartesian_frame":80,"models/canvas/index":81,"models/expressions/expression":82,"models/expressions/index":83,"models/expressions/stack":84,"models/filters/boolean_filter":85,"models/filters/customjs_filter":86,"models/filters/filter":87,"models/filters/group_filter":88,"models/filters/index":89,"models/filters/index_filter":90,"models/formatters/basic_tick_formatter":91,"models/formatters/categorical_tick_formatter":92,"models/formatters/datetime_tick_formatter":93,"models/formatters/func_tick_formatter":94,"models/formatters/index":95,"models/formatters/log_tick_formatter":96,"models/formatters/mercator_tick_formatter":97,"models/formatters/numeral_tick_formatter":98,"models/formatters/printf_tick_formatter":99,"models/formatters/tick_formatter":100,"models/glyphs/annular_wedge":101,"models/glyphs/annulus":102,"models/glyphs/arc":103,"models/glyphs/bezier":104,"models/glyphs/box":105,"models/glyphs/circle":106,"models/glyphs/ellipse":107,"models/glyphs/glyph":108,"models/glyphs/hbar":109,"models/glyphs/image":110,"models/glyphs/image_rgba":111,"models/glyphs/image_url":112,"models/glyphs/index":113,"models/glyphs/line":114,"models/glyphs/multi_line":115,"models/glyphs/oval":116,"models/glyphs/patch":117,"models/glyphs/patches":118,"models/glyphs/quad":119,"models/glyphs/quadratic":120,"models/glyphs/ray":121,"models/glyphs/rect":122,"models/glyphs/segment":123,"models/glyphs/step":124,"models/glyphs/text":125,"models/glyphs/vbar":126,"models/glyphs/wedge":127,"models/glyphs/xy_glyph":128,"models/graphs/graph_hit_test_policy":129,"models/graphs/index":130,"models/graphs/layout_provider":131,"models/graphs/static_layout_provider":132,"models/grids/grid":133,"models/grids/index":134,"models/index":135,"models/layouts/box":136,"models/layouts/column":137,"models/layouts/index":138,"models/layouts/layout_dom":139,"models/layouts/row":140,"models/layouts/spacer":141,"models/layouts/widget_box":142,"models/mappers/categorical_color_mapper":143,"models/mappers/color_mapper":144,"models/mappers/index":145,"models/mappers/linear_color_mapper":146,"models/mappers/log_color_mapper":147,"models/markers/index":148,"models/markers/marker":149,"models/plots/gmap_plot":150,"models/plots/gmap_plot_canvas":151,"models/plots/index":152,"models/plots/plot":153,"models/plots/plot_canvas":154,"models/ranges/data_range":155,"models/ranges/data_range1d":156,"models/ranges/factor_range":157,"models/ranges/index":158,"models/ranges/range":159,"models/ranges/range1d":160,"models/renderers/glyph_renderer":161,"models/renderers/graph_renderer":162,"models/renderers/guide_renderer":163,"models/renderers/index":164,"models/renderers/renderer":165,"models/scales/categorical_scale":166,"models/scales/index":167,"models/scales/linear_scale":168,"models/scales/log_scale":169,"models/scales/scale":170,"models/sources/ajax_data_source":171,"models/sources/cds_view":172,"models/sources/column_data_source":173,"models/sources/columnar_data_source":174,"models/sources/data_source":175,"models/sources/geojson_data_source":176,"models/sources/index":177,"models/sources/remote_data_source":178,"models/tickers/adaptive_ticker":179,"models/tickers/basic_ticker":180,"models/tickers/categorical_ticker":181,"models/tickers/composite_ticker":182,"models/tickers/continuous_ticker":183,"models/tickers/datetime_ticker":184,"models/tickers/days_ticker":185,"models/tickers/fixed_ticker":186,"models/tickers/index":187,"models/tickers/log_ticker":188,"models/tickers/mercator_ticker":189,"models/tickers/months_ticker":190,"models/tickers/single_interval_ticker":191,"models/tickers/ticker":192,"models/tickers/util":193,"models/tickers/years_ticker":194,"models/tiles/bbox_tile_source":195,"models/tiles/dynamic_image_renderer":196,"models/tiles/image_pool":197,"models/tiles/image_source":198,"models/tiles/index":199,"models/tiles/mercator_tile_source":200,"models/tiles/quadkey_tile_source":201,"models/tiles/tile_renderer":202,"models/tiles/tile_source":203,"models/tiles/tile_utils":204,"models/tiles/tms_tile_source":205,"models/tiles/wmts_tile_source":206,"models/tools/actions/action_tool":207,"models/tools/actions/help_tool":208,"models/tools/actions/redo_tool":209,"models/tools/actions/reset_tool":210,"models/tools/actions/save_tool":211,"models/tools/actions/undo_tool":212,"models/tools/actions/zoom_in_tool":213,"models/tools/actions/zoom_out_tool":214,"models/tools/button_tool":215,"models/tools/gestures/box_select_tool":216,"models/tools/gestures/box_zoom_tool":217,"models/tools/gestures/gesture_tool":218,"models/tools/gestures/lasso_select_tool":219,"models/tools/gestures/pan_tool":220,"models/tools/gestures/poly_select_tool":221,"models/tools/gestures/select_tool":222,"models/tools/gestures/tap_tool":223,"models/tools/gestures/wheel_pan_tool":224,"models/tools/gestures/wheel_zoom_tool":225,"models/tools/index":226,"models/tools/inspectors/crosshair_tool":227,"models/tools/inspectors/hover_tool":228,"models/tools/inspectors/inspect_tool":229,"models/tools/on_off_button":230,"models/tools/tool":231,"models/tools/tool_proxy":232,"models/tools/toolbar":233,"models/tools/toolbar_base":234,"models/tools/toolbar_box":235,"models/transforms/customjs_transform":236,"models/transforms/dodge":237,"models/transforms/index":238,"models/transforms/interpolator":239,"models/transforms/jitter":240,"models/transforms/linear_interpolator":241,"models/transforms/step_interpolator":242,"models/transforms/transform":243,"polyfill":244,"protocol/message":245,"protocol/receiver":246,"safely":247,"version":248}, 49);
})

//# sourceMappingURL=bokeh.js.map
